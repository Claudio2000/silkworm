--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         37748736 B, 64 B, 18-way associative
Command:          /home/mriccobene/CLionProjects/silkworm/cmake-build-release/cmd/api/execute --lib_path /home/mriccobene/CLionProjects/silkworm/cmake-build-release/silkworm/api/libsilkworm_api.so --data_dir /home/mriccobene/WorkingArea/blockchain/silkworm-1 build_idxes --snapshot_paths /home/mriccobene/WorkingArea/blockchain/silkworm-1/snapshots/v1-000000-000500-headers.seg
Data file:        cachegrind.out.65979
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                      I1mr            ILmr           Dr                     D1mr                DLmr               Dw                     D1mw               DLmw               
--------------------------------------------------------------------------------
31,026,220,058 (100.0%) 17,104 (100.0%) 9,510 (100.0%) 6,601,245,594 (100.0%) 37,866,691 (100.0%) 5,163,739 (100.0%) 2,785,647,277 (100.0%) 3,132,931 (100.0%) 2,367,000 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr           ILmr         Dr                     D1mr                DLmr               Dw                     D1mw             DLmw              file:function
--------------------------------------------------------------------------------
9,208,102,418 (29.68%)    33 ( 0.19%)  33 ( 0.35%) 1,946,115,334 (29.48%)        275 ( 0.00%)         8 ( 0.00%) 1,028,747,752 (36.93%)      54 ( 0.00%)       4 ( 0.00%)  /home/mriccobene/CLionProjects/silkworm/third_party/ethash/lib/keccak/keccak.c:keccakf1600_bmi
6,712,714,200 (21.64%)    31 ( 0.18%)  31 ( 0.33%)   600,812,752 ( 9.10%)    311,290 ( 0.82%)       333 ( 0.01%)     9,707,716 ( 0.35%) 275,752 ( 8.80%)     560 ( 0.02%)  /home/mriccobene/CLionProjects/silkworm/silkworm/node/recsplit/rec_split.hpp:silkworm::succinct::RecSplit<8ul>::recsplit(int, std::vector<unsigned long, std::allocator<unsigned long> >&, std::vector<unsigned long, std::allocator<unsigned long> >&, unsigned long, unsigned long, std::vector<unsigned int, std::allocator<unsigned int> >&, std::basic_ofstream<char, std::char_traits<char> >&)
3,379,524,188 (10.89%)     6 ( 0.04%)   6 ( 0.06%)   844,328,326 (12.79%)     90,590 ( 0.24%)    90,586 ( 1.75%)   481,831,320 (17.30%)      12 ( 0.00%)       6 ( 0.00%)  /home/mriccobene/CLionProjects/silkworm/silkworm/node/huffman/decompressor.cpp:silkworm::huffman::Decompressor::Iterator::next_position(bool)
2,705,195,016 ( 8.72%)     6 ( 0.04%)   6 ( 0.06%)   659,840,234 (10.00%)     95,583 ( 0.25%)    95,583 ( 1.85%)   390,088,112 (14.00%)       4 ( 0.00%)       2 ( 0.00%)  /home/mriccobene/CLionProjects/silkworm/silkworm/node/huffman/decompressor.cpp:silkworm::huffman::Decompressor::Iterator::next_pattern()
1,278,893,375 ( 4.12%)     1 ( 0.01%)   1 ( 0.01%)   371,994,236 ( 5.64%)  7,175,125 (18.95%)   384,372 ( 7.44%)             0                0                0           /usr/include/c++/11/bits/char_traits.h:silkworm::etl::operator<(silkworm::etl::Entry const&, silkworm::etl::Entry const&)
1,009,031,513 ( 3.25%)     3 ( 0.02%)   3 ( 0.03%)        26,023 ( 0.00%)          0                  0                 26,023 ( 0.00%)       0                0           /home/mriccobene/CLionProjects/silkworm/silkworm/node/recsplit/support/common.hpp:silkworm::succinct::RecSplit<8ul>::recsplit(int, std::vector<unsigned long, std::allocator<unsigned long> >&, std::vector<unsigned long, std::allocator<unsigned long> >&, unsigned long, unsigned long, std::vector<unsigned int, std::allocator<unsigned int> >&, std::basic_ofstream<char, std::char_traits<char> >&)
  783,897,889 ( 2.53%)    12 ( 0.07%)  12 ( 0.13%)    80,566,335 ( 1.22%)         43 ( 0.00%)         4 ( 0.00%)   130,193,726 ( 4.67%)       8 ( 0.00%)       4 ( 0.00%)  /home/mriccobene/CLionProjects/silkworm/silkworm/node/huffman/decompressor.cpp:silkworm::huffman::Decompressor::Iterator::next(std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >&)
  575,441,076 ( 1.85%)     2 ( 0.01%)   2 ( 0.02%)   246,617,604 ( 3.74%)          5 ( 0.00%)         2 ( 0.00%)   123,308,802 ( 4.43%)       0                0           /home/mriccobene/CLionProjects/silkworm/silkworm/node/huffman/decompressor.cpp:silkworm::huffman::PatternTable::search_condensed(unsigned short) const
  503,510,130 ( 1.62%)    53 ( 0.31%)  26 ( 0.27%)   120,458,481 ( 1.82%)  2,582,098 ( 6.82%) 1,171,730 (22.69%)    85,214,226 ( 3.06%) 186,634 ( 5.96%)   3,435 ( 0.15%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms
  417,787,112 ( 1.35%)     9 ( 0.05%)   4 ( 0.04%)   208,893,556 ( 3.16%)        851 ( 0.00%)         5 ( 0.00%)             0                0                0           /home/mriccobene/CLionProjects/silkworm/silkworm/infra/common/log.cpp:silkworm::log::test_verbosity(silkworm::log::Level)
  362,735,730 ( 1.17%)     3 ( 0.02%)   2 ( 0.02%)   120,829,350 ( 1.83%)    571,782 ( 1.51%)       781 ( 0.02%)             0                0                0           /home/mriccobene/CLionProjects/silkworm/silkworm/node/huffman/decompressor.hpp:silkworm::huffman::Decompressor::Iterator::next_position(bool)
  282,513,070 ( 0.91%)     0            0            161,436,040 ( 2.45%)     50,685 ( 0.13%)        19 ( 0.00%)             0                0                0           /usr/include/c++/11/bits/stl_vector.h:silkworm::huffman::Decompressor::Iterator::next_position(bool)
  239,474,716 ( 0.77%)     2 ( 0.01%)   2 ( 0.02%)    71,992,788 ( 1.09%)      3,380 ( 0.01%)         7 ( 0.00%)    37,996,424 ( 1.36%)       0                0           /home/mriccobene/CLionProjects/silkworm/silkworm/core/common/util.cpp:silkworm::to_hex[abi:cxx11](silkworm::ByteView, bool)
  238,161,414 ( 0.77%)   100 ( 0.58%)  47 ( 0.49%)    73,044,801 ( 1.11%)    253,303 ( 0.67%)    21,524 ( 0.42%)    38,445,380 ( 1.38%)   2,069 ( 0.07%)      43 ( 0.00%)  ./malloc/./malloc/malloc.c:_int_free
  198,938,882 ( 0.64%)     3 ( 0.02%)   3 ( 0.03%)    99,469,441 ( 1.51%) 12,950,132 (34.20%) 1,052,871 (20.39%)             0                0                0           /home/mriccobene/CLionProjects/silkworm/silkworm/node/etl/util.cpp:silkworm::etl::operator<(silkworm::etl::Entry const&, silkworm::etl::Entry const&)
  165,434,186 ( 0.53%)    77 ( 0.45%)  77 ( 0.81%)    55,809,710 ( 0.85%)      5,579 ( 0.01%)         5 ( 0.00%)    44,068,398 ( 1.58%)  37,284 ( 1.19%)      53 ( 0.00%)  /usr/include/c++/11/bits/basic_string.h:void std::__introsort_loop<__gnu_cxx::__normal_iterator<silkworm::etl::Entry*, std::vector<silkworm::etl::Entry, std::allocator<silkworm::etl::Entry> > >, long, __gnu_cxx::__ops::_Iter_less_iter>(__gnu_cxx::__normal_iterator<silkworm::etl::Entry*, std::vector<silkworm::etl::Entry, std::allocator<silkworm::etl::Entry> > >, __gnu_cxx::__normal_iterator<silkworm::etl::Entry*, std::vector<silkworm::etl::Entry, std::allocator<silkworm::etl::Entry> > >, long, __gnu_cxx::__ops::_Iter_less_iter) [clone .isra.0]
  164,411,736 ( 0.53%)     0            0             82,205,868 ( 1.25%)    127,330 ( 0.34%)       138 ( 0.00%)             0                0                0           /usr/include/c++/11/bits/stl_vector.h:silkworm::huffman::PatternTable::search_condensed(unsigned short) const
  158,428,528 ( 0.51%)     0            0            158,428,528 ( 2.40%)  2,657,156 ( 7.02%)     4,862 ( 0.09%)             0                0                0           /home/mriccobene/CLionProjects/silkworm/silkworm/node/huffman/decompressor.hpp:silkworm::huffman::Decompressor::Iterator::next_pattern()
  152,879,599 ( 0.49%)    34 ( 0.20%)  14 ( 0.15%)    38,971,580 ( 0.59%)      7,414 ( 0.02%)        55 ( 0.00%)    20,178,825 ( 0.72%)     438 ( 0.01%)      22 ( 0.00%)  ./malloc/./malloc/malloc.c:malloc
  137,953,300 ( 0.44%)    16 ( 0.09%)  16 ( 0.17%)    52,178,631 ( 0.79%)      1,656 ( 0.00%)         2 ( 0.00%)    39,654,974 ( 1.42%)       8 ( 0.00%)       2 ( 0.00%)  /home/mriccobene/CLionProjects/silkworm/third_party/ethash/lib/keccak/keccak.c:ethash_keccak256
  127,376,528 ( 0.41%)    34 ( 0.20%)  34 ( 0.36%)    42,534,832 ( 0.64%)  1,000,004 ( 2.64%)   500,002 ( 9.68%)    26,248,110 ( 0.94%)       4 ( 0.00%)       2 ( 0.00%)  /usr/include/c++/11/bits/basic_string.h:silkworm::etl::Collector::load(silkworm::db::RWCursorDupSort&, std::function<void (silkworm::etl::Entry const&, silkworm::db::RWCursorDupSort&, MDBX_put_flags_t)> const&, MDBX_put_flags_t)
  123,308,802 ( 0.40%)     0            0                      0                   0                  0                      0                0                0           /home/mriccobene/CLionProjects/silkworm/silkworm/node/huffman/decompressor.hpp:silkworm::huffman::PatternTable::search_condensed(unsigned short) const
  106,497,797 ( 0.34%)     1 ( 0.01%)   1 ( 0.01%)             0                   0                  0             21,735,533 ( 0.78%)       0                0           /usr/include/c++/11/bits/stl_algobase.h:silkworm::huffman::Decompressor::Iterator::next(std::__cxx11::basic_string<unsigned char, std::char_traits<unsigned char>, std::allocator<unsigned char> >&)
  103,645,806 ( 0.33%)     4 ( 0.02%)   4 ( 0.04%)       157,359 ( 0.00%)        577 ( 0.00%)         0             20,827,722 ( 0.75%)   4,197 ( 0.13%)       6 ( 0.00%)  /usr/include/c++/11/bits/predefined_ops.h:void std::__introsort_loop<__gnu_cxx::__normal_iterator<silkworm::etl::Entry*, std::vector<silkworm::etl::Entry, std::allocator<silkworm::etl::Entry> > >, long, __gnu_cxx::__ops::_Iter_less_iter>(__gnu_cxx::__normal_iterator<silkworm::etl::Entry*, std::vector<silkworm::etl::Entry, std::allocator<silkworm::etl::Entry> > >, __gnu_cxx::__normal_iterator<silkworm::etl::Entry*, std::vector<silkworm::etl::Entry, std::allocator<silkworm::etl::Entry> > >, long, __gnu_cxx::__ops::_Iter_less_iter) [clone .isra.0]
   96,006,083 ( 0.31%)    23 ( 0.13%)   4 ( 0.04%)    19,000,402 ( 0.29%)          0                  0             14,000,301 ( 0.50%)       3 ( 0.00%)       0           /usr/include/c++/11/bits/basic_string.tcc:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_mutate(unsigned long, unsigned long, char const*, unsigned long)
   93,548,447 ( 0.30%)    52 ( 0.30%)  13 ( 0.14%)     6,074,463 ( 0.09%)         98 ( 0.00%)         0             21,820,098 ( 0.78%)  29,722 ( 0.95%)  17,861 ( 0.75%)  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms
   82,434,077 ( 0.27%)   374 ( 2.19%) 122 ( 1.28%)    14,859,725 ( 0.23%)      3,954 ( 0.01%)        53 ( 0.00%)    16,373,023 ( 0.59%) 296,577 ( 9.47%) 272,363 (11.51%)  ./malloc/./malloc/malloc.c:_int_malloc
   82,205,868 ( 0.26%)     0            0             41,102,934 ( 0.62%)  1,747,517 ( 4.61%)     7,047 ( 0.14%)             0                0                0           /usr/include/c++/11/bits/shared_ptr_base.h:silkworm::huffman::PatternTable::search_condensed(unsigned short) const
   77,991,944 ( 0.25%)     1 ( 0.01%)   1 ( 0.01%)        33,672 ( 0.00%)          0                  0                      0                0                0           /usr/include/c++/11/ostream:silkworm::succinct::RecSplit<8ul>::recsplit(int, std::vector<unsigned long, std::allocator<unsigned long> >&, std::vector<unsigned long, std::allocator<unsigned long> >&, unsigned long, unsigned long, std::vector<unsigned int, std::allocator<unsigned int> >&, std::basic_ofstream<char, std::char_traits<char> >&)
   77,945,115 ( 0.25%)    21 ( 0.12%)  10 ( 0.11%)    28,343,658 ( 0.43%)    504,695 ( 1.33%)    77,847 ( 1.51%)    14,171,838 ( 0.51%)     522 ( 0.02%)       1 ( 0.00%)  ./malloc/./malloc/malloc.c:free
   76,999,926 ( 0.25%) 2,034 (11.89%) 966 (10.16%)    63,805,046 ( 0.97%)     15,708 ( 0.04%)       272 ( 0.01%)        16,330 ( 0.00%)     169 ( 0.01%)      75 ( 0.00%)  ???:???
   65,776,881 ( 0.21%)     5 ( 0.03%)   5 ( 0.05%)     1,213,758 ( 0.02%)      6,582 ( 0.02%)         2 ( 0.00%)       809,174 ( 0.03%)  31,368 ( 1.00%)      49 ( 0.00%)  /usr/include/c++/11/bits/stl_algo.h:void std::__introsort_loop<__gnu_cxx::__normal_iterator<silkworm::etl::Entry*, std::vector<silkworm::etl::Entry, std::allocator<silkworm::etl::Entry> > >, long, __gnu_cxx::__ops::_Iter_less_iter>(__gnu_cxx::__normal_iterator<silkworm::etl::Entry*, std::vector<silkworm::etl::Entry, std::allocator<silkworm::etl::Entry> > >, __gnu_cxx::__normal_iterator<silkworm::etl::Entry*, std::vector<silkworm::etl::Entry, std::allocator<silkworm::etl::Entry> > >, long, __gnu_cxx::__ops::_Iter_less_iter) [clone .isra.0]
   64,993,446 ( 0.21%)    17 ( 0.10%)  17 ( 0.18%)    17,505,714 ( 0.27%)      1,648 ( 0.00%)         1 ( 0.00%)    15,501,938 ( 0.56%)      12 ( 0.00%)       2 ( 0.00%)  /usr/include/c++/11/bits/basic_string.h:silkworm::snapshot::HeaderIndex::walk(silkworm::succinct::RecSplit<8ul>&, unsigned long, unsigned long, silkworm::ByteView)
   63,657,645 ( 0.21%)     6 ( 0.04%)   6 ( 0.06%)    59,386,907 ( 0.90%)      1,593 ( 0.00%)         2 ( 0.00%)        56,779 ( 0.00%)       0                0           /usr/include/c++/11/bits/stl_vector.h:silkworm::succinct::RecSplit<8ul>::recsplit(int, std::vector<unsigned long, std::allocator<unsigned long> >&, std::vector<unsigned long, std::allocator<unsigned long> >&, unsigned long, unsigned long, std::vector<unsigned int, std::allocator<unsigned int> >&, std::basic_ofstream<char, std::char_traits<char> >&)
   50,000,000 ( 0.16%)     6 ( 0.04%)   6 ( 0.06%)     3,500,000 ( 0.05%)        956 ( 0.00%)         1 ( 0.00%)     1,000,000 ( 0.04%)       0                0           /home/mriccobene/CLionProjects/silkworm/silkworm/node/recsplit/support/murmur_hash3.cpp:silkworm::succinct::MurmurHash3_x64_128(void const*, unsigned long, unsigned int, void*)
   42,515,376 ( 0.14%)     4 ( 0.02%)   2 ( 0.02%)     7,085,896 ( 0.11%)          0                  0              7,085,896 ( 0.25%)     576 ( 0.02%)       2 ( 0.00%)  ???:operator new(unsigned long)
   41,102,934 ( 0.13%)     0            0             41,102,934 ( 0.62%)    193,364 ( 0.51%)       116 ( 0.00%)             0                0                0           /usr/include/c++/11/bits/unique_ptr.h:silkworm::huffman::Decompressor::Iterator::next_pattern()
   40,359,010 ( 0.13%)     0            0             40,359,010 ( 0.61%)     43,876 ( 0.12%)        18 ( 0.00%)             0                0                0           /usr/include/c++/11/bits/unique_ptr.h:silkworm::huffman::Decompressor::Iterator::next_position(bool)
   39,528,740 ( 0.13%)     5 ( 0.03%)   4 ( 0.04%)     3,707,070 ( 0.06%)     13,771 ( 0.04%)         8 ( 0.00%)     2,888,890 ( 0.10%)       0                0           /usr/include/c++/11/bits/charconv.h:silkworm::snapshot::HeaderIndex::walk(silkworm::succinct::RecSplit<8ul>&, unsigned long, unsigned long, silkworm::ByteView)
   36,000,726 ( 0.12%)    40 ( 0.23%)   6 ( 0.06%)     9,000,201 ( 0.14%)          0                  0              7,000,134 ( 0.25%)       3 ( 0.00%)       1 ( 0.00%)  /usr/include/c++/11/bits/basic_string.h:std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_mutate(unsigned long, unsigned long, char const*, unsigned long)
   34,000,017 ( 0.11%)     8 ( 0.05%)   7 ( 0.07%)    10,999,997 ( 0.17%)         34 ( 0.00%)         6 ( 0.00%)     7,000,005 ( 0.25%)      11 ( 0.00%)       0           /home/mriccobene/CLionProjects/silkworm/silkworm/node/recsplit/rec_split.hpp:silkworm::succinct::RecSplit<8ul>::add_key(silkworm::succinct::hash128_t const&, unsigned long)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/predefined_ops.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                 D1mr         DLmr       Dw                  D1mw           DLmw       

-- line 37 ----------------------------------------
          .          .          .                  .            .          .                   .              .          .           namespace __ops
          .          .          .                  .            .          .                   .              .          .           {
          .          .          .                  .            .          .                   .              .          .             struct _Iter_less_iter
          .          .          .                  .            .          .                   .              .          .             {
          .          .          .                  .            .          .                   .              .          .               template<typename _Iterator1, typename _Iterator2>
          .          .          .                  .            .          .                   .              .          .                 _GLIBCXX14_CONSTEXPR
          .          .          .                  .            .          .                   .              .          .                 bool
          .          .          .                  .            .          .                   .              .          .                 operator()(_Iterator1 __it1, _Iterator2 __it2) const
103,645,902 ( 0.33%) 5 ( 0.03%) 5 ( 0.05%)   157,359 ( 0.00%) 577 ( 0.00%) 0          20,827,754 ( 0.75%) 4,197 ( 0.13%) 6 ( 0.00%)        { return *__it1 < *__it2; }
          .          .          .                  .            .          .                   .              .          .             };
          .          .          .                  .            .          .                   .              .          .           
          .          .          .                  .            .          .                   .              .          .             _GLIBCXX14_CONSTEXPR
          .          .          .                  .            .          .                   .              .          .             inline _Iter_less_iter
          .          .          .                  .            .          .                   .              .          .             __iter_less_iter()
          .          .          .                  .            .          .                   .              .          .             { return _Iter_less_iter(); }
          .          .          .                  .            .          .                   .              .          .           
          .          .          .                  .            .          .                   .              .          .             struct _Iter_less_val
-- line 53 ----------------------------------------
-- line 90 ----------------------------------------
          .          .          .                  .            .          .                   .              .          .               _GLIBCXX20_CONSTEXPR
          .          .          .                  .            .          .                   .              .          .               explicit
          .          .          .                  .            .          .                   .              .          .               _Val_less_iter(_Iter_less_iter) { }
          .          .          .                  .            .          .                   .              .          .           
          .          .          .                  .            .          .                   .              .          .               template<typename _Value, typename _Iterator>
          .          .          .                  .            .          .                   .              .          .                 _GLIBCXX20_CONSTEXPR
          .          .          .                  .            .          .                   .              .          .                 bool
          .          .          .                  .            .          .                   .              .          .                 operator()(_Value& __val, _Iterator __it) const
 14,017,785 ( 0.05%) 3 ( 0.02%) 3 ( 0.03%) 2,803,557 ( 0.04%)   0          0           2,803,557 ( 0.10%)     0          0                 { return __val < *__it; }
          .          .          .                  .            .          .                   .              .          .             };
          .          .          .                  .            .          .                   .              .          .           
          .          .          .                  .            .          .                   .              .          .             _GLIBCXX20_CONSTEXPR
          .          .          .                  .            .          .                   .              .          .             inline _Val_less_iter
          .          .          .                  .            .          .                   .              .          .             __val_less_iter()
          .          .          .                  .            .          .                   .              .          .             { return _Val_less_iter(); }
          .          .          .                  .            .          .                   .              .          .           
          .          .          .                  .            .          .                   .              .          .             _GLIBCXX20_CONSTEXPR
-- line 106 ----------------------------------------
-- line 262 ----------------------------------------
          .          .          .                  .            .          .                   .              .          .                 _Iter_equals_val(_Value& __value)
          .          .          .                  .            .          .                   .              .          .           	: _M_value(__value)
          .          .          .                  .            .          .                   .              .          .                 { }
          .          .          .                  .            .          .                   .              .          .           
          .          .          .                  .            .          .                   .              .          .                 template<typename _Iterator>
          .          .          .                  .            .          .                   .              .          .           	_GLIBCXX20_CONSTEXPR
          .          .          .                  .            .          .                   .              .          .           	bool
          .          .          .                  .            .          .                   .              .          .           	operator()(_Iterator __it)
        126 ( 0.00%) 7 ( 0.04%) 1 ( 0.01%)         0            0          0                  42 ( 0.00%)     0          0           	{ return *__it == _M_value; }
          .          .          .                  .            .          .                   .              .          .               };
          .          .          .                  .            .          .                   .              .          .           
          .          .          .                  .            .          .                   .              .          .             template<typename _Value>
          .          .          .                  .            .          .                   .              .          .               _GLIBCXX20_CONSTEXPR
          .          .          .                  .            .          .                   .              .          .               inline _Iter_equals_val<_Value>
          .          .          .                  .            .          .                   .              .          .               __iter_equals_val(_Value& __val)
          .          .          .                  .            .          .                   .              .          .               { return _Iter_equals_val<_Value>(__val); }
          .          .          .                  .            .          .                   .              .          .           
-- line 278 ----------------------------------------
-- line 310 ----------------------------------------
          .          .          .                  .            .          .                   .              .          .                 _Iter_pred(_Predicate __pred)
          .          .          .                  .            .          .                   .              .          .           	: _M_pred(_GLIBCXX_MOVE(__pred))
          .          .          .                  .            .          .                   .              .          .                 { }
          .          .          .                  .            .          .                   .              .          .           
          .          .          .                  .            .          .                   .              .          .                 template<typename _Iterator>
          .          .          .                  .            .          .                   .              .          .           	_GLIBCXX20_CONSTEXPR
          .          .          .                  .            .          .                   .              .          .           	bool
          .          .          .                  .            .          .                   .              .          .           	operator()(_Iterator __it)
        105 ( 0.00%) 2 ( 0.01%) 2 ( 0.02%)        84 ( 0.00%)   0          0                   7 ( 0.00%)     0          0           	{ return bool(_M_pred(*__it)); }
          .          .          .                  .            .          .                   .              .          .               };
          .          .          .                  .            .          .                   .              .          .           
          .          .          .                  .            .          .                   .              .          .             template<typename _Predicate>
          .          .          .                  .            .          .                   .              .          .               _GLIBCXX20_CONSTEXPR
          .          .          .                  .            .          .                   .              .          .               inline _Iter_pred<_Predicate>
          .          .          .                  .            .          .                   .              .          .               __pred_iter(_Predicate __pred)
          .          .          .                  .            .          .                   .              .          .               { return _Iter_pred<_Predicate>(_GLIBCXX_MOVE(__pred)); }
          .          .          .                  .            .          .                   .              .          .           
-- line 326 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_vector.h
--------------------------------------------------------------------------------
Ir                   I1mr        ILmr        Dr                   D1mr             DLmr           Dw              D1mw         DLmw        

-- line 90 ----------------------------------------
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 struct _Vector_impl_data
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	pointer _M_start;
          .           .           .                    .                .              .               .            .           .           	pointer _M_finish;
          .           .           .                    .                .              .               .            .           .           	pointer _M_end_of_storage;
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .           	_Vector_impl_data() _GLIBCXX_NOEXCEPT
     12,352 ( 0.00%) 41 ( 0.24%) 24 ( 0.25%)          20 ( 0.00%)       0              0           8,416 ( 0.00%) 295 ( 0.01%) 39 ( 0.00%)  	: _M_start(), _M_finish(), _M_end_of_storage()
          .           .           .                    .                .              .               .            .           .           	{ }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .           #if __cplusplus >= 201103L
          .           .           .                    .                .              .               .            .           .           	_Vector_impl_data(_Vector_impl_data&& __x) noexcept
         14 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           7 ( 0.00%)       0              0               7 ( 0.00%)   1 ( 0.00%)  1 ( 0.00%)  	: _M_start(__x._M_start), _M_finish(__x._M_finish),
          3 ( 0.00%)  0           0                    2 ( 0.00%)       0              0               1 ( 0.00%)   0           0           	  _M_end_of_storage(__x._M_end_of_storage)
         13 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           0                0              0              10 ( 0.00%)   0           0           	{ __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }
          .           .           .                    .                .              .               .            .           .           #endif
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .           	void
          .           .           .                    .                .              .               .            .           .           	_M_copy_data(_Vector_impl_data const& __x) _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .           	{
        505 ( 0.00%) 10 ( 0.06%)  3 ( 0.03%)         157 ( 0.00%)       0              0             225 ( 0.00%)   0           0           	  _M_start = __x._M_start;
          1 ( 0.00%)  0           0                    1 ( 0.00%)       0              0               0            0           0           	  _M_finish = __x._M_finish;
        382 ( 0.00%)  6 ( 0.04%)  3 ( 0.03%)         157 ( 0.00%)       0              0             225 ( 0.00%)   0           0           	  _M_end_of_storage = __x._M_end_of_storage;
          .           .           .                    .                .              .               .            .           .           	}
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .           	void
          .           .           .                    .                .              .               .            .           .           	_M_swap_data(_Vector_impl_data& __x) _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .           	{
          .           .           .                    .                .              .               .            .           .           	  // Do not use std::swap(_M_start, __x._M_start), etc as it loses
          .           .           .                    .                .              .               .            .           .           	  // information used by TBAA.
          .           .           .                    .                .              .               .            .           .           	  _Vector_impl_data __tmp;
-- line 121 ----------------------------------------
-- line 328 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                 _Vector_base(const allocator_type& __a, _Vector_base&& __x)
          .           .           .                    .                .              .               .            .           .                 : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
          .           .           .                    .                .              .               .            .           .                 { }
          .           .           .                    .                .              .               .            .           .           #endif
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 ~_Vector_base() _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	_M_deallocate(_M_impl._M_start,
     11,471 ( 0.00%)  5 ( 0.03%)  5 ( 0.05%)       7,288 ( 0.00%)     106 ( 0.00%)    70 ( 0.00%)     71 ( 0.00%)   0           0           		      _M_impl._M_end_of_storage - _M_impl._M_start);
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .               public:
          .           .           .                    .                .              .               .            .           .                 _Vector_impl _M_impl;
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 pointer
          .           .           .                    .                .              .               .            .           .                 _M_allocate(size_t __n)
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
  1,001,294 ( 0.00%) 20 ( 0.12%)  8 ( 0.08%)          13 ( 0.00%)       0              0              54 ( 0.00%)   0           0           	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 _M_deallocate(pointer __p, size_t __n)
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
     16,874 ( 0.00%) 71 ( 0.42%) 42 ( 0.44%)           7 ( 0.00%)       4 ( 0.00%)     0               0            0           0           	if (__p)
          .           .           .                    .                .              .               .            .           .           	  _Tr::deallocate(_M_impl, __p, __n);
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .               protected:
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 _M_create_storage(size_t __n)
          .           .           .                    .                .              .               .            .           .                 {
        524 ( 0.00%)  8 ( 0.05%)  3 ( 0.03%)         125 ( 0.00%)       0              0             133 ( 0.00%)   0           0           	this->_M_impl._M_start = this->_M_allocate(__n);
          .           .           .                    .                .              .               .            .           .           	this->_M_impl._M_finish = this->_M_impl._M_start;
        281 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)          13 ( 0.00%)       0              0             133 ( 0.00%)   0           0           	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .               };
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .             /**
          .           .           .                    .                .              .               .            .           .              *  @brief A standard container which offers fixed time access to
          .           .           .                    .                .              .               .            .           .              *  individual elements in any order.
          .           .           .                    .                .              .               .            .           .              *
          .           .           .                    .                .              .               .            .           .              *  @ingroup sequences
-- line 371 ----------------------------------------
-- line 545 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                  *
          .           .           .                    .                .              .               .            .           .                  *  All the elements of @a __x are copied, but any unused capacity in
          .           .           .                    .                .              .               .            .           .                  *  @a __x  will not be copied
          .           .           .                    .                .              .               .            .           .                  *  (i.e. capacity() == size() in the new %vector).
          .           .           .                    .                .              .               .            .           .                  *
          .           .           .                    .                .              .               .            .           .                  *  The newly-created %vector uses a copy of the allocator object used
          .           .           .                    .                .              .               .            .           .                  *  by @a __x (unless the allocator traits dictate a different object).
          .           .           .                    .                .              .               .            .           .                  */
      1,120 ( 0.00%)  9 ( 0.05%)  1 ( 0.01%)           0                0              0             672 ( 0.00%)   0           0                 vector(const vector& __x)
          .           .           .                    .                .              .               .            .           .                 : _Base(__x.size(),
          .           .           .                    .                .              .               .            .           .           	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
          .           .           .                    .                .              .               .            .           .                 {
        129 ( 0.00%)  6 ( 0.04%)  1 ( 0.01%)           0                0              0             129 ( 0.00%)   0           0           	this->_M_impl._M_finish =
          .           .           .                    .                .              .               .            .           .           	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
          .           .           .                    .                .              .               .            .           .           				      this->_M_impl._M_start,
          .           .           .                    .                .              .               .            .           .           				      _M_get_Tp_allocator());
        896 ( 0.00%)  2 ( 0.01%)  1 ( 0.01%)         784 ( 0.00%)       0              0               0            0           0                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .           #if __cplusplus >= 201103L
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  @brief  %Vector move constructor.
          .           .           .                    .                .              .               .            .           .                  *
          .           .           .                    .                .              .               .            .           .                  *  The newly-created %vector contains the exact contents of the
          .           .           .                    .                .              .               .            .           .                  *  moved instance.
          .           .           .                    .                .              .               .            .           .                  *  The contents of the moved instance are a valid, but unspecified
-- line 569 ----------------------------------------
-- line 670 ----------------------------------------
          .           .           .                    .                .              .               .            .           .           #endif
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  The dtor only erases the elements, and note that if the
          .           .           .                    .                .              .               .            .           .                  *  elements themselves are pointers, the pointed-to memory is
          .           .           .                    .                .              .               .            .           .                  *  not touched in any way.  Managing the pointer is the user's
          .           .           .                    .                .              .               .            .           .                  *  responsibility.
          .           .           .                    .                .              .               .            .           .                  */
      1,234 ( 0.00%)  8 ( 0.05%)  5 ( 0.05%)           0                0              0             738 ( 0.00%)   0           0                 ~vector() _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 {
      8,129 ( 0.00%) 32 ( 0.19%) 19 ( 0.20%)       8,128 ( 0.00%)   3,029 ( 0.01%) 2,394 ( 0.05%)      0            0           0           	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
          .           .           .                    .                .              .               .            .           .           		      _M_get_Tp_allocator());
          .           .           .                    .                .              .               .            .           .           	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
        907 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)         906 ( 0.00%)       0              0               0            0           0                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  @brief  %Vector assignment operator.
          .           .           .                    .                .              .               .            .           .                  *  @param  __x  A %vector of identical element and allocator types.
          .           .           .                    .                .              .               .            .           .                  *
          .           .           .                    .                .              .               .            .           .                  *  All the elements of @a __x are copied, but any unused capacity in
          .           .           .                    .                .              .               .            .           .                  *  @a __x will not be copied.
          .           .           .                    .                .              .               .            .           .                  *
-- line 691 ----------------------------------------
-- line 701 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                  *
          .           .           .                    .                .              .               .            .           .                  *  The contents of @a __x are moved into this %vector (without copying,
          .           .           .                    .                .              .               .            .           .                  *  if the allocators permit it).
          .           .           .                    .                .              .               .            .           .                  *  Afterwards @a __x is a valid, but unspecified %vector.
          .           .           .                    .                .              .               .            .           .                  *
          .           .           .                    .                .              .               .            .           .                  *  Whether the allocator is moved depends on the allocator traits.
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 vector&
          7 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           0                0              0               5 ( 0.00%)   0           0                 operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	constexpr bool __move_storage =
          .           .           .                    .                .              .               .            .           .           	  _Alloc_traits::_S_propagate_on_move_assign()
          .           .           .                    .                .              .               .            .           .           	  || _Alloc_traits::_S_always_equal();
          .           .           .                    .                .              .               .            .           .           	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
          .           .           .                    .                .              .               .            .           .           	return *this;
          7 ( 0.00%)  0           0                    6 ( 0.00%)       0              0               0            0           0                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  @brief  %Vector list assignment operator.
          .           .           .                    .                .              .               .            .           .                  *  @param  __l  An initializer_list.
          .           .           .                    .                .              .               .            .           .                  *
          .           .           .                    .                .              .               .            .           .                  *  This function fills a %vector with copies of the elements in the
          .           .           .                    .                .              .               .            .           .                  *  initializer list @a __l.
          .           .           .                    .                .              .               .            .           .                  *
-- line 724 ----------------------------------------
-- line 911 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                 crend() const noexcept
          .           .           .                    .                .              .               .            .           .                 { return const_reverse_iterator(begin()); }
          .           .           .                    .                .              .               .            .           .           #endif
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 // [23.2.4.2] capacity
          .           .           .                    .                .              .               .            .           .                 /**  Returns the number of elements in the %vector.  */
          .           .           .                    .                .              .               .            .           .                 size_type
          .           .           .                    .                .              .               .            .           .                 size() const _GLIBCXX_NOEXCEPT
447,680,961 ( 1.44%) 48 ( 0.28%) 38 ( 0.40%) 243,952,064 ( 3.70%) 179,414 ( 0.47%)   163 ( 0.00%) 26,290 ( 0.00%)   1 ( 0.00%)  0                 { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 /**  Returns the size() of the largest possible %vector.  */
          .           .           .                    .                .              .               .            .           .                 size_type
          .           .           .                    .                .              .               .            .           .                 max_size() const _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 { return _S_max_size(_M_get_Tp_allocator()); }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .           #if __cplusplus >= 201103L
          .           .           .                    .                .              .               .            .           .                 /**
-- line 927 ----------------------------------------
-- line 931 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                  *  This function will %resize the %vector to the specified
          .           .           .                    .                .              .               .            .           .                  *  number of elements.  If the number is smaller than the
          .           .           .                    .                .              .               .            .           .                  *  %vector's current size the %vector is truncated, otherwise
          .           .           .                    .                .              .               .            .           .                  *  default constructed elements are appended.
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 resize(size_type __new_size)
          .           .           .                    .                .              .               .            .           .                 {
    231,804 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)      26,023 ( 0.00%)       0              0               0            0           0           	if (__new_size > size())
     56,220 ( 0.00%) 16 ( 0.09%) 15 ( 0.16%)       7,298 ( 0.00%)       1 ( 0.00%)     0          24,228 ( 0.00%)   0           0           	  _M_default_append(__new_size - size());
     97,296 ( 0.00%)  0           0                    0                0              0               0            0           0           	else if (__new_size < size())
     89,132 ( 0.00%)  0           0                5,317 ( 0.00%)       0              0               0            0           0           	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  @brief  Resizes the %vector to the specified number of elements.
          .           .           .                    .                .              .               .            .           .                  *  @param  __new_size  Number of elements the %vector should contain.
          .           .           .                    .                .              .               .            .           .                  *  @param  __x  Data with which new elements should be populated.
          .           .           .                    .                .              .               .            .           .                  *
          .           .           .                    .                .              .               .            .           .                  *  This function will %resize the %vector to the specified
-- line 950 ----------------------------------------
-- line 992 ----------------------------------------
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  Returns the total number of elements that the %vector can
          .           .           .                    .                .              .               .            .           .                  *  hold before needing to allocate more memory.
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 size_type
          .           .           .                    .                .              .               .            .           .                 capacity() const _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 { return size_type(this->_M_impl._M_end_of_storage
      2,475 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         990 ( 0.00%)     246 ( 0.00%)     2 ( 0.00%)      0            0           0           			 - this->_M_impl._M_start); }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  Returns true if the %vector is empty.  (Thus begin() would
          .           .           .                    .                .              .               .            .           .                  *  equal end().)
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 _GLIBCXX_NODISCARD bool
          .           .           .                    .                .              .               .            .           .                 empty() const _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 { return begin() == end(); }
-- line 1008 ----------------------------------------
-- line 1038 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                  *  Note that data access with this operator is unchecked and
          .           .           .                    .                .              .               .            .           .                  *  out_of_range lookups are not defined. (For checked lookups
          .           .           .                    .                .              .               .            .           .                  *  see at().)
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 reference
          .           .           .                    .                .              .               .            .           .                 operator[](size_type __n) _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	__glibcxx_requires_subscript(__n);
 63,502,373 ( 0.20%)  3 ( 0.02%)  3 ( 0.03%)  59,467,737 ( 0.90%)     725 ( 0.00%)     0               0            0           0           	return *(this->_M_impl._M_start + __n);
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  @brief  Subscript access to the data contained in the %vector.
          .           .           .                    .                .              .               .            .           .                  *  @param __n The index of the element for which data should be
          .           .           .                    .                .              .               .            .           .                  *  accessed.
          .           .           .                    .                .              .               .            .           .                  *  @return  Read-only (constant) reference to data.
          .           .           .                    .                .              .               .            .           .                  *
-- line 1054 ----------------------------------------
-- line 1056 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                  *  Note that data access with this operator is unchecked and
          .           .           .                    .                .              .               .            .           .                  *  out_of_range lookups are not defined. (For checked lookups
          .           .           .                    .                .              .               .            .           .                  *  see at().)
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 const_reference
          .           .           .                    .                .              .               .            .           .                 operator[](size_type __n) const _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	__glibcxx_requires_subscript(__n);
      1,473 ( 0.00%)  0           0                  738 ( 0.00%)       0              0               0            0           0           	return *(this->_M_impl._M_start + __n);
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .               protected:
          .           .           .                    .                .              .               .            .           .                 /// Safety check used only from at().
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 _M_range_check(size_type __n) const
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	if (__n >= this->size())
-- line 1072 ----------------------------------------
-- line 1161 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                 // DR 464. Suggestion for new member functions in standard containers.
          .           .           .                    .                .              .               .            .           .                 // data access
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *   Returns a pointer such that [data(), data() + size()) is a valid
          .           .           .                    .                .              .               .            .           .                  *   range.  For a non-empty %vector, data() == &front().
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 _Tp*
          .           .           .                    .                .              .               .            .           .                 data() _GLIBCXX_NOEXCEPT
     10,734 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)      10,652 ( 0.00%)       1 ( 0.00%)     0               0            0           0                 { return _M_data_ptr(this->_M_impl._M_start); }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 const _Tp*
          .           .           .                    .                .              .               .            .           .                 data() const _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 { return _M_data_ptr(this->_M_impl._M_start); }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 // [23.2.4.3] modifiers
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  @brief  Add data to the end of the %vector.
-- line 1177 ----------------------------------------
-- line 1181 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                  *  element at the end of the %vector and assigns the given data
          .           .           .                    .                .              .               .            .           .                  *  to it.  Due to the nature of a %vector this operation can be
          .           .           .                    .                .              .               .            .           .                  *  done in constant time if the %vector has preallocated space
          .           .           .                    .                .              .               .            .           .                  *  available.
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 push_back(const value_type& __x)
          .           .           .                    .                .              .               .            .           .                 {
      3,118 ( 0.00%) 10 ( 0.06%)  6 ( 0.06%)         577 ( 0.00%)       0              0               0            0           0           	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
          .           .           .                    .                .              .               .            .           .           	  {
          .           .           .                    .                .              .               .            .           .           	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
          .           .           .                    .                .              .               .            .           .           	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          .           .           .                    .                .              .               .            .           .           				     __x);
      1,984 ( 0.00%)  0           0                    0                0              0             490 ( 0.00%)   0           0           	    ++this->_M_impl._M_finish;
          .           .           .                    .                .              .               .            .           .           	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
          .           .           .                    .                .              .               .            .           .           	  }
          .           .           .                    .                .              .               .            .           .           	else
        203 ( 0.00%)  7 ( 0.04%)  7 ( 0.07%)          39 ( 0.00%)       1 ( 0.00%)     0              42 ( 0.00%)   0           0           	  _M_realloc_insert(end(), __x);
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .           #if __cplusplus >= 201103L
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 push_back(value_type&& __x)
        163 ( 0.00%)  3 ( 0.02%)  1 ( 0.01%)          78 ( 0.00%)       0              0              52 ( 0.00%)   0           0                 { emplace_back(std::move(__x)); }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 template<typename... _Args>
          .           .           .                    .                .              .               .            .           .           #if __cplusplus > 201402L
          .           .           .                    .                .              .               .            .           .           	reference
          .           .           .                    .                .              .               .            .           .           #else
          .           .           .                    .                .              .               .            .           .           	void
          .           .           .                    .                .              .               .            .           .           #endif
          .           .           .                    .                .              .               .            .           .           	emplace_back(_Args&&... __args);
-- line 1212 ----------------------------------------
-- line 1220 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                  *  Note that no data is returned, and if the last element's
          .           .           .                    .                .              .               .            .           .                  *  data is needed, it should be retrieved before pop_back() is
          .           .           .                    .                .              .               .            .           .                  *  called.
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 pop_back() _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	__glibcxx_requires_nonempty();
         27 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           7 ( 0.00%)       0              0              10 ( 0.00%)   0           0           	--this->_M_impl._M_finish;
          .           .           .                    .                .              .               .            .           .           	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
          .           .           .                    .                .              .               .            .           .           	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .           #if __cplusplus >= 201103L
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  @brief  Inserts an object in %vector before specified iterator.
          .           .           .                    .                .              .               .            .           .                  *  @param  __position  A const_iterator into the %vector.
-- line 1236 ----------------------------------------
-- line 1491 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  Erases all the elements.  Note that this function only erases the
          .           .           .                    .                .              .               .            .           .                  *  elements, and that if the elements themselves are pointers, the
          .           .           .                    .                .              .               .            .           .                  *  pointed-to memory is not touched in any way.  Managing the pointer is
          .           .           .                    .                .              .               .            .           .                  *  the user's responsibility.
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 clear() _GLIBCXX_NOEXCEPT
        515 ( 0.00%)  6 ( 0.04%)  6 ( 0.06%)         514 ( 0.00%)      12 ( 0.00%)     7 ( 0.00%)      0            0           0                 { _M_erase_at_end(this->_M_impl._M_start); }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .               protected:
          .           .           .                    .                .              .               .            .           .                 /**
          .           .           .                    .                .              .               .            .           .                  *  Memory expansion handler.  Uses the member allocation function to
          .           .           .                    .                .              .               .            .           .                  *  obtain @a n bytes of memory, and then copies [first,last) into it.
          .           .           .                    .                .              .               .            .           .                  */
          .           .           .                    .                .              .               .            .           .                 template<typename _ForwardIterator>
          .           .           .                    .                .              .               .            .           .           	pointer
-- line 1507 ----------------------------------------
-- line 1574 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                 // Called by the second initialize_dispatch above
          .           .           .                    .                .              .               .            .           .                 template<typename _ForwardIterator>
          .           .           .                    .                .              .               .            .           .           	void
          .           .           .                    .                .              .               .            .           .           	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
          .           .           .                    .                .              .               .            .           .           			    std::forward_iterator_tag)
          .           .           .                    .                .              .               .            .           .           	{
          .           .           .                    .                .              .               .            .           .           	  const size_type __n = std::distance(__first, __last);
          .           .           .                    .                .              .               .            .           .           	  this->_M_impl._M_start
          6 ( 0.00%)  0           0                    0                0              0               6 ( 0.00%)   0           0           	    = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
        283 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           0                0              0               6 ( 0.00%)   0           0           	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
          6 ( 0.00%)  0           0                    0                0              0               6 ( 0.00%)   0           0           	  this->_M_impl._M_finish =
          .           .           .                    .                .              .               .            .           .           	    std::__uninitialized_copy_a(__first, __last,
          .           .           .                    .                .              .               .            .           .           					this->_M_impl._M_start,
          .           .           .                    .                .              .               .            .           .           					_M_get_Tp_allocator());
          .           .           .                    .                .              .               .            .           .           	}
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 // Called by the first initialize_dispatch above and by the
          .           .           .                    .                .              .               .            .           .                 // vector(n,value,a) constructor.
          .           .           .                    .                .              .               .            .           .                 void
-- line 1592 ----------------------------------------
-- line 1597 ----------------------------------------
          .           .           .                    .                .              .               .            .           .           					_M_get_Tp_allocator());
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .           #if __cplusplus >= 201103L
          .           .           .                    .                .              .               .            .           .                 // Called by the vector(n) constructor.
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 _M_default_initialize(size_type __n)
          .           .           .                    .                .              .               .            .           .                 {
          2 ( 0.00%)  0           0                    0                0              0               2 ( 0.00%)   0           0           	this->_M_impl._M_finish =
          .           .           .                    .                .              .               .            .           .           	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
          .           .           .                    .                .              .               .            .           .           					   _M_get_Tp_allocator());
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           #endif
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 // Internal assign functions follow.  The *_aux functions do the actual
          .           .           .                    .                .              .               .            .           .                 // assignment work for the range versions.
          .           .           .                    .                .              .               .            .           .           
-- line 1613 ----------------------------------------
-- line 1750 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                 _M_emplace_aux(const_iterator __position, value_type&& __v)
          .           .           .                    .                .              .               .            .           .                 { return _M_insert_rval(__position, std::move(__v)); }
          .           .           .                    .                .              .               .            .           .           #endif
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 // Called by _M_fill_insert, _M_insert_aux etc.
          .           .           .                    .                .              .               .            .           .                 size_type
          .           .           .                    .                .              .               .            .           .                 _M_check_len(size_type __n, const char* __s) const
          .           .           .                    .                .              .               .            .           .                 {
     50,702 ( 0.00%) 40 ( 0.23%) 21 ( 0.22%)           0                0              0               0            0           0           	if (max_size() - size() < __n)
          .           .           .                    .                .              .               .            .           .           	  __throw_length_error(__N(__s));
          .           .           .                    .                .              .               .            .           .           
         45 ( 0.00%)  0           0                    0                0              0              45 ( 0.00%)   0           0           	const size_type __len = size() + (std::max)(size(), __n);
      5,190 ( 0.00%) 10 ( 0.06%)  4 ( 0.04%)           0                0              0               0            0           0           	return (__len < size() || __len > max_size()) ? max_size() : __len;
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 // Called by constructors to check initial size.
          .           .           .                    .                .              .               .            .           .                 static size_type
          .           .           .                    .                .              .               .            .           .                 _S_check_init_len(size_type __n, const allocator_type& __a)
          .           .           .                    .                .              .               .            .           .                 {
          6 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0              0               0            0           0           	if (__n > _S_max_size(_Tp_alloc_type(__a)))
          .           .           .                    .                .              .               .            .           .           	  __throw_length_error(
          .           .           .                    .                .              .               .            .           .           	      __N("cannot create std::vector larger than max_size()"));
          .           .           .                    .                .              .               .            .           .           	return __n;
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 static size_type
          .           .           .                    .                .              .               .            .           .                 _S_max_size(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 {
-- line 1777 ----------------------------------------
-- line 1786 ----------------------------------------
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 // Internal erase functions follow.
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
          .           .           .                    .                .              .               .            .           .                 // _M_assign_aux.
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
          .           .           .                    .                .              .               .            .           .                 {
    168,657 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)       5,825 ( 0.00%)     247 ( 0.00%)     0               1 ( 0.00%)   0           0           	if (size_type __n = this->_M_impl._M_finish - __pos)
          .           .           .                    .                .              .               .            .           .           	  {
          .           .           .                    .                .              .               .            .           .           	    std::_Destroy(__pos, this->_M_impl._M_finish,
          .           .           .                    .                .              .               .            .           .           			  _M_get_Tp_allocator());
     11,385 ( 0.00%)  0           0                    2 ( 0.00%)       2 ( 0.00%)     1 ( 0.00%) 11,383 ( 0.00%)   2 ( 0.00%)  1 ( 0.00%)  	    this->_M_impl._M_finish = __pos;
          .           .           .                    .                .              .               .            .           .           	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
          .           .           .                    .                .              .               .            .           .           	  }
          .           .           .                    .                .              .               .            .           .                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 iterator
          .           .           .                    .                .              .               .            .           .                 _M_erase(iterator __position);
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 iterator
-- line 1806 ----------------------------------------
-- line 1813 ----------------------------------------
          .           .           .                    .                .              .               .            .           .                 // or because the allocators are equal.
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 _M_move_assign(vector&& __x, true_type) noexcept
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	vector __tmp(get_allocator());
          .           .           .                    .                .              .               .            .           .           	this->_M_impl._M_swap_data(__x._M_impl);
          .           .           .                    .                .              .               .            .           .           	__tmp._M_impl._M_swap_data(__x._M_impl);
          .           .           .                    .                .              .               .            .           .           	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
        170 ( 0.00%)  0           0                    0                0              0              68 ( 0.00%)   0           0                 }
          .           .           .                    .                .              .               .            .           .           
          .           .           .                    .                .              .               .            .           .                 // Do move assignment when it might not be possible to move source
          .           .           .                    .                .              .               .            .           .                 // object's memory, resulting in a linear-time operation.
          .           .           .                    .                .              .               .            .           .                 void
          .           .           .                    .                .              .               .            .           .                 _M_move_assign(vector&& __x, false_type)
          .           .           .                    .                .              .               .            .           .                 {
          .           .           .                    .                .              .               .            .           .           	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
          .           .           .                    .                .              .               .            .           .           	  _M_move_assign(std::move(__x), true_type());
-- line 1829 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/mriccobene/CLionProjects/silkworm/silkworm/node/recsplit/support/common.hpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                 D1mr         DLmr       Dw              D1mw       DLmw       

-- line 217 ----------------------------------------
            .          .          .                  .            .          .               .          .          .           /** Find the index of the most significant 1-bit in a word.
            .          .          .                  .            .          .               .          .          .            * @param word binary word.
            .          .          .                  .            .          .               .          .          .            *
            .          .          .                  .            .          .               .          .          .            * The Knuth's lambda function is the dual of the rho function.
            .          .          .                  .            .          .               .          .          .            *
            .          .          .                  .            .          .               .          .          .            * The behavior in zero is undefined.
            .          .          .                  .            .          .               .          .          .            *
            .          .          .                  .            .          .               .          .          .            */
            2 ( 0.00%) 0          0                  0            0          0               0          0          0           inline int lambda(uint64_t word) { return 63 ^ __builtin_clzll(word); }
            .          .          .                  .            .          .               .          .          .           
            .          .          .                  .            .          .               .          .          .           //! Convert the number x which is assumed to be uniformly distributed over the range [0..2^64) to a number that is uniformly
            .          .          .                  .            .          .               .          .          .           //! distributed over the range [0..n), under assumption that n is less than 2^16
            .          .          .                  .            .          .               .          .          .           inline uint64_t remap16(uint64_t x, uint64_t n) {
            .          .          .                  .            .          .               .          .          .               SILKWORM_ASSERT(n < (1 << 16));
            .          .          .                  .            .          .               .          .          .               static const int masklen = 48;
            .          .          .                  .            .          .               .          .          .               static const uint64_t mask = (uint64_t(1) << masklen) - 1;
1,009,031,513 ( 3.25%) 3 ( 0.02%) 3 ( 0.03%)    26,023 ( 0.00%)   0          0          26,023 ( 0.00%) 0          0               return ((x & mask) * n) >> masklen;
            .          .          .                  .            .          .               .          .          .           }
            .          .          .                  .            .          .               .          .          .           
            .          .          .                  .            .          .               .          .          .           inline uint64_t remap128(uint64_t x, uint64_t n) {
            .          .          .                  .            .          .               .          .          .           #ifdef __SIZEOF_INT128__
    1,500,000 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%) 1,000,000 ( 0.02%) 141 ( 0.00%) 1 ( 0.00%)      0          0          0               return static_cast<uint64_t>((static_cast<__uint128_t>(x) * static_cast<__uint128_t>(n)) >> 64);
            .          .          .                  .            .          .               .          .          .           #else
            .          .          .                  .            .          .               .          .          .               // Less than 2^32 keys
            .          .          .                  .            .          .               .          .          .               return (uint32_t)x * n >> 32;
            .          .          .                  .            .          .               .          .          .           #endif  // __SIZEOF_INT128__
            .          .          .                  .            .          .               .          .          .           }
            .          .          .                  .            .          .               .          .          .           
            .          .          .                  .            .          .               .          .          .           /** Count the number of 1-bits in a word.
            .          .          .                  .            .          .               .          .          .            * @param word binary word.
-- line 246 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/basic_string.tcc
--------------------------------------------------------------------------------
Ir                  I1mr        ILmr        Dr                  D1mr       DLmr       Dw                  D1mw       DLmw       

-- line 129 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               typename basic_string<_CharT, _Traits, _Alloc>::pointer
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               _M_create(size_type& __capacity, size_type __old_capacity)
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .           .           .                   .          .          .                   .          .          .                 // 83.  String::npos vs. string::max_size()
 6,000,678 ( 0.02%) 62 ( 0.36%) 40 ( 0.42%)          4 ( 0.00%) 0          0                   0          0          0                 if (__capacity > max_size())
         .           .           .                   .          .          .                   .          .          .           	std::__throw_length_error(__N("basic_string::_M_create"));
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 // The below implements an exponential growth policy, necessary to
         .           .           .                   .          .          .                   .          .          .                 // meet amortized linear time requirements of the library: see
         .           .           .                   .          .          .                   .          .          .                 // http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.
10,000,386 ( 0.03%)  0           0                   0          0          0                   0          0          0                 if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
         .           .           .                   .          .          .                   .          .          .           	{
         .           .           .                   .          .          .                   .          .          .           	  __capacity = 2 * __old_capacity;
         .           .           .                   .          .          .                   .          .          .           	  // Never allocate a string bigger than max_size.
 4,004,228 ( 0.01%)  0           0                   0          0          0                   0          0          0           	  if (__capacity > max_size())
         .           .           .                   .          .          .                   .          .          .           	    __capacity = max_size();
         .           .           .                   .          .          .                   .          .          .           	}
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 // NB: Need an array of char_type[__capacity], plus a terminating
         .           .           .                   .          .          .                   .          .          .                 // null char_type() element.
         2 ( 0.00%)  0           0                   0          0          0                   0          0          0                 return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
         .           .           .                   .          .          .                   .          .          .               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             // NB: This is the special case for Input Iterators, used in
         .           .           .                   .          .          .                   .          .          .             // istreambuf_iterators, etc.
         .           .           .                   .          .          .                   .          .          .             // Input Iterators have a cost structure very different from
         .           .           .                   .          .          .                   .          .          .             // pointers, calling for a different coding style.
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               template<typename _InIterator>
-- line 161 ----------------------------------------
-- line 198 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           	  }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           	_M_set_length(__len);
         .           .           .                   .          .          .                   .          .          .                 }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               template<typename _InIterator>
         .           .           .                   .          .          .                   .          .          .                 void
 9,006,840 ( 0.03%) 51 ( 0.30%) 21 ( 0.22%)          0          0          0           4,503,420 ( 0.16%) 0          0                 basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .                 _M_construct(_InIterator __beg, _InIterator __end,
         .           .           .                   .          .          .                   .          .          .           		   std::forward_iterator_tag)
         .           .           .                   .          .          .                   .          .          .                 {
         .           .           .                   .          .          .                   .          .          .           	// NB: Not required, but considered best practice.
 6,005,279 ( 0.02%) 28 ( 0.16%) 18 ( 0.19%)          0          0          0                   0          0          0           	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
         .           .           .                   .          .          .                   .          .          .           	  std::__throw_logic_error(__N("basic_string::"
         .           .           .                   .          .          .                   .          .          .           				       "_M_construct null not valid"));
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
         .           .           .                   .          .          .                   .          .          .           
 3,002,602 ( 0.01%) 27 ( 0.16%) 16 ( 0.17%)          4 ( 0.00%) 0          0                   0          0          0           	if (__dnew > size_type(_S_local_capacity))
         .           .           .                   .          .          .                   .          .          .           	  {
         .           .           .                   .          .          .                   .          .          .           	    _M_data(_M_create(__dnew, size_type(0)));
         .           .           .                   .          .          .                   .          .          .           	    _M_capacity(__dnew);
         .           .           .                   .          .          .                   .          .          .           	  }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           	// Check for out_of_range and length_error exceptions.
         .           .           .                   .          .          .                   .          .          .           	__try
         .           .           .                   .          .          .                   .          .          .           	  { this->_S_copy_chars(_M_data(), __beg, __end); }
         .           .           .                   .          .          .                   .          .          .           	__catch(...)
         .           .           .                   .          .          .                   .          .          .           	  {
         .           .           .                   .          .          .                   .          .          .           	    _M_dispose();
         .           .           .                   .          .          .                   .          .          .           	    __throw_exception_again;
         .           .           .                   .          .          .                   .          .          .           	  }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           	_M_set_length(__dnew);
 6,004,560 ( 0.02%)  0           0           6,004,560 ( 0.09%) 0          0                   0          0          0                 }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               void
        70 ( 0.00%) 10 ( 0.06%)  4 ( 0.04%)          0          0          0                  30 ( 0.00%) 0          0               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               _M_construct(size_type __n, _CharT __c)
         .           .           .                   .          .          .                   .          .          .               {
 2,980,046 ( 0.01%)  0           0                   0          0          0                   0          0          0                 if (__n > size_type(_S_local_capacity))
         .           .           .                   .          .          .                   .          .          .           	{
         .           .           .                   .          .          .                   .          .          .           	  _M_data(_M_create(__n, size_type(0)));
         .           .           .                   .          .          .                   .          .          .           	  _M_capacity(__n);
         .           .           .                   .          .          .                   .          .          .           	}
         .           .           .                   .          .          .                   .          .          .           
 1,980,028 ( 0.01%)  1 ( 0.01%)  1 ( 0.01%)          0          0          0                   0          0          0                 if (__n)
         4 ( 0.00%)  0           0                   0          0          0                   0          0          0           	this->_S_assign(_M_data(), __n, __c);
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 _M_set_length(__n);
        40 ( 0.00%)  0           0                  40 ( 0.00%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               void
       790 ( 0.00%) 13 ( 0.08%)  1 ( 0.01%)          0          0          0                 474 ( 0.00%) 1 ( 0.00%) 0               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               _M_assign(const basic_string& __str)
         .           .           .                   .          .          .                   .          .          .               {
       158 ( 0.00%)  0           0                   0          0          0                   0          0          0                 if (this != &__str)
         .           .           .                   .          .          .                   .          .          .           	{
         .           .           .                   .          .          .                   .          .          .           	  const size_type __rsize = __str.length();
         .           .           .                   .          .          .                   .          .          .           	  const size_type __capacity = capacity();
         .           .           .                   .          .          .                   .          .          .           
       158 ( 0.00%)  0           0                   0          0          0                   0          0          0           	  if (__rsize > __capacity)
         .           .           .                   .          .          .                   .          .          .           	    {
         .           .           .                   .          .          .                   .          .          .           	      size_type __new_capacity = __rsize;
         .           .           .                   .          .          .                   .          .          .           	      pointer __tmp = _M_create(__new_capacity, __capacity);
         .           .           .                   .          .          .                   .          .          .           	      _M_dispose();
         .           .           .                   .          .          .                   .          .          .           	      _M_data(__tmp);
         .           .           .                   .          .          .                   .          .          .           	      _M_capacity(__new_capacity);
         .           .           .                   .          .          .                   .          .          .           	    }
         .           .           .                   .          .          .                   .          .          .           
       161 ( 0.00%) 13 ( 0.08%)  1 ( 0.01%)          0          0          0                   0          0          0           	  if (__rsize)
         .           .           .                   .          .          .                   .          .          .           	    this->_S_copy(_M_data(), __str._M_data(), __rsize);
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .           	  _M_set_length(__rsize);
         .           .           .                   .          .          .                   .          .          .           	}
       632 ( 0.00%)  0           0                 553 ( 0.00%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               void
       656 ( 0.00%) 19 ( 0.11%)  6 ( 0.06%)          0          0          0                 410 ( 0.00%) 0          0               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               reserve(size_type __res)
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 const size_type __capacity = capacity();
         .           .           .                   .          .          .                   .          .          .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .           .           .                   .          .          .                   .          .          .                 // 2968. Inconsistencies between basic_string reserve and
         .           .           .                   .          .          .                   .          .          .                 // vector/unordered_map/unordered_set reserve functions
         .           .           .                   .          .          .                   .          .          .                 // P0966 reserve should not shrink
       176 ( 0.00%)  0           0                   0          0          0                   0          0          0                 if (__res <= __capacity)
         .           .           .                   .          .          .                   .          .          .           	return;
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 pointer __tmp = _M_create(__res, __capacity);
       106 ( 0.00%)  0           0                  53 ( 0.00%) 0          0                   0          0          0                 this->_S_copy(__tmp, _M_data(), length() + 1);
         .           .           .                   .          .          .                   .          .          .                 _M_dispose();
         .           .           .                   .          .          .                   .          .          .                 _M_data(__tmp);
         .           .           .                   .          .          .                   .          .          .                 _M_capacity(__res);
       492 ( 0.00%)  0           0                 492 ( 0.00%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               void
24,000,516 ( 0.08%)  9 ( 0.05%)  2 ( 0.02%)          0          0          0          12,000,258 ( 0.43%) 2 ( 0.00%) 0               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
         .           .           .                   .          .          .                   .          .          .           	      size_type __len2)
         .           .           .                   .          .          .                   .          .          .               {
 6,000,129 ( 0.02%)  0           0                   0          0          0           2,000,043 ( 0.07%) 1 ( 0.00%) 0                 const size_type __how_much = length() - __pos - __len1;
         .           .           .                   .          .          .                   .          .          .           
 6,000,129 ( 0.02%)  0           0                   0          0          0                   0          0          0                 size_type __new_capacity = length() + __len2 - __len1;
         .           .           .                   .          .          .                   .          .          .                 pointer __r = _M_create(__new_capacity, capacity());
         .           .           .                   .          .          .                   .          .          .           
 6,000,129 ( 0.02%)  0           0           2,000,043 ( 0.03%) 0          0                   0          0          0                 if (__pos)
         .           .           .                   .          .          .                   .          .          .           	this->_S_copy(__r, _M_data(), __pos);
 8,000,172 ( 0.03%)  0           0                   0          0          0                   0          0          0                 if (__s && __len2)
 2,000,042 ( 0.01%) 13 ( 0.08%)  1 ( 0.01%)          0          0          0                   0          0          0           	this->_S_copy(__r + __pos, __s, __len2);
 6,000,129 ( 0.02%)  1 ( 0.01%)  1 ( 0.01%)  2,000,043 ( 0.03%) 0          0                   0          0          0                 if (__how_much)
 2,000,030 ( 0.01%)  0           0                   0          0          0                   0          0          0           	this->_S_copy(__r + __pos + __len2,
 2,000,030 ( 0.01%)  0           0           1,000,015 ( 0.02%) 0          0                   0          0          0           		      _M_data() + __pos + __len1, __how_much);
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 _M_dispose();
         .           .           .                   .          .          .                   .          .          .                 _M_data(__r);
         .           .           .                   .          .          .                   .          .          .                 _M_capacity(__new_capacity);
16,000,344 ( 0.05%)  0           0          14,000,301 ( 0.21%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               void
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               _M_erase(size_type __pos, size_type __n)
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 const size_type __how_much = length() - __pos - __n;
         .           .           .                   .          .          .                   .          .          .           
       168 ( 0.00%)  4 ( 0.02%)  1 ( 0.01%)          0          0          0                   0          0          0                 if (__how_much && __n)
         .           .           .                   .          .          .                   .          .          .           	this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 _M_set_length(length() - __n);
         .           .           .                   .          .          .                   .          .          .               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               void
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>::
-- line 337 ----------------------------------------
-- line 364 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           	  { throw; }
         .           .           .                   .          .          .                   .          .          .           	catch (...)
         .           .           .                   .          .          .                   .          .          .           	  { /* swallow the exception */ }
         .           .           .                   .          .          .                   .          .          .           #endif
         .           .           .                   .          .          .                   .          .          .               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               void
 5,000,000 ( 0.02%)  1 ( 0.01%)  1 ( 0.01%)          0          0          0           3,000,000 ( 0.11%) 0          0               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               resize(size_type __n, _CharT __c)
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 const size_type __size = this->size();
 1,000,000 ( 0.00%)  0           0                   0          0          0                   0          0          0                 if (__size < __n)
 1,500,000 ( 0.00%)  0           0                   0          0          0                   0          0          0           	this->append(__n - __size, __c);
         .           .           .                   .          .          .                   .          .          .                 else if (__n < __size)
         .           .           .                   .          .          .                   .          .          .           	this->_M_set_length(__n);
 4,000,000 ( 0.01%)  0           0           3,500,000 ( 0.05%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>&
     2,090 ( 0.00%) 17 ( 0.10%)  2 ( 0.02%)          0          0          0                 836 ( 0.00%) 0          0               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               _M_append(const _CharT* __s, size_type __n)
         .           .           .                   .          .          .                   .          .          .               {
   500,440 ( 0.00%)  6 ( 0.04%)  4 ( 0.04%)          0          0          0                  10 ( 0.00%) 0          0                 const size_type __len = __n + this->size();
         .           .           .                   .          .          .                   .          .          .           
 1,000,860 ( 0.00%)  0           0                   0          0          0                   0          0          0                 if (__len <= this->capacity())
         .           .           .                   .          .          .                   .          .          .           	{
       802 ( 0.00%)  0           0                   0          0          0                   0          0          0           	  if (__n)
       368 ( 0.00%)  0           0                   0          0          0                   0          0          0           	    this->_S_copy(this->_M_data() + this->size(), __s, __n);
         .           .           .                   .          .          .                   .          .          .           	}
         .           .           .                   .          .          .                   .          .          .                 else
 5,000,102 ( 0.02%)  4 ( 0.02%)  3 ( 0.03%)          0          0          0           1,000,017 ( 0.04%) 2 ( 0.00%) 1 ( 0.00%)  	this->_M_mutate(this->size(), size_type(0), __s, __n);
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 this->_M_set_length(__len);
         .           .           .                   .          .          .                   .          .          .                 return *this;
     2,090 ( 0.00%)  0           0               1,254 ( 0.00%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               template<typename _InputIterator>
         .           .           .                   .          .          .                   .          .          .                 basic_string<_CharT, _Traits, _Alloc>&
         .           .           .                   .          .          .                   .          .          .                 basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .                 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
         .           .           .                   .          .          .                   .          .          .           			  _InputIterator __k1, _InputIterator __k2,
         .           .           .                   .          .          .                   .          .          .           			  std::__false_type)
-- line 407 ----------------------------------------
-- line 411 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           	const basic_string __s(__k1, __k2, this->get_allocator());
         .           .           .                   .          .          .                   .          .          .           	const size_type __n1 = __i2 - __i1;
         .           .           .                   .          .          .                   .          .          .           	return _M_replace(__i1 - begin(), __n1, __s._M_data(),
         .           .           .                   .          .          .                   .          .          .           			  __s.size());
         .           .           .                   .          .          .                   .          .          .                 }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>&
        70 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)          0          0          0                  43 ( 0.00%) 0          0               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
         .           .           .                   .          .          .                   .          .          .           		   _CharT __c)
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 const size_type __old_size = this->size();
        38 ( 0.00%)  0           0                   0          0          0                   0          0          0                 const size_type __new_size = __old_size + __n2 - __n1;
         .           .           .                   .          .          .                   .          .          .           
 1,000,022 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          0          0          0                   0          0          0                 if (__new_size <= this->capacity())
         .           .           .                   .          .          .                   .          .          .           	{
         7 ( 0.00%)  0           0                   0          0          0                   0          0          0           	  pointer __p = this->_M_data() + __pos1;
         .           .           .                   .          .          .                   .          .          .           
        10 ( 0.00%)  0           0                   0          0          0                   0          0          0           	  const size_type __how_much = __old_size - __pos1 - __n1;
        40 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)          0          0          0                   0          0          0           	  if (__how_much && __n1 != __n2)
         .           .           .                   .          .          .                   .          .          .           	    this->_S_move(__p + __n2, __p + __n1, __how_much);
         .           .           .                   .          .          .                   .          .          .           	}
         .           .           .                   .          .          .                   .          .          .                 else
         .           .           .                   .          .          .                   .          .          .           	this->_M_mutate(__pos1, __n1, 0, __n2);
         .           .           .                   .          .          .                   .          .          .           
         6 ( 0.00%)  0           0                   0          0          0                   0          0          0                 if (__n2)
   500,005 ( 0.00%)  0           0                   0          0          0                   0          0          0           	this->_S_assign(this->_M_data() + __pos1, __n2, __c);
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 this->_M_set_length(__new_size);
         .           .           .                   .          .          .                   .          .          .                 return *this;
        70 ( 0.00%)  0           0                  53 ( 0.00%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>&
       468 ( 0.00%) 28 ( 0.16%)  4 ( 0.04%)          0          0          0                 312 ( 0.00%) 0          0               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
         .           .           .                   .          .          .                   .          .          .           	       const size_type __len2)
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 _M_check_length(__len1, __len2, "basic_string::_M_replace");
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 const size_type __old_size = this->size();
 1,000,052 ( 0.00%)  0           0                   0          0          0                   0          0          0                 const size_type __new_size = __old_size + __len2 - __len1;
         .           .           .                   .          .          .                   .          .          .           
 2,000,116 ( 0.01%)  4 ( 0.02%)  2 ( 0.02%)          0          0          0                   0          0          0                 if (__new_size <= this->capacity())
         .           .           .                   .          .          .                   .          .          .           	{
        33 ( 0.00%)  0           0                   0          0          0                   0          0          0           	  pointer __p = this->_M_data() + __pos;
         .           .           .                   .          .          .                   .          .          .           
        99 ( 0.00%)  0           0                   0          0          0                   0          0          0           	  const size_type __how_much = __old_size - __pos - __len1;
         .           .           .                   .          .          .                   .          .          .           	  if (_M_disjunct(__s))
         .           .           .                   .          .          .                   .          .          .           	    {
       132 ( 0.00%)  0           0                   0          0          0                   0          0          0           	      if (__how_much && __len1 != __len2)
        20 ( 0.00%)  0           0                   0          0          0                   0          0          0           		this->_S_move(__p + __len2, __p + __len1, __how_much);
        66 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)          0          0          0                   0          0          0           	      if (__len2)
         .           .           .                   .          .          .                   .          .          .           		this->_S_copy(__p, __s, __len2);
         .           .           .                   .          .          .                   .          .          .           	    }
         .           .           .                   .          .          .                   .          .          .           	  else
         .           .           .                   .          .          .                   .          .          .           	    {
         .           .           .                   .          .          .                   .          .          .           	      // Work in-place.
         .           .           .                   .          .          .                   .          .          .           	      if (__len2 && __len2 <= __len1)
         .           .           .                   .          .          .                   .          .          .           		this->_S_move(__p, __s, __len2);
         .           .           .                   .          .          .                   .          .          .           	      if (__how_much && __len1 != __len2)
-- line 474 ----------------------------------------
-- line 490 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           		      this->_S_move(__p, __s, __nleft);
         .           .           .                   .          .          .                   .          .          .           		      this->_S_copy(__p + __nleft, __p + __len2,
         .           .           .                   .          .          .                   .          .          .           				    __len2 - __nleft);
         .           .           .                   .          .          .                   .          .          .           		    }
         .           .           .                   .          .          .                   .          .          .           		}
         .           .           .                   .          .          .                   .          .          .           	    }
         .           .           .                   .          .          .                   .          .          .           	}
         .           .           .                   .          .          .                   .          .          .                 else
 7,000,144 ( 0.02%) 23 ( 0.13%)  5 ( 0.05%)          0          0          0           1,000,025 ( 0.04%) 0          0           	this->_M_mutate(__pos, __len1, __s, __len2);
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 this->_M_set_length(__new_size);
         .           .           .                   .          .          .                   .          .          .                 return *this;
       468 ( 0.00%)  6 ( 0.04%)  0                 364 ( 0.00%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               copy(_CharT* __s, size_type __n, size_type __pos) const
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 _M_check(__pos, "basic_string::copy");
         .           .           .                   .          .          .                   .          .          .                 __n = _M_limit(__pos, __n);
-- line 510 ----------------------------------------
-- line 1161 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           	_M_copy(__s, _M_data() + __pos, __n);
         .           .           .                   .          .          .                   .          .          .                 // 21.3.5.7 par 3: do not append null.  (good.)
         .           .           .                   .          .          .                   .          .          .                 return __n;
         .           .           .                   .          .          .                   .          .          .               }
         .           .           .                   .          .          .                   .          .          .           #endif  // !_GLIBCXX_USE_CXX11_ABI
         .           .           .                   .          .          .                   .          .          .              
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>
        66 ( 0.00%)  3 ( 0.02%)  1 ( 0.01%)          0          0          0                  36 ( 0.00%) 1 ( 0.00%) 0               operator+(const _CharT* __lhs,
         .           .           .                   .          .          .                   .          .          .           	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 __glibcxx_requires_string(__lhs);
         .           .           .                   .          .          .                   .          .          .                 typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
         .           .           .                   .          .          .                   .          .          .                 typedef typename __string_type::size_type	  __size_type;
         .           .           .                   .          .          .                   .          .          .                 typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
         .           .           .                   .          .          .                   .          .          .           	rebind<_CharT>::other _Char_alloc_type;
         .           .           .                   .          .          .                   .          .          .                 typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
         .           .           .                   .          .          .                   .          .          .                 const __size_type __len = _Traits::length(__lhs);
         .           .           .                   .          .          .                   .          .          .                 __string_type __str(_Alloc_traits::_S_select_on_copy(
         .           .           .                   .          .          .                   .          .          .                     __rhs.get_allocator()));
        12 ( 0.00%)  0           0                   6 ( 0.00%) 0          0                   0          0          0                 __str.reserve(__len + __rhs.size());
         .           .           .                   .          .          .                   .          .          .                 __str.append(__lhs, __len);
         .           .           .                   .          .          .                   .          .          .                 __str.append(__rhs);
         .           .           .                   .          .          .                   .          .          .                 return __str;
        54 ( 0.00%)  0           0                  42 ( 0.00%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>
         .           .           .                   .          .          .                   .          .          .               operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
         .           .           .                   .          .          .                   .          .          .                 typedef typename __string_type::size_type	  __size_type;
         .           .           .                   .          .          .                   .          .          .                 typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
-- line 1193 ----------------------------------------
-- line 1208 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .               find(const _CharT* __s, size_type __pos, size_type __n) const
         .           .           .                   .          .          .                   .          .          .               _GLIBCXX_NOEXCEPT
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 __glibcxx_requires_string_len(__s, __n);
         .           .           .                   .          .          .                   .          .          .                 const size_type __size = this->size();
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 if (__n == 0)
         .           .           .                   .          .          .                   .          .          .           	return __pos <= __size ? __pos : npos;
       118 ( 0.00%)  0           0                   0          0          0                   0          0          0                 if (__pos >= __size)
         .           .           .                   .          .          .                   .          .          .           	return npos;
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .                 const _CharT __elem0 = __s[0];
         .           .           .                   .          .          .                   .          .          .                 const _CharT* const __data = data();
         .           .           .                   .          .          .                   .          .          .                 const _CharT* __first = __data + __pos;
       126 ( 0.00%)  2 ( 0.01%)  1 ( 0.01%)          0          0          0                   0          0          0                 const _CharT* const __last = __data + __size;
         .           .           .                   .          .          .                   .          .          .                 size_type __len = __size - __pos;
         .           .           .                   .          .          .                   .          .          .           
        68 ( 0.00%)  0           0                   0          0          0                  34 ( 0.00%) 0          0                 while (__len >= __n)
         .           .           .                   .          .          .                   .          .          .           	{
         .           .           .                   .          .          .                   .          .          .           	  // Find the first occurrence of __elem0:
         .           .           .                   .          .          .                   .          .          .           	  __first = traits_type::find(__first, __len - __n + 1, __elem0);
        84 ( 0.00%)  0           0                   0          0          0                   0          0          0           	  if (!__first)
         .           .           .                   .          .          .                   .          .          .           	    return npos;
         .           .           .                   .          .          .                   .          .          .           	  // Compare the full strings from the first occurrence of __elem0.
         .           .           .                   .          .          .                   .          .          .           	  // We already know that __first[0] == __s[0] but compare them again
         .           .           .                   .          .          .                   .          .          .           	  // anyway because __s is probably aligned, which helps memcmp.
        16 ( 0.00%)  0           0                   8 ( 0.00%) 0          0                   0          0          0           	  if (traits_type::compare(__first, __s, __n) == 0)
        16 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          0          0          0                   8 ( 0.00%) 0          0           	    return __first - __data;
         .           .           .                   .          .          .                   .          .          .           	  __len = __last - ++__first;
         .           .           .                   .          .          .                   .          .          .           	}
         .           .           .                   .          .          .                   .          .          .                 return npos;
         .           .           .                   .          .          .                   .          .          .               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               find(_CharT __c, size_type __pos) const _GLIBCXX_NOEXCEPT
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 size_type __ret = npos;
         .           .           .                   .          .          .                   .          .          .                 const size_type __size = this->size();
        12 ( 0.00%)  0           0                   0          0          0                   0          0          0                 if (__pos < __size)
         .           .           .                   .          .          .                   .          .          .           	{
         .           .           .                   .          .          .                   .          .          .           	  const _CharT* __data = _M_data();
         .           .           .                   .          .          .                   .          .          .           	  const size_type __n = __size - __pos;
         .           .           .                   .          .          .                   .          .          .           	  const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
        20 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          6 ( 0.00%) 0          0                   0          0          0           	  if (__p)
         7 ( 0.00%)  0           0                   0          0          0                   0          0          0           	    __ret = __p - __data;
         .           .           .                   .          .          .                   .          .          .           	}
         .           .           .                   .          .          .                   .          .          .                 return __ret;
         .           .           .                   .          .          .                   .          .          .               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               rfind(const _CharT* __s, size_type __pos, size_type __n) const
-- line 1262 ----------------------------------------
-- line 1297 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
         .           .           .                   .          .          .                   .          .          .               _GLIBCXX_NOEXCEPT
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 __glibcxx_requires_string_len(__s, __n);
       838 ( 0.00%)  7 ( 0.04%)  2 ( 0.02%)         34 ( 0.00%) 0          0                   0          0          0                 for (; __n && __pos < this->size(); ++__pos)
         .           .           .                   .          .          .                   .          .          .           	{
         .           .           .                   .          .          .                   .          .          .           	  const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
       442 ( 0.00%)  0           0                   0          0          0                   0          0          0           	  if (__p)
         .           .           .                   .          .          .                   .          .          .           	    return __pos;
         .           .           .                   .          .          .                   .          .          .           	}
         .           .           .                   .          .          .                   .          .          .                 return npos;
         .           .           .                   .          .          .                   .          .          .               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               typename basic_string<_CharT, _Traits, _Alloc>::size_type
         .           .           .                   .          .          .                   .          .          .               basic_string<_CharT, _Traits, _Alloc>::
-- line 1316 ----------------------------------------
-- line 1429 ----------------------------------------
         .           .           .                   .          .          .                   .          .          .           				     __str.data() + __pos2, __len);
         .           .           .                   .          .          .                   .          .          .                 if (!__r)
         .           .           .                   .          .          .                   .          .          .           	__r = _S_compare(__n1, __n2);
         .           .           .                   .          .          .                   .          .          .                 return __r;
         .           .           .                   .          .          .                   .          .          .               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               int
       440 ( 0.00%)  6 ( 0.04%)  1 ( 0.01%)          0          0          0                 220 ( 0.00%) 0          0               basic_string<_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               compare(const _CharT* __s) const _GLIBCXX_NOEXCEPT
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 __glibcxx_requires_string(__s);
         .           .           .                   .          .          .                   .          .          .                 const size_type __size = this->size();
         .           .           .                   .          .          .                   .          .          .                 const size_type __osize = traits_type::length(__s);
         .           .           .                   .          .          .                   .          .          .                 const size_type __len = std::min(__size, __osize);
         .           .           .                   .          .          .                   .          .          .                 int __r = traits_type::compare(_M_data(), __s, __len);
       110 ( 0.00%)  0           0                   0          0          0                   0          0          0                 if (!__r)
         .           .           .                   .          .          .                   .          .          .           	__r = _S_compare(__size, __osize);
         .           .           .                   .          .          .                   .          .          .                 return __r;
       330 ( 0.00%)  1 ( 0.01%)  0                 275 ( 0.00%) 0          0                   0          0          0               }
         .           .           .                   .          .          .                   .          .          .           
         .           .           .                   .          .          .                   .          .          .             template<typename _CharT, typename _Traits, typename _Alloc>
         .           .           .                   .          .          .                   .          .          .               int
         .           .           .                   .          .          .                   .          .          .               basic_string <_CharT, _Traits, _Alloc>::
         .           .           .                   .          .          .                   .          .          .               compare(size_type __pos, size_type __n1, const _CharT* __s) const
         .           .           .                   .          .          .                   .          .          .               {
         .           .           .                   .          .          .                   .          .          .                 __glibcxx_requires_string(__s);
         .           .           .                   .          .          .                   .          .          .                 _M_check(__pos, "basic_string::compare");
-- line 1456 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/mriccobene/CLionProjects/silkworm/third_party/ethash/lib/keccak/keccak.c
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                   D1mr           DLmr       Dw                  D1mw        DLmw       

-- line 28 ----------------------------------------
            .          .          .                    .              .          .                   .           .          .               __builtin_memcpy(&word, data, sizeof(word));
            .          .          .                    .              .          .                   .           .          .               return to_le64(word);
            .          .          .                    .              .          .                   .           .          .           }
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           /// Rotates the bits of x left by the count value specified by s.
            .          .          .                    .              .          .                   .           .          .           /// The s must be in range <0, 64> exclusively, otherwise the result is undefined.
            .          .          .                    .              .          .                   .           .          .           static inline uint64_t rol(uint64_t x, unsigned s)
            .          .          .                    .              .          .                   .           .          .           {
1,409,465,424 ( 4.54%) 4 ( 0.02%) 4 ( 0.04%)           0              0          0                   0           0          0               return (x << s) | (x >> (64 - s));
            .          .          .                    .              .          .                   .           .          .           }
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           static const uint64_t round_constants[24] = {  //
            .          .          .                    .              .          .                   .           .          .               0x0000000000000001, 0x0000000000008082, 0x800000000000808a, 0x8000000080008000,
            .          .          .                    .              .          .                   .           .          .               0x000000000000808b, 0x0000000080000001, 0x8000000080008081, 0x8000000000008009,
            .          .          .                    .              .          .                   .           .          .               0x000000000000008a, 0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
            .          .          .                    .              .          .                   .           .          .               0x000000008000808b, 0x800000000000008b, 0x8000000000008089, 0x8000000000008003,
            .          .          .                    .              .          .                   .           .          .               0x8000000000008002, 0x8000000000000080, 0x000000000000800a, 0x800000008000000a,
-- line 44 ----------------------------------------
-- line 68 ----------------------------------------
            .          .          .                    .              .          .                   .           .          .               uint64_t Eka, Eke, Eki, Eko, Eku;
            .          .          .                    .              .          .                   .           .          .               uint64_t Ema, Eme, Emi, Emo, Emu;
            .          .          .                    .              .          .                   .           .          .               uint64_t Esa, Ese, Esi, Eso, Esu;
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .               uint64_t Ba, Be, Bi, Bo, Bu;
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .               uint64_t Da, De, Di, Do, Du;
            .          .          .                    .              .          .                   .           .          .           
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Aba = state[0];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Abe = state[1];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Abi = state[2];
    2,025,094 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0                   0           0          0               Abo = state[3];
    4,050,188 ( 0.01%) 1 ( 0.01%) 1 ( 0.01%)   2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Abu = state[4];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Aga = state[5];
    2,025,094 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0                   0           0          0               Age = state[6];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Agi = state[7];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Ago = state[8];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Agu = state[9];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%) 45 ( 0.00%) 2 ( 0.00%)      Aka = state[10];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Ake = state[11];
    2,025,094 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0                   0           0          0               Aki = state[12];
    4,050,188 ( 0.01%) 1 ( 0.01%) 1 ( 0.01%)   2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Ako = state[13];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Aku = state[14];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Ama = state[15];
    2,025,094 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0                   0           0          0               Ame = state[16];
    6,075,282 ( 0.02%) 1 ( 0.01%) 1 ( 0.01%)   2,025,094 ( 0.03%)     0          0           4,050,188 ( 0.15%)  0          0               Ami = state[17];
    2,025,094 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0                   0           0          0               Amo = state[18];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Amu = state[19];
    2,025,094 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0                   0           0          0               Asa = state[20];
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Ase = state[21];
    2,025,094 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0                   0           0          0               Asi = state[22];
    6,075,282 ( 0.02%) 0          0            2,025,094 ( 0.03%)     0          0           4,050,188 ( 0.15%)  9 ( 0.00%) 2 ( 0.00%)      Aso = state[23];
    8,100,376 ( 0.03%) 1 ( 0.01%) 1 ( 0.01%)   2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               Asu = state[24];
            .          .          .                    .              .          .                   .           .          .           
  121,505,640 ( 0.39%) 0          0           48,602,256 ( 0.74%)     0          0                   0           0          0               for (size_t n = 0; n < 24; n += 2)
            .          .          .                    .              .          .                   .           .          .               {
            .          .          .                    .              .          .                   .           .          .                   // Round (n + 0): Axx -> Exx
            .          .          .                    .              .          .                   .           .          .           
  145,806,768 ( 0.47%) 0          0          121,505,640 ( 1.84%)     0          0                   0           0          0                   Ba = Aba ^ Aga ^ Aka ^ Ama ^ Asa;
  121,505,640 ( 0.39%) 0          0           72,903,384 ( 1.10%)     0          0                   0           0          0                   Be = Abe ^ Age ^ Ake ^ Ame ^ Ase;
  121,505,640 ( 0.39%) 0          0           72,903,384 ( 1.10%)     0          0                   0           0          0                   Bi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
  145,806,768 ( 0.47%) 1 ( 0.01%) 1 ( 0.01%)  97,204,512 ( 1.47%)     0          0                   0           0          0                   Bo = Abo ^ Ago ^ Ako ^ Amo ^ Aso;
  121,505,640 ( 0.39%) 1 ( 0.01%) 1 ( 0.01%)  97,204,512 ( 1.47%)     0          0                   0           0          0                   Bu = Abu ^ Agu ^ Aku ^ Amu ^ Asu;
            .          .          .                    .              .          .                   .           .          .           
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Da = Bu ^ rol(Be, 1);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   De = Ba ^ rol(Bi, 1);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Di = Be ^ rol(Bo, 1);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Do = Bi ^ rol(Bu, 1);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Du = Bo ^ rol(Ba, 1);
            .          .          .                    .              .          .                   .           .          .           
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Ba = Aba ^ Da;
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Be = rol(Age ^ De, 44);
   24,301,128 ( 0.08%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0                   0           0          0                   Bi = rol(Aki ^ Di, 43);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Bo = rol(Amo ^ Do, 21);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Bu = rol(Asu ^ Du, 14);
  145,806,768 ( 0.47%) 0          0           48,602,256 ( 0.74%)   275 ( 0.00%) 8 ( 0.00%) 24,301,128 ( 0.87%)  0          0                   Eba = Ba ^ (~Be & Bi) ^ round_constants[n];
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ebe = Be ^ (~Bi & Bo);
   97,204,512 ( 0.31%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0          24,301,128 ( 0.87%)  0          0                   Ebi = Bi ^ (~Bo & Bu);
   97,204,512 ( 0.31%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ebo = Bo ^ (~Bu & Ba);
   97,204,512 ( 0.31%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ebu = Bu ^ (~Ba & Be);
            .          .          .                    .              .          .                   .           .          .           
   48,602,256 ( 0.16%) 1 ( 0.01%) 1 ( 0.01%)  24,301,128 ( 0.37%)     0          0                   0           0          0                   Ba = rol(Abo ^ Do, 28);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Be = rol(Agu ^ Du, 20);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bi = rol(Aka ^ Da, 3);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Bo = rol(Ame ^ De, 45);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Bu = rol(Asi ^ Di, 61);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ega = Ba ^ (~Be & Bi);
   97,204,512 ( 0.31%) 0          0                    0              0          0                   0           0          0                   Ege = Be ^ (~Bi & Bo);
   72,903,384 ( 0.23%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0          24,301,128 ( 0.87%)  0          0                   Egi = Bi ^ (~Bo & Bu);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ego = Bo ^ (~Bu & Ba);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Egu = Bu ^ (~Ba & Be);
            .          .          .                    .              .          .                   .           .          .           
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Ba = rol(Abe ^ De, 1);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Be = rol(Agi ^ Di, 6);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bi = rol(Ako ^ Do, 25);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bo = rol(Amu ^ Du, 8);
   48,602,256 ( 0.16%) 1 ( 0.01%) 1 ( 0.01%)  24,301,128 ( 0.37%)     0          0                   0           0          0                   Bu = rol(Asa ^ Da, 18);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Eka = Ba ^ (~Be & Bi);
   97,204,512 ( 0.31%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Eke = Be ^ (~Bi & Bo);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Eki = Bi ^ (~Bo & Bu);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Eko = Bo ^ (~Bu & Ba);
   72,903,384 ( 0.23%) 0          0                    0              0          0                   0           0          0                   Eku = Bu ^ (~Ba & Be);
            .          .          .                    .              .          .                   .           .          .           
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Ba = rol(Abu ^ Du, 27);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Be = rol(Aga ^ Da, 36);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bi = rol(Ake ^ De, 10);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bo = rol(Ami ^ Di, 15);
   48,602,256 ( 0.16%) 1 ( 0.01%) 1 ( 0.01%)  24,301,128 ( 0.37%)     0          0                   0           0          0                   Bu = rol(Aso ^ Do, 56);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ema = Ba ^ (~Be & Bi);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Eme = Be ^ (~Bi & Bo);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Emi = Bi ^ (~Bo & Bu);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Emo = Bo ^ (~Bu & Ba);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Emu = Bu ^ (~Ba & Be);
            .          .          .                    .              .          .                   .           .          .           
   24,301,128 ( 0.08%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Ba = rol(Abi ^ Di, 62);
   24,301,128 ( 0.08%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Be = rol(Ago ^ Do, 55);
   24,301,128 ( 0.08%) 1 ( 0.01%) 1 ( 0.01%)  24,301,128 ( 0.37%)     0          0                   0           0          0                   Bi = rol(Aku ^ Du, 39);
   24,301,128 ( 0.08%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bo = rol(Ama ^ Da, 41);
   24,301,128 ( 0.08%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bu = rol(Ase ^ De, 2);
   72,903,384 ( 0.23%) 0          0                    0              0          0                   0           0          0                   Esa = Ba ^ (~Be & Bi);
   72,903,384 ( 0.23%) 0          0                    0              0          0                   0           0          0                   Ese = Be ^ (~Bi & Bo);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Esi = Bi ^ (~Bo & Bu);
   72,903,384 ( 0.23%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0          24,301,128 ( 0.87%)  0          0                   Eso = Bo ^ (~Bu & Ba);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Esu = Bu ^ (~Ba & Be);
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .                   // Round (n + 1): Exx -> Axx
            .          .          .                    .              .          .                   .           .          .           
  170,107,896 ( 0.55%) 0          0           97,204,512 ( 1.47%)     0          0          24,301,128 ( 0.87%)  0          0                   Ba = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
  145,806,768 ( 0.47%) 1 ( 0.01%) 1 ( 0.01%)  48,602,256 ( 0.74%)     0          0          24,301,128 ( 0.87%)  0          0                   Be = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
  145,806,768 ( 0.47%) 0          0           48,602,256 ( 0.74%)     0          0          24,301,128 ( 0.87%)  0          0                   Bi = Ebi ^ Egi ^ Eki ^ Emi ^ Esi;
  145,806,768 ( 0.47%) 0          0           97,204,512 ( 1.47%)     0          0                   0           0          0                   Bo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
  145,806,768 ( 0.47%) 1 ( 0.01%) 1 ( 0.01%)  72,903,384 ( 1.10%)     0          0          24,301,128 ( 0.87%)  0          0                   Bu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;
            .          .          .                    .              .          .                   .           .          .           
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Da = Bu ^ rol(Be, 1);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   De = Ba ^ rol(Bi, 1);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Di = Be ^ rol(Bo, 1);
   24,301,128 ( 0.08%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0                   0           0          0                   Do = Bi ^ rol(Bu, 1);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Du = Bo ^ rol(Ba, 1);
            .          .          .                    .              .          .                   .           .          .           
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Ba = Eba ^ Da;
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Be = rol(Ege ^ De, 44);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Bi = rol(Eki ^ Di, 43);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Bo = rol(Emo ^ Do, 21);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Bu = rol(Esu ^ Du, 14);
  145,806,768 ( 0.47%) 0          0           48,602,256 ( 0.74%)     0          0          24,301,128 ( 0.87%)  0          0                   Aba = Ba ^ (~Be & Bi) ^ round_constants[n + 1];
   97,204,512 ( 0.31%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0          24,301,128 ( 0.87%)  0          0                   Abe = Be ^ (~Bi & Bo);
   97,204,512 ( 0.31%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Abi = Bi ^ (~Bo & Bu);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Abo = Bo ^ (~Bu & Ba);
   97,204,512 ( 0.31%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Abu = Bu ^ (~Ba & Be);
            .          .          .                    .              .          .                   .           .          .           
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Ba = rol(Ebo ^ Do, 28);
   48,602,256 ( 0.16%) 1 ( 0.01%) 1 ( 0.01%)  24,301,128 ( 0.37%)     0          0                   0           0          0                   Be = rol(Egu ^ Du, 20);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bi = rol(Eka ^ Da, 3);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Bo = rol(Eme ^ De, 45);
   24,301,128 ( 0.08%) 0          0                    0              0          0                   0           0          0                   Bu = rol(Esi ^ Di, 61);
   97,204,512 ( 0.31%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0          24,301,128 ( 0.87%)  0          0                   Aga = Ba ^ (~Be & Bi);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Age = Be ^ (~Bi & Bo);
   97,204,512 ( 0.31%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Agi = Bi ^ (~Bo & Bu);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ago = Bo ^ (~Bu & Ba);
   97,204,512 ( 0.31%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Agu = Bu ^ (~Ba & Be);
            .          .          .                    .              .          .                   .           .          .           
   48,602,256 ( 0.16%) 1 ( 0.01%) 1 ( 0.01%)  24,301,128 ( 0.37%)     0          0                   0           0          0                   Ba = rol(Ebe ^ De, 1);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Be = rol(Egi ^ Di, 6);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bi = rol(Eko ^ Do, 25);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bo = rol(Emu ^ Du, 8);
   48,602,256 ( 0.16%) 1 ( 0.01%) 1 ( 0.01%)  24,301,128 ( 0.37%)     0          0                   0           0          0                   Bu = rol(Esa ^ Da, 18);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Aka = Ba ^ (~Be & Bi);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ake = Be ^ (~Bi & Bo);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Aki = Bi ^ (~Bo & Bu);
   72,903,384 ( 0.23%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0          24,301,128 ( 0.87%)  0          0                   Ako = Bo ^ (~Bu & Ba);
   97,204,512 ( 0.31%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Aku = Bu ^ (~Ba & Be);
            .          .          .                    .              .          .                   .           .          .           
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Ba = rol(Ebu ^ Du, 27);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Be = rol(Ega ^ Da, 36);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bi = rol(Eke ^ De, 10);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bo = rol(Emi ^ Di, 15);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bu = rol(Eso ^ Do, 56);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ama = Ba ^ (~Be & Bi);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Ame = Be ^ (~Bi & Bo);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ami = Bi ^ (~Bo & Bu);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Amo = Bo ^ (~Bu & Ba);
   72,903,384 ( 0.23%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0          24,301,128 ( 0.87%)  0          0                   Amu = Bu ^ (~Ba & Be);
            .          .          .                    .              .          .                   .           .          .           
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Ba = rol(Ebi ^ Di, 62);
   24,301,128 ( 0.08%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Be = rol(Ego ^ Do, 55);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bi = rol(Eku ^ Du, 39);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bo = rol(Ema ^ Da, 41);
   48,602,256 ( 0.16%) 0          0           24,301,128 ( 0.37%)     0          0                   0           0          0                   Bu = rol(Ese ^ De, 2);
   72,903,384 ( 0.23%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0          24,301,128 ( 0.87%)  0          0                   Asa = Ba ^ (~Be & Bi);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Ase = Be ^ (~Bi & Bo);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Asi = Bi ^ (~Bo & Bu);
   72,903,384 ( 0.23%) 0          0                    0              0          0          24,301,128 ( 0.87%)  0          0                   Aso = Bo ^ (~Bu & Ba);
   48,602,256 ( 0.16%) 0          0                    0              0          0                   0           0          0                   Asu = Bu ^ (~Ba & Be);
            .          .          .                    .              .          .                   .           .          .               }
            .          .          .                    .              .          .                   .           .          .           
    8,100,376 ( 0.03%) 0          0            6,075,282 ( 0.09%)     0          0           2,025,094 ( 0.07%)  0          0               state[0] = Aba;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[1] = Abe;
    4,050,188 ( 0.01%) 1 ( 0.01%) 1 ( 0.01%)   2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[2] = Abi;
    2,025,094 ( 0.01%) 0          0                    0              0          0           2,025,094 ( 0.07%)  0          0               state[3] = Abo;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[4] = Abu;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[5] = Aga;
    2,025,094 ( 0.01%) 0          0                    0              0          0           2,025,094 ( 0.07%)  0          0               state[6] = Age;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[7] = Agi;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[8] = Ago;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[9] = Agu;
    4,050,188 ( 0.01%) 1 ( 0.01%) 1 ( 0.01%)   2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[10] = Aka;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[11] = Ake;
    2,025,094 ( 0.01%) 0          0                    0              0          0           2,025,094 ( 0.07%)  0          0               state[12] = Aki;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[13] = Ako;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[14] = Aku;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[15] = Ama;
    2,025,094 ( 0.01%) 0          0                    0              0          0           2,025,094 ( 0.07%)  0          0               state[16] = Ame;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[17] = Ami;
    2,025,094 ( 0.01%) 0          0                    0              0          0           2,025,094 ( 0.07%)  0          0               state[18] = Amo;
    4,050,188 ( 0.01%) 0          0            2,025,094 ( 0.03%)     0          0           2,025,094 ( 0.07%)  0          0               state[19] = Amu;
    2,025,094 ( 0.01%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0           2,025,094 ( 0.07%)  0          0               state[20] = Asa;
    2,025,094 ( 0.01%) 0          0                    0              0          0           2,025,094 ( 0.07%)  0          0               state[21] = Ase;
    2,025,094 ( 0.01%) 0          0                    0              0          0           2,025,094 ( 0.07%)  0          0               state[22] = Asi;
    2,025,094 ( 0.01%) 0          0                    0              0          0           2,025,094 ( 0.07%)  0          0               state[23] = Aso;
    2,025,094 ( 0.01%) 0          0                    0              0          0           2,025,094 ( 0.07%)  0          0               state[24] = Asu;
            .          .          .                    .              .          .                   .           .          .           }
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           static void keccakf1600_generic(uint64_t state[25])
            .          .          .                    .              .          .                   .           .          .           {
            .          .          .                    .              .          .                   .           .          .               keccakf1600_implementation(state);
            .          .          .                    .              .          .                   .           .          .           }
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           /// The pointer to the best Keccak-f[1600] function implementation,
            .          .          .                    .              .          .                   .           .          .           /// selected during runtime initialization.
            .          .          .                    .              .          .                   .           .          .           static void (*keccakf1600_best)(uint64_t[25]) = keccakf1600_generic;
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           #if !defined(_MSC_VER) && defined(__x86_64__) && __has_attribute(target)
            .          .          .                    .              .          .                   .           .          .           __attribute__((target("bmi,bmi2"))) static void keccakf1600_bmi(uint64_t state[25])
   20,250,940 ( 0.07%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0          14,175,658 ( 0.51%)  0          0           {
            .          .          .                    .              .          .                   .           .          .               keccakf1600_implementation(state);
   16,200,752 ( 0.05%) 0          0           14,175,658 ( 0.21%)     0          0                   0           0          0           }
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           __attribute__((constructor)) static void select_keccakf1600_implementation(void)
            4 ( 0.00%) 0          0                    0              0          0                   0           0          0           {
            .          .          .                    .              .          .                   .           .          .               // Init CPU information.
            .          .          .                    .              .          .                   .           .          .               // This is needed on macOS because of the bug: https://bugs.llvm.org/show_bug.cgi?id=48459.
            2 ( 0.00%) 0          0                    0              0          0                   2 ( 0.00%)  0          0               __builtin_cpu_init();
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .               // Check if both BMI and BMI2 are supported. Some CPUs like Intel E5-2697 v2 incorrectly
            .          .          .                    .              .          .                   .           .          .               // report BMI2 but not BMI being available.
           12 ( 0.00%) 0          0                    2 ( 0.00%)     0          0                   0           0          0               if (__builtin_cpu_supports("bmi") && __builtin_cpu_supports("bmi2"))
            4 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0                   2 ( 0.00%)  1 ( 0.00%) 0                   keccakf1600_best = keccakf1600_bmi;
            4 ( 0.00%) 0          0                    2 ( 0.00%)     0          0                   0           0          0           }
            .          .          .                    .              .          .                   .           .          .           #endif
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           static inline ALWAYS_INLINE void keccak(
            .          .          .                    .              .          .                   .           .          .               uint64_t* out, size_t bits, const uint8_t* data, size_t size)
            .          .          .                    .              .          .                   .           .          .           {
            .          .          .                    .              .          .                   .           .          .               static const size_t word_size = sizeof(uint64_t);
            .          .          .                    .              .          .                   .           .          .               const size_t hash_size = bits / 8;
            .          .          .                    .              .          .                   .           .          .               const size_t block_size = (1600 - bits * 2) / 8;
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .               size_t i;
            .          .          .                    .              .          .                   .           .          .               uint64_t* state_iter;
      500,000 ( 0.00%) 0          0                    0              0          0             500,000 ( 0.02%)  0          0               uint64_t last_word = 0;
            .          .          .                    .              .          .                   .           .          .               uint8_t* last_word_iter = (uint8_t*)&last_word;
            .          .          .                    .              .          .                   .           .          .           
   14,500,000 ( 0.05%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0          12,500,000 ( 0.45%)  0          0               uint64_t state[25] = {0};
            .          .          .                    .              .          .                   .           .          .           
    4,550,188 ( 0.01%) 0          0                    0              0          0                   0           0          0               while (size >= block_size)
            .          .          .                    .              .          .                   .           .          .               {
            .          .          .                    .              .          .                   .           .          .                   for (i = 0; i < (block_size / word_size); ++i)
            .          .          .                    .              .          .                   .           .          .                   {
   39,652,444 ( 0.13%) 3 ( 0.02%) 3 ( 0.03%)  27,451,692 ( 0.42%)     5 ( 0.00%) 1 ( 0.00%) 12,200,752 ( 0.44%)  0          0                       state[i] ^= load_le(data);
    1,525,094 ( 0.00%) 0          0                    0              0          0                   0           0          0                       data += word_size;
            .          .          .                    .              .          .                   .           .          .                   }
            .          .          .                    .              .          .                   .           .          .           
    3,050,188 ( 0.01%) 0          0            1,525,094 ( 0.02%) 1,651 ( 0.00%) 1 ( 0.00%)  1,525,094 ( 0.05%)  0          0                   keccakf1600_best(state);
            .          .          .                    .              .          .                   .           .          .           
    1,525,094 ( 0.00%) 0          0                    0              0          0                   0           0          0                   size -= block_size;
            .          .          .                    .              .          .                   .           .          .               }
            .          .          .                    .              .          .                   .           .          .           
       50,188 ( 0.00%) 0          0                    0              0          0                   0           0          0               state_iter = state;
            .          .          .                    .              .          .                   .           .          .           
   15,005,590 ( 0.05%) 5 ( 0.03%) 5 ( 0.05%)           0              0          0                   0           0          0               while (size >= word_size)
            .          .          .                    .              .          .                   .           .          .               {
   14,645,810 ( 0.05%) 2 ( 0.01%) 2 ( 0.02%)   7,797,811 ( 0.12%)     0          0           6,847,999 ( 0.25%)  0          0                   *state_iter ^= load_le(data);
      474,906 ( 0.00%) 0          0                    0              0          0                   0           0          0                   ++state_iter;
      474,906 ( 0.00%) 0          0                    0              0          0                   0           0          0                   data += word_size;
    7,952,607 ( 0.03%) 1 ( 0.01%) 1 ( 0.01%)           0              0          0                   0           0          0                   size -= word_size;
            .          .          .                    .              .          .                   .           .          .               }
            .          .          .                    .              .          .                   .           .          .           
    1,000,000 ( 0.00%) 0          0                    0              0          0                   0           0          0               while (size > 0)
            .          .          .                    .              .          .                   .           .          .               {
    8,140,046 ( 0.03%) 0          0            1,081,129 ( 0.02%)     0          0           1,081,129 ( 0.04%)  0          0                   *last_word_iter = *data;
      288,318 ( 0.00%) 0          0                    0              0          0                   0           0          0                   ++last_word_iter;
            .          .          .                    .              .          .                   .           .          .                   ++data;
            .          .          .                    .              .          .                   .           .          .                   --size;
            .          .          .                    .              .          .                   .           .          .               }
      500,000 ( 0.00%) 0          0                    0              0          0             500,000 ( 0.02%)  0          0               *last_word_iter = 0x01;
    9,617,921 ( 0.03%) 0          0            8,322,905 ( 0.13%)     0          0             500,000 ( 0.02%)  0          0               *state_iter ^= to_le64(last_word);
            .          .          .                    .              .          .                   .           .          .           
      500,000 ( 0.00%) 0          0              500,000 ( 0.01%)     0          0                   0           0          0               state[(block_size / word_size) - 1] ^= 0x8000000000000000;
            .          .          .                    .              .          .                   .           .          .           
    1,000,000 ( 0.00%) 2 ( 0.01%) 2 ( 0.02%)     500,000 ( 0.01%)     0          0             500,000 ( 0.02%)  0          0               keccakf1600_best(state);
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .               for (i = 0; i < (hash_size / word_size); ++i)
            .          .          .                    .              .          .                   .           .          .                   out[i] = to_le64(state[i]);
            .          .          .                    .              .          .                   .           .          .           }
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           union ethash_hash256 ethash_keccak256(const uint8_t* data, size_t size)
    6,000,000 ( 0.02%) 1 ( 0.01%) 1 ( 0.01%)     500,000 ( 0.01%)     0          0           2,500,000 ( 0.09%)  0          0           {
            .          .          .                    .              .          .                   .           .          .               union ethash_hash256 hash;
            .          .          .                    .              .          .                   .           .          .               keccak(hash.word64s, 256, data, size);
    2,000,000 ( 0.01%) 0          0            1,000,000 ( 0.02%)     0          0           1,000,000 ( 0.04%)  8 ( 0.00%) 2 ( 0.00%)      return hash;
    5,000,000 ( 0.02%) 1 ( 0.01%) 1 ( 0.01%)   3,500,000 ( 0.05%)     0          0                   0           0          0           }
            .          .          .                    .              .          .                   .           .          .           
            .          .          .                    .              .          .                   .           .          .           union ethash_hash256 ethash_keccak256_32(const uint8_t data[32])
            .          .          .                    .              .          .                   .           .          .           {
            .          .          .                    .              .          .                   .           .          .               union ethash_hash256 hash;
            .          .          .                    .              .          .                   .           .          .               keccak(hash.word64s, 256, data, 32);
            .          .          .                    .              .          .                   .           .          .               return hash;
            .          .          .                    .              .          .                   .           .          .           }
            .          .          .                    .              .          .                   .           .          .           
-- line 369 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/basic_string.h
--------------------------------------------------------------------------------
Ir                  I1mr         ILmr         Dr                  D1mr               DLmr             Dw                  D1mw            DLmw            

-- line 157 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                 // Use empty-base optimization: http://www.cantrip.org/emptyopt.html
         .            .            .                   .                  .                .                   .               .               .                 struct _Alloc_hider : allocator_type // TODO check __is_final
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           #if __cplusplus < 201103L
         .            .            .                   .                  .                .                   .               .               .           	_Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
         .            .            .                   .                  .                .                   .               .               .           	: allocator_type(__a), _M_p(__dat) { }
         .            .            .                   .                  .                .                   .               .               .           #else
         .            .            .                   .                  .                .                   .               .               .           	_Alloc_hider(pointer __dat, const _Alloc& __a)
 6,136,385 ( 0.02%)  28 ( 0.16%)  24 ( 0.25%)         18 ( 0.00%)         0                0           4,063,121 ( 0.15%)    731 ( 0.02%)     11 ( 0.00%)  	: allocator_type(__a), _M_p(__dat) { }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           	_Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
17,278,834 ( 0.06%) 104 ( 0.61%)  66 ( 0.69%)  1,000,179 ( 0.02%)         1 ( 0.00%)       0          11,811,520 ( 0.42%) 20,557 ( 0.66%)     75 ( 0.00%)  	: allocator_type(std::move(__a)), _M_p(__dat) { }
         .            .            .                   .                  .                .                   .               .               .           #endif
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           	pointer _M_p; // The actual data.
         .            .            .                   .                  .                .                   .               .               .                 };
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 _Alloc_hider	_M_dataplus;
         .            .            .                   .                  .                .                   .               .               .                 size_type		_M_string_length;
         .            .            .                   .                  .                .                   .               .               .           
-- line 176 ----------------------------------------
-- line 179 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                 union
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	_CharT           _M_local_buf[_S_local_capacity + 1];
         .            .            .                   .                  .                .                   .               .               .           	size_type        _M_allocated_capacity;
         .            .            .                   .                  .                .                   .               .               .                 };
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 _M_data(pointer __p)
46,652,523 ( 0.15%)  44 ( 0.26%)  34 ( 0.36%)  5,915,161 ( 0.09%)     1,872 ( 0.00%)       1 ( 0.00%) 31,632,680 ( 1.14%) 16,345 ( 0.52%)     26 ( 0.00%)        { _M_dataplus._M_p = __p; }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 _M_length(size_type __length)
69,945,938 ( 0.23%) 225 ( 1.32%) 153 ( 1.61%)  9,829,174 ( 0.15%)     1,648 ( 0.00%)       1 ( 0.00%) 57,294,294 ( 2.06%)     18 ( 0.00%)     12 ( 0.00%)        { _M_string_length = __length; }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 pointer
         .            .            .                   .                  .                .                   .               .               .                 _M_data() const
88,261,392 ( 0.28%) 227 ( 1.33%) 149 ( 1.57%) 85,457,596 ( 1.29%) 1,035,939 ( 2.74%) 500,164 ( 9.69%)         26 ( 0.00%)      0               0                 { return _M_dataplus._M_p; }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 pointer
         .            .            .                   .                  .                .                   .               .               .                 _M_local_data()
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           #if __cplusplus >= 201103L
 5,001,347 ( 0.02%)  31 ( 0.18%)  17 ( 0.18%)         34 ( 0.00%)         0                0           2,000,532 ( 0.07%) 38,867 ( 1.24%) 32,788 ( 1.39%)  	return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);
         .            .            .                   .                  .                .                   .               .               .           #else
         .            .            .                   .                  .                .                   .               .               .           	return pointer(_M_local_buf);
         .            .            .                   .                  .                .                   .               .               .           #endif
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 const_pointer
         .            .            .                   .                  .                .                   .               .               .                 _M_local_data() const
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           #if __cplusplus >= 201103L
12,552,734 ( 0.04%)  13 ( 0.08%)   7 ( 0.07%)          0                  0                0                   3 ( 0.00%)      0               0           	return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);
         .            .            .                   .                  .                .                   .               .               .           #else
         .            .            .                   .                  .                .                   .               .               .           	return const_pointer(_M_local_buf);
         .            .            .                   .                  .                .                   .               .               .           #endif
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 _M_capacity(size_type __capacity)
18,723,621 ( 0.06%)  22 ( 0.13%)  16 ( 0.17%)  6,192,901 ( 0.09%)         0                0          12,530,696 ( 0.45%)    471 ( 0.02%)      5 ( 0.00%)        { _M_allocated_capacity = __capacity; }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 _M_set_length(size_type __n)
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	_M_length(__n);
        24 ( 0.00%)   0            0                   6 ( 0.00%)         0                0                   0               0               0           	traits_type::assign(_M_data()[__n], _CharT());
 7,737,350 ( 0.02%)   8 ( 0.05%)   6 ( 0.06%)         16 ( 0.00%)         0                0                   0               0               0                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 bool
         .            .            .                   .                  .                .                   .               .               .                 _M_is_local() const
         .            .            .                   .                  .                .                   .               .               .                 { return _M_data() == _M_local_data(); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 // Create & Destroy
         .            .            .                   .                  .                .                   .               .               .                 pointer
         .            .            .                   .                  .                .                   .               .               .                 _M_create(size_type&, size_type);
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 _M_dispose()
         .            .            .                   .                  .                .                   .               .               .                 {
37,784,242 ( 0.12%)  73 ( 0.43%)  55 ( 0.58%)  2,063,044 ( 0.03%)         5 ( 0.00%)       0                  18 ( 0.00%)      3 ( 0.00%)      0           	if (!_M_is_local())
         .            .            .                   .                  .                .                   .               .               .           	  _M_destroy(_M_allocated_capacity);
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 _M_destroy(size_type __size) throw()
 6,500,672 ( 0.02%)  25 ( 0.15%)  19 ( 0.20%)  3,000,336 ( 0.05%)         2 ( 0.00%)       1 ( 0.00%)          0               0               0                 { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 // _M_construct_aux is used to implement the 21.3.1 para 15 which
         .            .            .                   .                  .                .                   .               .               .                 // requires special behaviour if _InIterator is an integral type
         .            .            .                   .                  .                .                   .               .               .                 template<typename _InIterator>
         .            .            .                   .                  .                .                   .               .               .                   void
         .            .            .                   .                  .                .                   .               .               .                   _M_construct_aux(_InIterator __beg, _InIterator __end,
         .            .            .                   .                  .                .                   .               .               .           			 std::__false_type)
         .            .            .                   .                  .                .                   .               .               .           	{
         .            .            .                   .                  .                .                   .               .               .                     typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
 4,002,194 ( 0.01%)  30 ( 0.18%)  22 ( 0.23%)        119 ( 0.00%)         0                0           1,501,000 ( 0.05%)      0               0                     _M_construct(__beg, __end, _Tag());
         .            .            .                   .                  .                .                   .               .               .           	}
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .            .            .                   .                  .                .                   .               .               .                 // 438. Ambiguity in the "do the right thing" clause
         .            .            .                   .                  .                .                   .               .               .                 template<typename _Integer>
         .            .            .                   .                  .                .                   .               .               .                   void
         .            .            .                   .                  .                .                   .               .               .                   _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
         .            .            .                   .                  .                .                   .               .               .           	{ _M_construct_aux_2(static_cast<size_type>(__beg), __end); }
-- line 263 ----------------------------------------
-- line 312 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .           	{ typedef basic_string& __type; };
         .            .            .                   .                  .                .                   .               .               .                 template<typename _Tp>
         .            .            .                   .                  .                .                   .               .               .           	struct __enable_if_not_native_iterator<_Tp, false> { };
         .            .            .                   .                  .                .                   .               .               .           #endif
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 size_type
         .            .            .                   .                  .                .                   .               .               .                 _M_check(size_type __pos, const char* __s) const
         .            .            .                   .                  .                .                   .               .               .                 {
       112 ( 0.00%)   2 ( 0.01%)   2 ( 0.02%)          0                  0                0                   0               0               0           	if (__pos > this->size())
         .            .            .                   .                  .                .                   .               .               .           	  __throw_out_of_range_fmt(__N("%s: __pos (which is %zu) > "
         .            .            .                   .                  .                .                   .               .               .           				       "this->size() (which is %zu)"),
         .            .            .                   .                  .                .                   .               .               .           				   __s, __pos, this->size());
         .            .            .                   .                  .                .                   .               .               .           	return __pos;
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 _M_check_length(size_type __n1, size_type __n2, const char* __s) const
         .            .            .                   .                  .                .                   .               .               .                 {
 8,000,434 ( 0.03%)   8 ( 0.05%)   7 ( 0.07%)          0                  0                0                   0               0               0           	if (this->max_size() - (this->size() - __n1) < __n2)
         .            .            .                   .                  .                .                   .               .               .           	  __throw_length_error(__N(__s));
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 // NB: _M_limit doesn't check for a bad __pos value.
         .            .            .                   .                  .                .                   .               .               .                 size_type
         .            .            .                   .                  .                .                   .               .               .                 _M_limit(size_type __pos, size_type __off) const _GLIBCXX_NOEXCEPT
         .            .            .                   .                  .                .                   .               .               .                 {
-- line 338 ----------------------------------------
-- line 340 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .           	return __testoff ? __off : this->size() - __pos;
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 // True if _Rep and source do not overlap.
         .            .            .                   .                  .                .                   .               .               .                 bool
         .            .            .                   .                  .                .                   .               .               .                 _M_disjunct(const _CharT* __s) const _GLIBCXX_NOEXCEPT
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	return (less<const _CharT*>()(__s, _M_data())
       165 ( 0.00%)   6 ( 0.04%)   2 ( 0.02%)          0                  0                0                   0               0               0           		|| less<const _CharT*>()(_M_data() + this->size(), __s));
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 // When __n = 1 way faster than the general multichar
         .            .            .                   .                  .                .                   .               .               .                 // traits_type::copy/move/assign.
         .            .            .                   .                  .                .                   .               .               .                 static void
         .            .            .                   .                  .                .                   .               .               .                 _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
         .            .            .                   .                  .                .                   .               .               .                 {
25,298,281 ( 0.08%)   7 ( 0.04%)   4 ( 0.04%)          0                  0                0           1,000,005 ( 0.04%)      0               0           	if (__n == 1)
         .            .            .                   .                  .                .                   .               .               .           	  traits_type::assign(*__d, *__s);
         .            .            .                   .                  .                .                   .               .               .           	else
         .            .            .                   .                  .                .                   .               .               .           	  traits_type::copy(__d, __s, __n);
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 static void
         .            .            .                   .                  .                .                   .               .               .                 _S_move(_CharT* __d, const _CharT* __s, size_type __n)
         .            .            .                   .                  .                .                   .               .               .                 {
        20 ( 0.00%)   0            0                   0                  0                0                   0               0               0           	if (__n == 1)
         .            .            .                   .                  .                .                   .               .               .           	  traits_type::assign(*__d, *__s);
         .            .            .                   .                  .                .                   .               .               .           	else
         .            .            .                   .                  .                .                   .               .               .           	  traits_type::move(__d, __s, __n);
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 static void
         .            .            .                   .                  .                .                   .               .               .                 _S_assign(_CharT* __d, size_type __n, _CharT __c)
         .            .            .                   .                  .                .                   .               .               .                 {
 1,980,030 ( 0.01%)   2 ( 0.01%)   2 ( 0.02%)          0                  0                0                   0               0               0           	if (__n == 1)
         .            .            .                   .                  .                .                   .               .               .           	  traits_type::assign(*__d, __c);
         .            .            .                   .                  .                .                   .               .               .           	else
         .            .            .                   .                  .                .                   .               .               .           	  traits_type::assign(__d, __n, __c);
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 // _S_copy_chars is a separate template to permit specialization
         .            .            .                   .                  .                .                   .               .               .                 // to optimize for the common case of pointers as iterators.
         .            .            .                   .                  .                .                   .               .               .                 template<class _Iterator>
-- line 382 ----------------------------------------
-- line 403 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                 static void
         .            .            .                   .                  .                .                   .               .               .                 _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
         .            .            .                   .                  .                .                   .               .               .                 _GLIBCXX_NOEXCEPT
         .            .            .                   .                  .                .                   .               .               .                 { _S_copy(__p, __k1, __k2 - __k1); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 static int
         .            .            .                   .                  .                .                   .               .               .                 _S_compare(size_type __n1, size_type __n2) _GLIBCXX_NOEXCEPT
         .            .            .                   .                  .                .                   .               .               .                 {
        49 ( 0.00%)   0            0                   0                  0                0                   0               0               0           	const difference_type __d = difference_type(__n1 - __n2);
         .            .            .                   .                  .                .                   .               .               .           
        98 ( 0.00%)   0            0                   0                  0                0                   0               0               0           	if (__d > __gnu_cxx::__numeric_traits<int>::__max)
        49 ( 0.00%)   0            0                   0                  0                0                   0               0               0           	  return __gnu_cxx::__numeric_traits<int>::__max;
         .            .            .                   .                  .                .                   .               .               .           	else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
         .            .            .                   .                  .                .                   .               .               .           	  return __gnu_cxx::__numeric_traits<int>::__min;
         .            .            .                   .                  .                .                   .               .               .           	else
       147 ( 0.00%)  10 ( 0.06%)   1 ( 0.01%)          0                  0                0                   0               0               0           	  return int(__d);
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 _M_assign(const basic_string&);
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
         .            .            .                   .                  .                .                   .               .               .           		size_type __len2);
-- line 426 ----------------------------------------
-- line 434 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                 // arguments, per 17.4.4.4 para. 2 item 2.
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Default constructor creates an empty string.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string()
         .            .            .                   .                  .                .                   .               .               .                 _GLIBCXX_NOEXCEPT_IF(is_nothrow_default_constructible<_Alloc>::value)
         .            .            .                   .                  .                .                   .               .               .                 : _M_dataplus(_M_local_data())
         1 ( 0.00%)   0            0                   0                  0                0                   0               0               0                 { _M_set_length(0); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Construct an empty string using allocator @a a.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 explicit
         .            .            .                   .                  .                .                   .               .               .                 basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT
         .            .            .                   .                  .                .                   .               .               .                 : _M_dataplus(_M_local_data(), __a)
         .            .            .                   .                  .                .                   .               .               .                 { _M_set_length(0); }
-- line 450 ----------------------------------------
-- line 451 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Construct string with copy of value of @a __str.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __str  Source string.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string(const basic_string& __str)
         .            .            .                   .                  .                .                   .               .               .                 : _M_dataplus(_M_local_data(),
         .            .            .                   .                  .                .                   .               .               .           		    _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
 2,001,208 ( 0.01%)  21 ( 0.12%)  11 ( 0.12%)  1,000,564 ( 0.02%)         3 ( 0.00%)       0                  56 ( 0.00%)      0               0                 { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .            .            .                   .                  .                .                   .               .               .                 // 2583. no way to supply an allocator for basic_string(str, pos)
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Construct string as copy of a substring.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __str  Source string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __pos  Index of first character to copy from.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __a  Allocator to use.
-- line 467 ----------------------------------------
-- line 480 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __str  Source string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __pos  Index of first character to copy from.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __n  Number of characters to copy.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string(const basic_string& __str, size_type __pos,
         .            .            .                   .                  .                .                   .               .               .           		   size_type __n)
         .            .            .                   .                  .                .                   .               .               .                 : _M_dataplus(_M_local_data())
         .            .            .                   .                  .                .                   .               .               .                 {
        52 ( 0.00%)   0            0                   8 ( 0.00%)         0                0                   0               0               0           	const _CharT* __start = __str._M_data()
         .            .            .                   .                  .                .                   .               .               .           	  + __str._M_check(__pos, "basic_string::basic_string");
       152 ( 0.00%)   1 ( 0.01%)   1 ( 0.01%)         21 ( 0.00%)         0                0                   0               0               0           	_M_construct(__start, __start + __str._M_limit(__pos, __n));
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Construct string as copy of a substring.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __str  Source string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __pos  Index of first character to copy from.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __n  Number of characters to copy.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __a  Allocator to use.
-- line 498 ----------------------------------------
-- line 513 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __a  Allocator to use (default is default allocator).
         .            .            .                   .                  .                .                   .               .               .                  *
         .            .            .                   .                  .                .                   .               .               .                  *  NB: @a __s must have at least @a __n characters, &apos;\\0&apos;
         .            .            .                   .                  .                .                   .               .               .                  *  has no special meaning.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string(const _CharT* __s, size_type __n,
         .            .            .                   .                  .                .                   .               .               .           		   const _Alloc& __a = _Alloc())
         .            .            .                   .                  .                .                   .               .               .                 : _M_dataplus(_M_local_data(), __a)
        65 ( 0.00%)   6 ( 0.04%)   5 ( 0.05%)         31 ( 0.00%)         0                0                   0               0               0                 { _M_construct(__s, __s + __n); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Construct string as copy of a C string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __s  Source C string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __a  Allocator to use (default is default allocator).
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .           #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
         .            .            .                   .                  .                .                   .               .               .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .            .            .                   .                  .                .                   .               .               .                 // 3076. basic_string CTAD ambiguity
         .            .            .                   .                  .                .                   .               .               .                 template<typename = _RequireAllocator<_Alloc>>
         .            .            .                   .                  .                .                   .               .               .           #endif
       435 ( 0.00%)  11 ( 0.06%)   8 ( 0.08%)          0                  0                0                 184 ( 0.00%)      0               0                 basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
         .            .            .                   .                  .                .                   .               .               .                 : _M_dataplus(_M_local_data(), __a)
         .            .            .                   .                  .                .                   .               .               .                 {
       253 ( 0.00%)   0            0                   0                  0                0                   0               0               0           	const _CharT* __end = __s ? __s + traits_type::length(__s)
         .            .            .                   .                  .                .                   .               .               .           	  // We just need a non-null pointer here to get an exception:
         .            .            .                   .                  .                .                   .               .               .           	  : reinterpret_cast<const _CharT*>(__alignof__(_CharT));
       505 ( 0.00%)  11 ( 0.06%)  10 ( 0.11%)          6 ( 0.00%)         0                0                  88 ( 0.00%)      2 ( 0.00%)      1 ( 0.00%)  	_M_construct(__s, __end, random_access_iterator_tag());
       276 ( 0.00%)   0            0                 201 ( 0.00%)         0                0                   0               0               0                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Construct string as multiple characters.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __n  Number of characters.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __c  Character to use.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __a  Allocator to use (default is default allocator).
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .           #if __cpp_deduction_guides && ! defined _GLIBCXX_DEFINING_STRING_INSTANTIATIONS
         .            .            .                   .                  .                .                   .               .               .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .            .            .                   .                  .                .                   .               .               .                 // 3076. basic_string CTAD ambiguity
         .            .            .                   .                  .                .                   .               .               .                 template<typename = _RequireAllocator<_Alloc>>
         .            .            .                   .                  .                .                   .               .               .           #endif
         .            .            .                   .                  .                .                   .               .               .                 basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
         .            .            .                   .                  .                .                   .               .               .                 : _M_dataplus(_M_local_data(), __a)
        22 ( 0.00%)   0            0                   0                  0                0                  10 ( 0.00%)      0               0                 { _M_construct(__n, __c); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           #if __cplusplus >= 201103L
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Move construct string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __str  Source string.
         .            .            .                   .                  .                .                   .               .               .                  *
         .            .            .                   .                  .                .                   .               .               .                  *  The newly-created string contains the exact contents of @a __str.
         .            .            .                   .                  .                .                   .               .               .                  *  @a __str is a valid, but unspecified string.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string(basic_string&& __str) noexcept
         .            .            .                   .                  .                .                   .               .               .                 : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
         .            .            .                   .                  .                .                   .               .               .                 {
24,603,688 ( 0.08%)  32 ( 0.19%)  22 ( 0.23%)    202,385 ( 0.00%)       737 ( 0.00%)       1 ( 0.00%)         13 ( 0.00%)      0               0           	if (__str._M_is_local())
         .            .            .                   .                  .                .                   .               .               .           	  {
         .            .            .                   .                  .                .                   .               .               .           	    traits_type::copy(_M_local_buf, __str._M_local_buf,
         .            .            .                   .                  .                .                   .               .               .           			      _S_local_capacity + 1);
         .            .            .                   .                  .                .                   .               .               .           	  }
         .            .            .                   .                  .                .                   .               .               .           	else
         .            .            .                   .                  .                .                   .               .               .           	  {
         .            .            .                   .                  .                .                   .               .               .           	    _M_data(__str._M_data());
   499,999 ( 0.00%)   0            0             499,999 ( 0.01%)         0                0                   0               0               0           	    _M_capacity(__str._M_allocated_capacity);
         .            .            .                   .                  .                .                   .               .               .           	  }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           	// Must use _M_length() here not _M_set_length() because
         .            .            .                   .                  .                .                   .               .               .           	// basic_stringbuf relies on writing into unallocated capacity so
         .            .            .                   .                  .                .                   .               .               .           	// we mess up the contents if we put a '\0' in the string.
         .            .            .                   .                  .                .                   .               .               .           	_M_length(__str.length());
         .            .            .                   .                  .                .                   .               .               .           	__str._M_data(__str._M_local_data());
         .            .            .                   .                  .                .                   .               .               .           	__str._M_set_length(0);
-- line 584 ----------------------------------------
-- line 663 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .           	explicit
         .            .            .                   .                  .                .                   .               .               .           	basic_string(const _Tp& __t, const _Alloc& __a = _Alloc())
         .            .            .                   .                  .                .                   .               .               .           	: basic_string(__sv_wrapper(_S_to_string_view(__t)), __a) { }
         .            .            .                   .                  .                .                   .               .               .           #endif // C++17
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Destroy the string instance.
         .            .            .                   .                  .                .                   .               .               .                  */
         9 ( 0.00%)   1 ( 0.01%)   1 ( 0.01%)          0                  0                0                   0               0               0                 ~basic_string()
         7 ( 0.00%)   1 ( 0.01%)   1 ( 0.01%)          7 ( 0.00%)         0                0                   0               0               0                 { _M_dispose(); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Assign the value of @a str to this string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __str  Source string.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string&
         .            .            .                   .                  .                .                   .               .               .                 operator=(const basic_string& __str)
         .            .            .                   .                  .                .                   .               .               .                 {
-- line 680 ----------------------------------------
-- line 709 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __str  Source string.
         .            .            .                   .                  .                .                   .               .               .                  *
         .            .            .                   .                  .                .                   .               .               .                  *  The contents of @a str are moved into this string (without copying).
         .            .            .                   .                  .                .                   .               .               .                  *  @a str is a valid, but unspecified string.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .            .            .                   .                  .                .                   .               .               .                 // 2063. Contradictory requirements for string move assignment
         .            .            .                   .                  .                .                   .               .               .                 basic_string&
        48 ( 0.00%)   2 ( 0.01%)   1 ( 0.01%)          0                  0                0                  16 ( 0.00%)      0               0                 operator=(basic_string&& __str)
         .            .            .                   .                  .                .                   .               .               .                 noexcept(_Alloc_traits::_S_nothrow_move())
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
         .            .            .                   .                  .                .                   .               .               .           	    && !_Alloc_traits::_S_always_equal()
         .            .            .                   .                  .                .                   .               .               .           	    && _M_get_allocator() != __str._M_get_allocator())
         .            .            .                   .                  .                .                   .               .               .           	  {
         .            .            .                   .                  .                .                   .               .               .           	    // Destroy existing storage before replacing allocator.
         .            .            .                   .                  .                .                   .               .               .           	    _M_destroy(_M_allocated_capacity);
         .            .            .                   .                  .                .                   .               .               .           	    _M_data(_M_local_data());
         .            .            .                   .                  .                .                   .               .               .           	    _M_set_length(0);
         .            .            .                   .                  .                .                   .               .               .           	  }
         .            .            .                   .                  .                .                   .               .               .           	// Replace allocator if POCMA is true.
         .            .            .                   .                  .                .                   .               .               .           	std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());
         .            .            .                   .                  .                .                   .               .               .           
26,589,956 ( 0.09%)   7 ( 0.04%)   7 ( 0.07%)  1,000,036 ( 0.02%)         0                0                   3 ( 0.00%)      0               0           	if (__str._M_is_local())
         .            .            .                   .                  .                .                   .               .               .           	  {
         .            .            .                   .                  .                .                   .               .               .           	    // We've always got room for a short string, just copy it
         .            .            .                   .                  .                .                   .               .               .           	    // (unless this is a self-move, because that would violate the
         .            .            .                   .                  .                .                   .               .               .           	    // char_traits::copy precondition that the ranges don't overlap).
 4,197,164 ( 0.01%)   5 ( 0.03%)   4 ( 0.04%)    499,984 ( 0.01%)         0                0                   0               0               0           	    if (__builtin_expect(std::__addressof(__str) != this, true))
         .            .            .                   .                  .                .                   .               .               .           	      {
15,474,674 ( 0.05%)  26 ( 0.15%)  15 ( 0.16%)          0                  0                0                   0               0               0           		if (__str.size())
         .            .            .                   .                  .                .                   .               .               .           		  this->_S_copy(_M_data(), __str._M_data(), __str.size());
         .            .            .                   .                  .                .                   .               .               .           		_M_set_length(__str.size());
         .            .            .                   .                  .                .                   .               .               .           	      }
         .            .            .                   .                  .                .                   .               .               .           	  }
         .            .            .                   .                  .                .                   .               .               .           	else if (_Alloc_traits::_S_propagate_on_move_assign()
         .            .            .                   .                  .                .                   .               .               .           	    || _Alloc_traits::_S_always_equal()
         .            .            .                   .                  .                .                   .               .               .           	    || _M_get_allocator() == __str._M_get_allocator())
         .            .            .                   .                  .                .                   .               .               .           	  {
         .            .            .                   .                  .                .                   .               .               .           	    // Just move the allocated pointer, our allocator can free it.
         .            .            .                   .                  .                .                   .               .               .           	    pointer __data = nullptr;
         .            .            .                   .                  .                .                   .               .               .           	    size_type __capacity;
 7,402,463 ( 0.02%)   0            0                   8 ( 0.00%)         0                0                   0               0               0           	    if (!_M_is_local())
         .            .            .                   .                  .                .                   .               .               .           	      {
         .            .            .                   .                  .                .                   .               .               .           		if (_Alloc_traits::_S_always_equal())
         .            .            .                   .                  .                .                   .               .               .           		  {
         .            .            .                   .                  .                .                   .               .               .           		    // __str can reuse our existing storage.
         .            .            .                   .                  .                .                   .               .               .           		    __data = _M_data();
        12 ( 0.00%)   0            0                  12 ( 0.00%)         0                0                   0               0               0           		    __capacity = _M_allocated_capacity;
         .            .            .                   .                  .                .                   .               .               .           		  }
         .            .            .                   .                  .                .                   .               .               .           		else // __str can't use it, so free it.
         .            .            .                   .                  .                .                   .               .               .           		  _M_destroy(_M_allocated_capacity);
         .            .            .                   .                  .                .                   .               .               .           	      }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           	    _M_data(__str._M_data());
         .            .            .                   .                  .                .                   .               .               .           	    _M_length(__str.length());
 2,337,528 ( 0.01%)   1 ( 0.01%)   1 ( 0.01%)  2,337,465 ( 0.04%)         0                0                   0               0               0           	    _M_capacity(__str._M_allocated_capacity);
        12 ( 0.00%)   0            0                   0                  0                0                   0               0               0           	    if (__data)
         .            .            .                   .                  .                .                   .               .               .           	      {
         .            .            .                   .                  .                .                   .               .               .           		__str._M_data(__data);
         .            .            .                   .                  .                .                   .               .               .           		__str._M_capacity(__capacity);
         .            .            .                   .                  .                .                   .               .               .           	      }
         .            .            .                   .                  .                .                   .               .               .           	    else
         .            .            .                   .                  .                .                   .               .               .           	      __str._M_data(__str._M_local_buf);
         .            .            .                   .                  .                .                   .               .               .           	  }
         .            .            .                   .                  .                .                   .               .               .           	else // Need to do a deep copy
         .            .            .                   .                  .                .                   .               .               .           	  assign(__str);
         .            .            .                   .                  .                .                   .               .               .           	__str.clear();
         .            .            .                   .                  .                .                   .               .               .           	return *this;
        40 ( 0.00%)   0            0                  24 ( 0.00%)         0                0                   0               0               0                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Set value to string constructed from initializer %list.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __l  std::initializer_list.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string&
         .            .            .                   .                  .                .                   .               .               .                 operator=(initializer_list<_CharT> __l)
         .            .            .                   .                  .                .                   .               .               .                 {
-- line 786 ----------------------------------------
-- line 825 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                 { return const_iterator(_M_data()); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  Returns a read/write iterator that points one past the last
         .            .            .                   .                  .                .                   .               .               .                  *  character in the %string.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 iterator
         .            .            .                   .                  .                .                   .               .               .                 end() _GLIBCXX_NOEXCEPT
       143 ( 0.00%)   0            0                   1 ( 0.00%)         0                0                   8 ( 0.00%)      0               0                 { return iterator(_M_data() + this->size()); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  Returns a read-only (constant) iterator that points one past the
         .            .            .                   .                  .                .                   .               .               .                  *  last character in the %string.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 const_iterator
         .            .            .                   .                  .                .                   .               .               .                 end() const _GLIBCXX_NOEXCEPT
        36 ( 0.00%)   6 ( 0.04%)   1 ( 0.01%)          0                  0                0                   0               0               0                 { return const_iterator(_M_data() + this->size()); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  Returns a read/write reverse iterator that points to the last
         .            .            .                   .                  .                .                   .               .               .                  *  character in the %string.  Iteration is done in reverse element
         .            .            .                   .                  .                .                   .               .               .                  *  order.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 reverse_iterator
         .            .            .                   .                  .                .                   .               .               .                 rbegin() _GLIBCXX_NOEXCEPT
-- line 849 ----------------------------------------
-- line 913 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .           #endif
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .               public:
         .            .            .                   .                  .                .                   .               .               .                 // Capacity:
         .            .            .                   .                  .                .                   .               .               .                 ///  Returns the number of characters in the string, not including any
         .            .            .                   .                  .                .                   .               .               .                 ///  null-termination.
         .            .            .                   .                  .                .                   .               .               .                 size_type
         .            .            .                   .                  .                .                   .               .               .                 size() const _GLIBCXX_NOEXCEPT
39,729,418 ( 0.13%)  39 ( 0.23%)  26 ( 0.27%) 39,229,263 ( 0.59%)         2 ( 0.00%)       0             500,034 ( 0.02%)      0               0                 { return _M_string_length; }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 ///  Returns the number of characters in the string, not including any
         .            .            .                   .                  .                .                   .               .               .                 ///  null-termination.
         .            .            .                   .                  .                .                   .               .               .                 size_type
         .            .            .                   .                  .                .                   .               .               .                 length() const _GLIBCXX_NOEXCEPT
10,837,760 ( 0.03%)   9 ( 0.05%)   7 ( 0.07%)  7,337,738 ( 0.11%)         5 ( 0.00%)       0           2,000,047 ( 0.07%)      3 ( 0.00%)      1 ( 0.00%)        { return _M_string_length; }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 ///  Returns the size() of the largest possible %string.
         .            .            .                   .                  .                .                   .               .               .                 size_type
         .            .            .                   .                  .                .                   .               .               .                 max_size() const _GLIBCXX_NOEXCEPT
         .            .            .                   .                  .                .                   .               .               .                 { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Resizes the %string to the specified number of characters.
-- line 935 ----------------------------------------
-- line 951 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                  *  This function will resize the %string to the specified length.  If
         .            .            .                   .                  .                .                   .               .               .                  *  the new size is smaller than the %string's current size the %string
         .            .            .                   .                  .                .                   .               .               .                  *  is truncated, otherwise the %string is extended and new characters
         .            .            .                   .                  .                .                   .               .               .                  *  are default-constructed.  For basic types such as char, this means
         .            .            .                   .                  .                .                   .               .               .                  *  setting them to 0.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 resize(size_type __n)
 1,500,000 ( 0.00%)   0            0                   0                  0                0             500,000 ( 0.02%)      0               0                 { this->resize(__n, _CharT()); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           #if __cplusplus >= 201103L
         .            .            .                   .                  .                .                   .               .               .           #pragma GCC diagnostic push
         .            .            .                   .                  .                .                   .               .               .           #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
         .            .            .                   .                  .                .                   .               .               .                 ///  A non-binding request to reduce capacity() to size().
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 shrink_to_fit() noexcept
         .            .            .                   .                  .                .                   .               .               .                 { reserve(); }
-- line 967 ----------------------------------------
-- line 970 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  Returns the total number of characters that the %string can hold
         .            .            .                   .                  .                .                   .               .               .                  *  before needing to allocate more memory.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 size_type
         .            .            .                   .                  .                .                   .               .               .                 capacity() const _GLIBCXX_NOEXCEPT
         .            .            .                   .                  .                .                   .               .               .                 {
16,006,558 ( 0.05%)  78 ( 0.46%)  17 ( 0.18%)  5,000,431 ( 0.08%)        67 ( 0.00%)       2 ( 0.00%)          0               0               0           	return _M_is_local() ? size_type(_S_local_capacity)
         .            .            .                   .                  .                .                   .               .               .           	                     : _M_allocated_capacity;
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Attempt to preallocate enough memory for specified number of
         .            .            .                   .                  .                .                   .               .               .                  *          characters.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __res_arg  Number of characters required.
         .            .            .                   .                  .                .                   .               .               .                  *  @throw  std::length_error  If @a __res_arg exceeds @c max_size().
-- line 986 ----------------------------------------
-- line 1054 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                 reference
         .            .            .                   .                  .                .                   .               .               .                 operator[](size_type __pos)
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .                   // Allow pos == size() both in C++98 mode, as v3 extension,
         .            .            .                   .                  .                .                   .               .               .           	// and in C++11 mode.
         .            .            .                   .                  .                .                   .               .               .           	__glibcxx_assert(__pos <= size());
         .            .            .                   .                  .                .                   .               .               .                   // In pedantic mode be strict in C++98 mode.
         .            .            .                   .                  .                .                   .               .               .           	_GLIBCXX_DEBUG_PEDASSERT(__cplusplus >= 201103L || __pos < size());
        16 ( 0.00%)   0            0                   2 ( 0.00%)         0                0                   0               0               0           	return _M_data()[__pos];
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Provides access to the data contained in the %string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __n The index of the character to access.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Read-only (const) reference to the character.
         .            .            .                   .                  .                .                   .               .               .                  *  @throw  std::out_of_range  If @a n is an invalid index.
         .            .            .                   .                  .                .                   .               .               .                  *
-- line 1070 ----------------------------------------
-- line 1206 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Append a string to this string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __str  The string to append.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Reference to this string.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string&
         .            .            .                   .                  .                .                   .               .               .                 append(const basic_string& __str)
        32 ( 0.00%)   1 ( 0.01%)   1 ( 0.01%)         16 ( 0.00%)         0                0                   8 ( 0.00%)      0               0                 { return _M_append(__str._M_data(), __str.size()); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Append a substring.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __str  The string to append.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __pos  Index of the first character of str to append.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __n  The number of characters to append.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Reference to this string.
         .            .            .                   .                  .                .                   .               .               .                  *  @throw  std::out_of_range if @a __pos is not a valid index.
-- line 1222 ----------------------------------------
-- line 1238 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                  *  @param __n  The number of characters to append.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Reference to this string.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string&
         .            .            .                   .                  .                .                   .               .               .                 append(const _CharT* __s, size_type __n)
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	__glibcxx_requires_string_len(__s, __n);
         .            .            .                   .                  .                .                   .               .               .           	_M_check_length(size_type(0), __n, "basic_string::append");
        24 ( 0.00%)   3 ( 0.02%)   1 ( 0.01%)          0                  0                0                   6 ( 0.00%)      0               0           	return _M_append(__s, __n);
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Append a C string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __s  The C string to append.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Reference to this string.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string&
         .            .            .                   .                  .                .                   .               .               .                 append(const _CharT* __s)
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	__glibcxx_requires_string(__s);
         .            .            .                   .                  .                .                   .               .               .           	const size_type __n = traits_type::length(__s);
         .            .            .                   .                  .                .                   .               .               .           	_M_check_length(size_type(0), __n, "basic_string::append");
     1,938 ( 0.00%)   0            0                   0                  0                0                   0               0               0           	return _M_append(__s, __n);
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Append multiple characters.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __n  The number of characters to append.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __c  The character to use.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Reference to this string.
         .            .            .                   .                  .                .                   .               .               .                  *
-- line 1268 ----------------------------------------
-- line 1336 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Append a single character.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __c  Character to append.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 void
         .            .            .                   .                  .                .                   .               .               .                 push_back(_CharT __c)
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	const size_type __size = this->size();
       120 ( 0.00%)   0            0                   0                  0                0                   0               0               0           	if (__size + 1 > this->capacity())
         .            .            .                   .                  .                .                   .               .               .           	  this->_M_mutate(__size, size_type(0), 0, size_type(1));
         .            .            .                   .                  .                .                   .               .               .           	traits_type::assign(this->_M_data()[__size], __c);
         .            .            .                   .                  .                .                   .               .               .           	this->_M_set_length(__size + 1);
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Set value to contents of another string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __str  Source string to use.
-- line 1352 ----------------------------------------
-- line 1379 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .           		    _M_data(__ptr);
         .            .            .                   .                  .                .                   .               .               .           		    _M_capacity(__len);
         .            .            .                   .                  .                .                   .               .               .           		    _M_set_length(__len);
         .            .            .                   .                  .                .                   .               .               .           		  }
         .            .            .                   .                  .                .                   .               .               .           	      }
         .            .            .                   .                  .                .                   .               .               .           	    std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
         .            .            .                   .                  .                .                   .               .               .           	  }
         .            .            .                   .                  .                .                   .               .               .           #endif
       115 ( 0.00%)   4 ( 0.02%)   3 ( 0.03%)         22 ( 0.00%)         0                0                  51 ( 0.00%)      0               0           	this->_M_assign(__str);
         .            .            .                   .                  .                .                   .               .               .           	return *this;
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           #if __cplusplus >= 201103L
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Set value to contents of another string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param  __str  Source string to use.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Reference to this string.
-- line 1395 ----------------------------------------
-- line 1451 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                  *  This function sets the value of this string to the value of @a __s.
         .            .            .                   .                  .                .                   .               .               .                  *  The data is copied, so there is no dependence on @a __s once the
         .            .            .                   .                  .                .                   .               .               .                  *  function returns.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string&
         .            .            .                   .                  .                .                   .               .               .                 assign(const _CharT* __s)
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	__glibcxx_requires_string(__s);
        50 ( 0.00%)   1 ( 0.01%)   1 ( 0.01%)          8 ( 0.00%)         0                0                   9 ( 0.00%)      0               0           	return _M_replace(size_type(0), this->size(), __s,
         6 ( 0.00%)   0            0                   0                  0                0                   0               0               0           			  traits_type::length(__s));
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Set value to multiple characters.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __n  Length of the resulting string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __c  The character to use.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Reference to this string.
         .            .            .                   .                  .                .                   .               .               .                  *
         .            .            .                   .                  .                .                   .               .               .                  *  This function sets the value of this string to @a __n copies of
         .            .            .                   .                  .                .                   .               .               .                  *  character @a __c.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 basic_string&
         .            .            .                   .                  .                .                   .               .               .                 assign(size_type __n, _CharT __c)
        31 ( 0.00%)   2 ( 0.01%)   2 ( 0.02%)          5 ( 0.00%)         0                0                   4 ( 0.00%)      0               0                 { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Set value to a range of characters.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __first  Iterator referencing the first character to append.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __last  Iterator marking the end of the range.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Reference to this string.
         .            .            .                   .                  .                .                   .               .               .                  *
         .            .            .                   .                  .                .                   .               .               .                  *  Sets value of string to characters in the range [__first,__last).
-- line 1482 ----------------------------------------
-- line 1862 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                  *  The value of the string doesn't change if an error is thrown.
         .            .            .                   .                  .                .                   .               .               .                 */
         .            .            .                   .                  .                .                   .               .               .                 iterator
         .            .            .                   .                  .                .                   .               .               .                 erase(__const_iterator __first, __const_iterator __last)
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	_GLIBCXX_DEBUG_PEDASSERT(__first >= begin() && __first <= __last
         .            .            .                   .                  .                .                   .               .               .           				 && __last <= end());
         .            .            .                   .                  .                .                   .               .               .                   const size_type __pos = __first - begin();
        84 ( 0.00%)   0            0                   0                  0                0                   0               0               0           	if (__last == end())
         .            .            .                   .                  .                .                   .               .               .           	  this->_M_set_length(__pos);
         .            .            .                   .                  .                .                   .               .               .           	else
         .            .            .                   .                  .                .                   .               .               .           	  this->_M_erase(__pos, __last - __first);
         .            .            .                   .                  .                .                   .               .               .           	return iterator(this->_M_data() + __pos);
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           #if __cplusplus >= 201103L
         .            .            .                   .                  .                .                   .               .               .                 /**
-- line 1878 ----------------------------------------
-- line 1952 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                  *  thrown.  The value of the string doesn't change if an error
         .            .            .                   .                  .                .                   .               .               .                  *  is thrown.
         .            .            .                   .                  .                .                   .               .               .                 */
         .            .            .                   .                  .                .                   .               .               .                 basic_string&
         .            .            .                   .                  .                .                   .               .               .                 replace(size_type __pos, size_type __n1, const _CharT* __s,
         .            .            .                   .                  .                .                   .               .               .           	      size_type __n2)
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	__glibcxx_requires_string_len(__s, __n2);
       136 ( 0.00%)  10 ( 0.06%)   5 ( 0.05%)          2 ( 0.00%)         1 ( 0.00%)       0                  23 ( 0.00%)      0               0           	return _M_replace(_M_check(__pos, "basic_string::replace"),
         1 ( 0.00%)   0            0                   0                  0                0                   0               0               0           			  _M_limit(__pos, __n1), __s, __n2);
         .            .            .                   .                  .                .                   .               .               .                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Replace characters with value of a C string.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __pos  Index of first character to replace.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __n1  Number of characters to be replaced.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __s  C string to insert.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Reference to this string.
-- line 1969 ----------------------------------------
-- line 2865 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                  *  string is ordered after @a __str.  Determines the effective
         .            .            .                   .                  .                .                   .               .               .                  *  length rlen of the strings to compare as the smallest of
         .            .            .                   .                  .                .                   .               .               .                  *  size() and str.size().  The function then compares the two
         .            .            .                   .                  .                .                   .               .               .                  *  strings by calling traits::compare(data(), str.data(),rlen).
         .            .            .                   .                  .                .                   .               .               .                  *  If the result of the comparison is nonzero returns it,
         .            .            .                   .                  .                .                   .               .               .                  *  otherwise the shorter one is ordered first.
         .            .            .                   .                  .                .                   .               .               .                 */
         .            .            .                   .                  .                .                   .               .               .                 int
        90 ( 0.00%)   1 ( 0.01%)   1 ( 0.01%)          0                  0                0                  20 ( 0.00%)      0               0                 compare(const basic_string& __str) const
         .            .            .                   .                  .                .                   .               .               .                 {
         .            .            .                   .                  .                .                   .               .               .           	const size_type __size = this->size();
         .            .            .                   .                  .                .                   .               .               .           	const size_type __osize = __str.size();
         .            .            .                   .                  .                .                   .               .               .           	const size_type __len = std::min(__size, __osize);
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           	int __r = traits_type::compare(_M_data(), __str.data(), __len);
        49 ( 0.00%)   0            0                   3 ( 0.00%)         0                0                   0               0               0           	if (!__r)
         .            .            .                   .                  .                .                   .               .               .           	  __r = _S_compare(__size, __osize);
         .            .            .                   .                  .                .                   .               .               .           	return __r;
        40 ( 0.00%)   1 ( 0.01%)   1 ( 0.01%)         30 ( 0.00%)         0                0                   0               0               0                 }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           #if __cplusplus >= 201703L
         .            .            .                   .                  .                .                   .               .               .                 /**
         .            .            .                   .                  .                .                   .               .               .                  *  @brief  Compare to a string_view.
         .            .            .                   .                  .                .                   .               .               .                  *  @param __svt An object convertible to string_view to compare against.
         .            .            .                   .                  .                .                   .               .               .                  *  @return  Integer < 0, 0, or > 0.
         .            .            .                   .                  .                .                   .               .               .                  */
         .            .            .                   .                  .                .                   .               .               .                 template<typename _Tp>
-- line 2891 ----------------------------------------
-- line 6177 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .                 bool __use_rhs = false;
         .            .            .                   .                  .                .                   .               .               .                 if _GLIBCXX17_CONSTEXPR (typename _Alloc_traits::is_always_equal{})
         .            .            .                   .                  .                .                   .               .               .           	__use_rhs = true;
         .            .            .                   .                  .                .                   .               .               .                 else if (__lhs.get_allocator() == __rhs.get_allocator())
         .            .            .                   .                  .                .                   .               .               .           	__use_rhs = true;
         .            .            .                   .                  .                .                   .               .               .                 if (__use_rhs)
         .            .            .                   .                  .                .                   .               .               .           #endif
         .            .            .                   .                  .                .                   .               .               .           	{
 1,000,000 ( 0.00%)   0            0                   0                  0                0             500,000 ( 0.02%)      0               0           	  const auto __size = __lhs.size() + __rhs.size();
 2,500,000 ( 0.01%)   0            0             500,000 ( 0.01%)         0                0                   0               0               0           	  if (__size > __lhs.capacity() && __size <= __rhs.capacity())
         .            .            .                   .                  .                .                   .               .               .           	    return std::move(__rhs.insert(0, __lhs));
         .            .            .                   .                  .                .                   .               .               .           	}
         .            .            .                   .                  .                .                   .               .               .                 return std::move(__lhs.append(__rhs));
         .            .            .                   .                  .                .                   .               .               .               }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             template<typename _CharT, typename _Traits, typename _Alloc>
         .            .            .                   .                  .                .                   .               .               .               inline basic_string<_CharT, _Traits, _Alloc>
         .            .            .                   .                  .                .                   .               .               .               operator+(const _CharT* __lhs,
-- line 6194 ----------------------------------------
-- line 6204 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .             template<typename _CharT, typename _Traits, typename _Alloc>
         .            .            .                   .                  .                .                   .               .               .               inline basic_string<_CharT, _Traits, _Alloc>
         .            .            .                   .                  .                .                   .               .               .               operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
         .            .            .                   .                  .                .                   .               .               .           	      const _CharT* __rhs)
         .            .            .                   .                  .                .                   .               .               .               { return std::move(__lhs.append(__rhs)); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             template<typename _CharT, typename _Traits, typename _Alloc>
         .            .            .                   .                  .                .                   .               .               .               inline basic_string<_CharT, _Traits, _Alloc>
         8 ( 0.00%)   1 ( 0.01%)   1 ( 0.01%)          0                  0                0                   6 ( 0.00%)      0               0               operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
         .            .            .                   .                  .                .                   .               .               .           	      _CharT __rhs)
         9 ( 0.00%)   0            0                   7 ( 0.00%)         0                0                   0               0               0               { return std::move(__lhs.append(1, __rhs)); }
         .            .            .                   .                  .                .                   .               .               .           #endif
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             // operator ==
         .            .            .                   .                  .                .                   .               .               .             /**
         .            .            .                   .                  .                .                   .               .               .              *  @brief  Test equivalence of two strings.
         .            .            .                   .                  .                .                   .               .               .              *  @param __lhs  First string.
         .            .            .                   .                  .                .                   .               .               .              *  @param __rhs  Second string.
         .            .            .                   .                  .                .                   .               .               .              *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
-- line 6222 ----------------------------------------
-- line 6226 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .               operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .            .            .                   .                  .                .                   .               .               .           	       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
         .            .            .                   .                  .                .                   .               .               .               _GLIBCXX_NOEXCEPT
         .            .            .                   .                  .                .                   .               .               .               { return __lhs.compare(__rhs) == 0; }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             template<typename _CharT>
         .            .            .                   .                  .                .                   .               .               .               inline
         .            .            .                   .                  .                .                   .               .               .               typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
        49 ( 0.00%)   7 ( 0.04%)   1 ( 0.01%)          0                  0                0                   0               0               0               operator==(const basic_string<_CharT>& __lhs,
         .            .            .                   .                  .                .                   .               .               .           	       const basic_string<_CharT>& __rhs) _GLIBCXX_NOEXCEPT
         .            .            .                   .                  .                .                   .               .               .               { return (__lhs.size() == __rhs.size()
       255 ( 0.00%)   2 ( 0.01%)   2 ( 0.02%)         94 ( 0.00%)         0                0                   0               0               0           	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
        49 ( 0.00%)   0            0                  42 ( 0.00%)         0                0                   0               0               0           						    __lhs.size())); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             /**
         .            .            .                   .                  .                .                   .               .               .              *  @brief  Test equivalence of string and C string.
         .            .            .                   .                  .                .                   .               .               .              *  @param __lhs  String.
         .            .            .                   .                  .                .                   .               .               .              *  @param __rhs  C string.
         .            .            .                   .                  .                .                   .               .               .              *  @return  True if @a __lhs.compare(@a __rhs) == 0.  False otherwise.
         .            .            .                   .                  .                .                   .               .               .              */
         .            .            .                   .                  .                .                   .               .               .             template<typename _CharT, typename _Traits, typename _Alloc>
         .            .            .                   .                  .                .                   .               .               .               inline bool
         .            .            .                   .                  .                .                   .               .               .               operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .            .            .                   .                  .                .                   .               .               .           	       const _CharT* __rhs)
       215 ( 0.00%)   5 ( 0.03%)   3 ( 0.03%)          0                  0                0                  49 ( 0.00%)      0               0               { return __lhs.compare(__rhs) == 0; }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .           #if __cpp_lib_three_way_comparison
         .            .            .                   .                  .                .                   .               .               .             /**
         .            .            .                   .                  .                .                   .               .               .              *  @brief  Three-way comparison of a string and a C string.
         .            .            .                   .                  .                .                   .               .               .              *  @param __lhs  A string.
         .            .            .                   .                  .                .                   .               .               .              *  @param __rhs  A null-terminated string.
         .            .            .                   .                  .                .                   .               .               .              *  @return  A value indicating whether `__lhs` is less than, equal to,
         .            .            .                   .                  .                .                   .               .               .              *	       greater than, or incomparable with `__rhs`.
         .            .            .                   .                  .                .                   .               .               .              */
         .            .            .                   .                  .                .                   .               .               .             template<typename _CharT, typename _Traits, typename _Alloc>
         .            .            .                   .                  .                .                   .               .               .               inline auto
         .            .            .                   .                  .                .                   .               .               .               operator<=>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
         .            .            .                   .                  .                .                   .               .               .           		const basic_string<_CharT, _Traits, _Alloc>& __rhs) noexcept
         .            .            .                   .                  .                .                   .               .               .               -> decltype(__detail::__char_traits_cmp_cat<_Traits>(0))
        50 ( 0.00%)   1 ( 0.01%)   1 ( 0.01%)         40 ( 0.00%)         0                0                  10 ( 0.00%)      0               0               { return __detail::__char_traits_cmp_cat<_Traits>(__lhs.compare(__rhs)); }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             /**
         .            .            .                   .                  .                .                   .               .               .              *  @brief  Three-way comparison of a string and a C string.
         .            .            .                   .                  .                .                   .               .               .              *  @param __lhs  A string.
         .            .            .                   .                  .                .                   .               .               .              *  @param __rhs  A null-terminated string.
         .            .            .                   .                  .                .                   .               .               .              *  @return  A value indicating whether `__lhs` is less than, equal to,
         .            .            .                   .                  .                .                   .               .               .              *	       greater than, or incomparable with `__rhs`.
         .            .            .                   .                  .                .                   .               .               .              */
-- line 6273 ----------------------------------------
-- line 6528 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .              */
         .            .            .                   .                  .                .                   .               .               .             template<typename _CharT, typename _Traits, typename _Alloc>
         .            .            .                   .                  .                .                   .               .               .               inline basic_ostream<_CharT, _Traits>&
         .            .            .                   .                  .                .                   .               .               .               operator<<(basic_ostream<_CharT, _Traits>& __os,
         .            .            .                   .                  .                .                   .               .               .           	       const basic_string<_CharT, _Traits, _Alloc>& __str)
         .            .            .                   .                  .                .                   .               .               .               {
         .            .            .                   .                  .                .                   .               .               .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .            .            .                   .                  .                .                   .               .               .                 // 586. string inserter not a formatted function
       150 ( 0.00%)   7 ( 0.04%)   3 ( 0.03%)         60 ( 0.00%)         1 ( 0.00%)       0                  37 ( 0.00%)      0               0                 return __ostream_insert(__os, __str.data(), __str.size());
         .            .            .                   .                  .                .                   .               .               .               }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             /**
         .            .            .                   .                  .                .                   .               .               .              *  @brief  Read a line from stream into a string.
         .            .            .                   .                  .                .                   .               .               .              *  @param __is  Input stream.
         .            .            .                   .                  .                .                   .               .               .              *  @param __str  Buffer to store into.
         .            .            .                   .                  .                .                   .               .               .              *  @param __delim  Character marking end of line.
         .            .            .                   .                  .                .                   .               .               .              *  @return  Reference to the input stream.
-- line 6544 ----------------------------------------
-- line 6653 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .             stold(const string& __str, size_t* __idx = 0)
         .            .            .                   .                  .                .                   .               .               .             { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }
         .            .            .                   .                  .                .                   .               .               .           #endif // _GLIBCXX_USE_C99_STDLIB
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             // DR 1261. Insufficent overloads for to_string / to_wstring
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             inline string
         .            .            .                   .                  .                .                   .               .               .             to_string(int __val)
        14 ( 0.00%)   2 ( 0.01%)   2 ( 0.02%)          0                  0                0                  10 ( 0.00%)      0               0             {
         4 ( 0.00%)   0            0                   0                  0                0                   0               0               0               const bool __neg = __val < 0;
         6 ( 0.00%)   0            0                   0                  0                0                   0               0               0               const unsigned __uval = __neg ? (unsigned)~__val + 1u : __val;
         .            .            .                   .                  .                .                   .               .               .               const auto __len = __detail::__to_chars_len(__uval);
         2 ( 0.00%)   0            0                   0                  0                0                   0               0               0               string __str(__neg + __len, '-');
         2 ( 0.00%)   0            0                   0                  0                0                   0               0               0               __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
         .            .            .                   .                  .                .                   .               .               .               return __str;
        16 ( 0.00%)   0            0                  12 ( 0.00%)         0                0                   2 ( 0.00%)      0               0             }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             inline string
         .            .            .                   .                  .                .                   .               .               .             to_string(unsigned __val)
         .            .            .                   .                  .                .                   .               .               .             {
         .            .            .                   .                  .                .                   .               .               .               string __str(__detail::__to_chars_len(__val), '\0');
         .            .            .                   .                  .                .                   .               .               .               __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
         .            .            .                   .                  .                .                   .               .               .               return __str;
         .            .            .                   .                  .                .                   .               .               .             }
-- line 6676 ----------------------------------------
-- line 6684 ----------------------------------------
         .            .            .                   .                  .                .                   .               .               .               string __str(__neg + __len, '-');
         .            .            .                   .                  .                .                   .               .               .               __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
         .            .            .                   .                  .                .                   .               .               .               return __str;
         .            .            .                   .                  .                .                   .               .               .             }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             inline string
         .            .            .                   .                  .                .                   .               .               .             to_string(unsigned long __val)
         .            .            .                   .                  .                .                   .               .               .             {
   490,000 ( 0.00%)   1 ( 0.01%)   1 ( 0.01%)          0                  0                0                   0               0               0               string __str(__detail::__to_chars_len(__val), '\0');
         .            .            .                   .                  .                .                   .               .               .               __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
         .            .            .                   .                  .                .                   .               .               .               return __str;
         .            .            .                   .                  .                .                   .               .               .             }
         .            .            .                   .                  .                .                   .               .               .           
         .            .            .                   .                  .                .                   .               .               .             inline string
         .            .            .                   .                  .                .                   .               .               .             to_string(long long __val)
         .            .            .                   .                  .                .                   .               .               .             {
         .            .            .                   .                  .                .                   .               .               .               const bool __neg = __val < 0;
-- line 6700 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/mriccobene/CLionProjects/silkworm/silkworm/node/recsplit/rec_split.hpp
--------------------------------------------------------------------------------
Ir                     I1mr        ILmr        Dr                   D1mr             DLmr         Dw                 D1mw             DLmw         

-- line 105 ----------------------------------------
            .           .           .                    .                .            .                  .                .            .               0x082f20e10092a9a3, 0x2ada2ce68d21defc, 0xe33cb4f3e7c6466b, 0x3980be458c509c59, 0xc466fd9584828e8c, 0x45f0aabe1a61ede6, 0xf6e7b8b33ad9b98d,
            .           .           .                    .                .            .                  .                .            .               0x4ef95e25f4b4983d, 0x81175195173b92d3, 0x4e50927d8dd15978, 0x1ea2099d1fafae7f, 0x425c8a06fbaaa815, 0xcd4216006c74052a};
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .           //! David Stafford's (http://zimbry.blogspot.com/2011/09/better-bit-mixingsuccinct::-improving-on.html)
            .           .           .                    .                .            .                  .                .            .           //! 13th variant of the 64-bit finalizer function in Austin Appleby's MurmurHash3 (https://github.com/aappleby/smhasher)
            .           .           .                    .                .            .                  .                .            .           //! @param z a 64-bit integer
            .           .           .                    .                .            .                  .                .            .           //! @return a 64-bit integer obtained by mixing the bits of `z`
            .           .           .                    .                .            .                  .                .            .           uint64_t inline remix(uint64_t z) {
1,344,732,851 ( 4.33%)  2 ( 0.01%)  2 ( 0.02%)      62,575 ( 0.00%)       0            0                  0                0            0               z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
1,347,912,307 ( 4.34%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  0                0            0               z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
1,008,369,810 ( 3.25%)  2 ( 0.01%)  2 ( 0.02%)           0                0            0                  0                0            0               return z ^ (z >> 31);
            .           .           .                    .                .            .                  .                .            .           }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .           //! 128-bit hash used in the construction of RecSplit (first of all keys are hashed using MurmurHash3)
            .           .           .                    .                .            .                  .                .            .           //! Moreover, it is possible to build and query RecSplit instances using 128-bit random hashes (mainly for test purposes)
            .           .           .                    .                .            .                  .                .            .           struct hash128_t {
            .           .           .                    .                .            .                  .                .            .               uint64_t first;   // The high 64-bit hash half
            .           .           .                    .                .            .                  .                .            .               uint64_t second;  // The low 64-bit hash half
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               bool operator<(const hash128_t& o) const { return first < o.first || second < o.second; }
            .           .           .                    .                .            .                  .                .            .           };
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .           // Quick replacements for min/max on not-so-large integers
            .           .           .                    .                .            .                  .                .            .           static constexpr inline uint64_t min(int64_t x, int64_t y) { return static_cast<uint64_t>(y + ((x - y) & ((x - y) >> 63))); }
            8 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  0                0            0           static constexpr inline uint64_t max(int64_t x, int64_t y) { return static_cast<uint64_t>(x - ((x - y) & ((x - y) >> 63))); }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .           // Optimal Golomb-Rice parameters for leaves
            .           .           .                    .                .            .                  .                .            .           static constexpr uint8_t bij_memo[] = {0, 0, 0, 1, 3, 4, 5, 7, 8, 10, 11, 12, 14, 15, 16, 18, 19, 21, 22, 23, 25, 26, 28, 29, 30};
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .           //! The splitting strategy of Recsplit algorithm is embedded into the generation code, which uses only the public fields
            .           .           .                    .                .            .                  .                .            .           //! SplittingStrategy::lower_aggr and SplittingStrategy::upper_aggr.
            .           .           .                    .                .            .                  .                .            .           template <std::size_t LEAF_SIZE>
            .           .           .                    .                .            .                  .                .            .           class SplittingStrategy {
-- line 137 ----------------------------------------
-- line 141 ----------------------------------------
            .           .           .                    .                .            .                  .                .            .               //! The lower bound for primary (lower) key aggregation
            .           .           .                    .                .            .                  .                .            .               static inline const std::size_t kLowerAggregationBound = LEAF_SIZE * max(2, ceil(0.35 * LEAF_SIZE + 1. / 2));
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               //! The lower bound for secondary (upper) key aggregation
            .           .           .                    .                .            .                  .                .            .               static inline const std::size_t kUpperAggregationBound = kLowerAggregationBound * (LEAF_SIZE < 7 ? 2 : ceil(0.21 * LEAF_SIZE + 9. / 10));
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               static inline std::pair<std::size_t, std::size_t> split_params(const std::size_t m) {
            .           .           .                    .                .            .                  .                .            .                   std::size_t fanout{0}, unit{0};
       65,725 ( 0.00%)  0           0                    0                0            0                  0                0            0                   if (m > kUpperAggregationBound) {  // High-level aggregation (fanout 2)
       97,956 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  0                0            0                       unit = kUpperAggregationBound * (uint16_t((m + 1) / 2 + kUpperAggregationBound - 1) / kUpperAggregationBound);
       10,884 ( 0.00%)  0           0                    0                0            0              5,078 ( 0.00%)       0            0                       fanout = 2;
       42,242 ( 0.00%)  3 ( 0.02%)  3 ( 0.03%)           0                0            0                  0                0            0                   } else if (m > kLowerAggregationBound) {  // Second-level aggregation
        5,386 ( 0.00%)  0           0                    0                0            0                  0                0            0                       unit = kLowerAggregationBound;
       21,416 ( 0.00%)  0           0                    0                0            0              5,258 ( 0.00%)       0            0                       fanout = uint16_t(m + kLowerAggregationBound - 1) / kLowerAggregationBound;
            .           .           .                    .                .            .                  .                .            .                   } else {  // First-level aggregation
       15,735 ( 0.00%)  0           0                    0                0            0                  0                0            0                       unit = LEAF_SIZE;
       78,579 ( 0.00%)  4 ( 0.02%)  4 ( 0.04%)           0                0            0             15,687 ( 0.00%)       0            0                       fanout = uint16_t(m + LEAF_SIZE - 1) / LEAF_SIZE;
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .                   return {fanout, unit};
            .           .           .                    .                .            .                  .                .            .               }
            .           .           .                    .                .            .                  .                .            .           };
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .           //! Size in bytes of 1st fixed metadata header fields in RecSplit-encoded file
            .           .           .                    .                .            .                  .                .            .           static constexpr std::size_t kBaseDataIdLength{sizeof(uint64_t)};
            .           .           .                    .                .            .                  .                .            .           static constexpr std::size_t kKeyCountLength{sizeof(uint64_t)};
-- line 165 ----------------------------------------
-- line 195 ----------------------------------------
            .           .           .                    .                .            .                  .                .            .               std::size_t etl_optimal_size{etl::kOptimalBufferSize};  // Optimal size for offset and bucket ETL collectors
            .           .           .                    .                .            .                  .                .            .           };
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .           //! Recursive splitting (RecSplit) is an efficient algorithm to identify minimal perfect hash functions.
            .           .           .                    .                .            .                  .                .            .           //! The template parameter LEAF_SIZE decides how large a leaf will be. Larger leaves imply slower construction, but less
            .           .           .                    .                .            .                  .                .            .           //! space and faster evaluation
            .           .           .                    .                .            .                  .                .            .           //! @tparam LEAF_SIZE the size of a leaf, typical value range from 6 to 8 for fast small maps or up to 16 for very compact functions
            .           .           .                    .                .            .                  .                .            .           template <std::size_t LEAF_SIZE>
           16 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           2 ( 0.00%)       1 ( 0.00%)   0                  6 ( 0.00%)       0            0           class RecSplit {
            .           .           .                    .                .            .                  .                .            .             public:
            .           .           .                    .                .            .                  .                .            .               using SplitStrategy = SplittingStrategy<LEAF_SIZE>;
            .           .           .                    .                .            .                  .                .            .               using GolombRiceBuilder = typename GolombRiceVector::Builder;
            .           .           .                    .                .            .                  .                .            .               using EliasFano = EliasFanoList32;
            .           .           .                    .                .            .                  .                .            .               using DoubleEliasFano = DoubleEliasFanoList16;
            .           .           .                    .                .            .                  .                .            .           
           18 ( 0.00%)  3 ( 0.02%)  3 ( 0.03%)           3 ( 0.00%)       2 ( 0.00%)   0                  7 ( 0.00%)       0            0               explicit RecSplit(const RecSplitSettings& settings, uint32_t salt = 0)
            3 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   : bucket_size_(settings.bucket_size),
            3 ( 0.00%)  0           0                    0                0            0                  0                0            0                     key_count_(settings.keys_count),
            5 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                     bucket_count_((key_count_ + bucket_size_ - 1) / bucket_size_),
            2 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                     base_data_id_(settings.base_data_id),
            .           .           .                    .                .            .                  .                .            .                     index_path_(settings.index_path),
            2 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                     double_enum_index_(settings.double_enum_index),
            3 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                     offset_collector_(settings.etl_optimal_size),
           18 ( 0.00%)  3 ( 0.02%)  3 ( 0.03%)           1 ( 0.00%)       0            0                  9 ( 0.00%)       4 ( 0.00%)   0                     bucket_collector_(settings.etl_optimal_size) {
            4 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   bucket_size_accumulator_.reserve(bucket_count_ + 1);
            4 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   bucket_position_accumulator_.reserve(bucket_count_ + 1);
            .           .           .                    .                .            .                  .                .            .                   bucket_size_accumulator_.resize(1);      // Start with 0 as bucket accumulated size
            .           .           .                    .                .            .                  .                .            .                   bucket_position_accumulator_.resize(1);  // Start with 0 as bucket accumulated position
            3 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   current_bucket_.reserve(bucket_size_);
            3 ( 0.00%)  0           0                    2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   current_bucket_offsets_.reserve(bucket_size_);
            4 ( 0.00%)  0           0                    1 ( 0.00%)       1 ( 0.00%)   0                  1 ( 0.00%)       0            0                   count_.reserve(kLowerAggregationBound);
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Generate random salt for murmur3 hash
            .           .           .                    .                .            .                  .                .            .                   std::random_device rand_dev;
            1 ( 0.00%)  0           0                    0                0            0                  0                0            0                   std::mt19937 rand_gen32{rand_dev()};
            5 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   salt_ = salt != 0 ? salt : rand_gen32();
            .           .           .                    .                .            .                  .                .            .                   hasher_ = std::make_unique<Murmur3>(salt_);
           11 ( 0.00%)  0           0                    9 ( 0.00%)       1 ( 0.00%)   0                  0                0            0               }
            .           .           .                    .                .            .                  .                .            .           
           15 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           1 ( 0.00%)       0            0                  8 ( 0.00%)       0            0               explicit RecSplit(std::filesystem::path index_path, std::optional<MemoryMappedRegion> index_region = {})
            5 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       0            0                  2 ( 0.00%)       0            0                   : index_path_{index_path},
           14 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           0                0            0                  9 ( 0.00%)       2 ( 0.00%)   2 ( 0.00%)            encoded_file_{std::make_optional<MemoryMappedFile>(std::move(index_path), std::move(index_region))} {
           19 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           3 ( 0.00%)       3 ( 0.00%)   0                  3 ( 0.00%)       0            0                   SILK_DEBUG << "RecSplit encoded file path: " << encoded_file_->path();
            3 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  1 ( 0.00%)       0            0                   check_minimum_length(kFirstMetadataHeaderLength);
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   const auto address = encoded_file_->address();
            .           .           .                    .                .            .                  .                .            .           
            2 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   encoded_file_->advise_sequential();
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Read fixed metadata header fields from RecSplit-encoded file
            1 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   base_data_id_ = endian::load_big_u64(address);
            1 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       1 ( 0.00%)   0                   key_count_ = endian::load_big_u64(address + kBaseDataIdLength);
            2 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   bytes_per_record_ = address[kBaseDataIdLength + kKeyCountLength];
            5 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   record_mask_ = (uint64_t(1) << (8 * bytes_per_record_)) - 1;
            4 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "Base data ID: " << base_data_id_ << " key count: " << key_count_
            .           .           .                    .                .            .                  .                .            .                              << " bytes per record: " << bytes_per_record_ << " record mask: " << record_mask_;
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Compute offset for variable metadata header fields
            2 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           2 ( 0.00%)       0            0                  0                0            0                   uint64_t offset = kFirstMetadataHeaderLength + key_count_ * bytes_per_record_;
            5 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  2 ( 0.00%)       0            0                   check_minimum_length(offset + kSecondMetadataHeaderLength);
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Read offset-based metadata fields
            1 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   bucket_count_ = endian::load_big_u64(address + offset);
            .           .           .                    .                .            .                  .                .            .                   offset += kBucketCountLength;
            2 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   bucket_size_ = endian::load_big_u16(address + offset);
            .           .           .                    .                .            .                  .                .            .                   offset += kBucketSizeLength;
            .           .           .                    .                .            .                  .                .            .                   const uint16_t leaf_size = endian::load_big_u16(address + offset);
            2 ( 0.00%)  0           0                    0                0            0                  0                0            0                   SILKWORM_ASSERT(leaf_size == LEAF_SIZE);
            .           .           .                    .                .            .                  .                .            .                   offset += kLeafSizeLength;
            .           .           .                    .                .            .                  .                .            .           
           10 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           4 ( 0.00%)       1 ( 0.00%)   0                  2 ( 0.00%)       0            0                   const uint16_t primary_aggr_bound = leaf_size * succinct::max(2, std::ceil(0.35 * leaf_size + 1. / 2));
            4 ( 0.00%)  0           0                    1 ( 0.00%)       1 ( 0.00%)   0                  0                0            0                   SILKWORM_ASSERT(primary_aggr_bound == kLowerAggregationBound);
           28 ( 0.00%)  3 ( 0.02%)  3 ( 0.03%)           8 ( 0.00%)       1 ( 0.00%)   0                  0                0            0                   const uint16_t secondary_aggr_bound = primary_aggr_bound * (leaf_size < 7 ? 2 : ceil(0.21 * leaf_size + 9. / 10));
            4 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  0                0            0                   SILKWORM_ASSERT(secondary_aggr_bound == kUpperAggregationBound);
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Read salt
            1 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   salt_ = endian::load_big_u32(address + offset);
            .           .           .                    .                .            .                  .                .            .                   offset += kSaltSizeLength;
            .           .           .                    .                .            .                  .                .            .                   hasher_ = std::make_unique<Murmur3>(salt_);
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Read start seed
            1 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       0            0                  0                0            0                   const uint8_t start_seed_length = (address + offset)[0];
            .           .           .                    .                .            .                  .                .            .                   offset += kStartSeedSizeLength;
            2 ( 0.00%)  0           0                    0                0            0                  0                0            0                   SILKWORM_ASSERT(start_seed_length == kStartSeed.size());
            8 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  2 ( 0.00%)       0            0                   check_minimum_length(offset + start_seed_length * sizeof(uint64_t));
            .           .           .                    .                .            .                  .                .            .                   std::array<uint64_t, kStartSeed.size()> start_seed;
           43 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   for (std::size_t i{0}; i < start_seed_length; ++i) {
           24 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                 20 ( 0.00%)       2 ( 0.00%)   0                       start_seed[i] = endian::load_big_u64(address + offset);
           43 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                       offset += sizeof(uint64_t);
            .           .           .                    .                .            .                  .                .            .                   }
            2 ( 0.00%)  0           0                    0                0            0                  0                0            0                   SILKWORM_ASSERT(start_seed == kStartSeed);
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Read double-index flag
            5 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   check_minimum_length(offset + kDoubleIndexFlagLength);
            2 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   double_enum_index_ = (address + offset)[0] != 0;
            .           .           .                    .                .            .                  .                .            .                   offset += kDoubleIndexFlagLength;
            .           .           .                    .                .            .                  .                .            .           
            1 ( 0.00%)  0           0                    0                0            0                  0                0            0                   if (double_enum_index_) {
            5 ( 0.00%)  0           0                    0                0            0                  2 ( 0.00%)       0            0                       check_minimum_length(offset + kEliasFano32CountLength + kEliasFano32ULength);
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                       // Read Elias-Fano index for offsets
            .           .           .                    .                .            .                  .                .            .                       const uint64_t count = endian::load_big_u64(address + offset);
            .           .           .                    .                .            .                  .                .            .                       offset += kEliasFano32CountLength;
            .           .           .                    .                .            .                  .                .            .                       const uint64_t u = endian::load_big_u64(address + offset);
            .           .           .                    .                .            .                  .                .            .                       offset += kEliasFano32ULength;
            5 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  2 ( 0.00%)       0            0                       std::span<uint8_t> remaining_data{address + offset, encoded_file_->length() - offset};
            .           .           .                    .                .            .                  .                .            .                       ef_offsets_ = std::make_unique<EliasFano>(count, u, remaining_data);
            1 ( 0.00%)  0           0                    0                0            0                  0                0            0                       offset += ef_offsets_->data().size() * sizeof(uint64_t);
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Read the number of Golomb-Rice code params
            5 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  2 ( 0.00%)       1 ( 0.00%)   0                   check_minimum_length(offset + kGolombParamSizeLength);
            .           .           .                    .                .            .                  .                .            .                   const uint16_t golomb_param_size = endian::load_big_u16(address + offset);
            2 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       1 ( 0.00%)   0                   golomb_param_max_index_ = golomb_param_size - 1;
            .           .           .                    .                .            .                  .                .            .                   offset += kGolombParamSizeLength;
            .           .           .                    .                .            .                  .                .            .           
            1 ( 0.00%)  0           0                    0                0            0                  0                0            0                   MemoryMappedInputStream mmis{address + offset, encoded_file_->length() - offset};
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Read Golomb-Rice codes
            .           .           .                    .                .            .                  .                .            .                   mmis >> golomb_rice_codes_;
            .           .           .                    .                .            .                  .                .            .                   offset += sizeof(uint64_t) + golomb_rice_codes_.size() * sizeof(uint64_t);
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Read double Elias-Fano code for bucket cumulative keys and bit positions
            .           .           .                    .                .            .                  .                .            .                   mmis >> double_ef_index_;
            4 ( 0.00%)  0           0                    2 ( 0.00%)       0            0                  0                0            0                   offset += 5 * sizeof(uint64_t) + double_ef_index_.data().size() * sizeof(uint64_t);
            .           .           .                    .                .            .                  .                .            .           
            2 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       1 ( 0.00%)   0                  0                0            0                   SILKWORM_ASSERT(offset == encoded_file_->length());
            .           .           .                    .                .            .                  .                .            .           
            2 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   encoded_file_->advise_random();
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Prevent any new key addition
            1 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       1 ( 0.00%)   0                   built_ = true;
           11 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           9 ( 0.00%)       2 ( 0.00%)   0                  0                0            0               }
            .           .           .                    .                .            .                  .                .            .           
    8,500,000 ( 0.03%)  2 ( 0.01%)  2 ( 0.02%)   1,500,000 ( 0.02%)       0            0          3,500,000 ( 0.13%)      11 ( 0.00%)   0               void add_key(const hash128_t& key_hash, uint64_t offset) {
    2,500,000 ( 0.01%)  0           0              500,000 ( 0.01%)       0            0            500,000 ( 0.02%)       0            0                   if (built_) {
    2,000,000 ( 0.01%)  1 ( 0.01%)  1 ( 0.01%)     500,000 ( 0.01%)       0            0                  0                0            0                       throw std::logic_error{"cannot add key after perfect hash function has been built"};
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .           
    2,500,000 ( 0.01%)  0           0                    0                0            0                  0                0            0                   if (keys_added_ % 100'000 == 0) {
           25 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  5 ( 0.00%)       0            0                       SILK_DEBUG << "[index] add key hash: first=" << key_hash.first << " second=" << key_hash.second << " offset=" << offset;
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   Bytes bucket_key(16, '\0');
            .           .           .                    .                .            .                  .                .            .                   endian::store_big_u64(bucket_key.data(), hash128_to_bucket(key_hash));
            .           .           .                    .                .            .                  .                .            .                   endian::store_big_u64(bucket_key.data() + sizeof(uint64_t), key_hash.second);
            .           .           .                    .                .            .                  .                .            .                   Bytes offset_key(8, '\0');
            .           .           .                    .                .            .                  .                .            .                   endian::store_big_u64(offset_key.data(), offset);
            .           .           .                    .                .            .                  .                .            .           
    1,000,000 ( 0.00%)  0           0              500,000 ( 0.01%)      22 ( 0.00%)   2 ( 0.00%)         0                0            0                   if (offset > max_offset_) {
      499,999 ( 0.00%)  0           0                    0                0            0            499,999 ( 0.02%)       0            0                       max_offset_ = offset;
            .           .           .                    .                .            .                  .                .            .                   }
    1,500,000 ( 0.00%)  0           0              500,000 ( 0.01%)       0            0                  0                0            0                   if (keys_added_ > 0) {
      999,998 ( 0.00%)  0           0              499,999 ( 0.01%)       0            0                  0                0            0                       const auto delta = offset - previous_offset_;
    1,999,994 ( 0.01%)  0           0              499,998 ( 0.01%)       0            0                  0                0            0                       if (keys_added_ == 1 || delta < min_delta_) {
            1 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                           min_delta_ = delta;
            .           .           .                    .                .            .                  .                .            .                       }
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .           
    1,000,000 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)     500,000 ( 0.01%)       0            0                  0                0            0                   if (double_enum_index_) {
    2,500,000 ( 0.01%)  0           0              500,000 ( 0.01%)       0            0          1,000,000 ( 0.04%)       0            0                       offset_collector_.collect({offset_key, {}});
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                       Bytes current_key_count(8, '\0');
            .           .           .                    .                .            .                  .                .            .                       endian::store_big_u64(current_key_count.data(), keys_added_);
    2,500,000 ( 0.01%)  0           0              500,000 ( 0.01%)       0            0          1,000,000 ( 0.04%)       0            0                       bucket_collector_.collect({bucket_key, current_key_count});
            .           .           .                    .                .            .                  .                .            .                   } else {
            .           .           .                    .                .            .                  .                .            .                       bucket_collector_.collect({bucket_key, offset_key});
            .           .           .                    .                .            .                  .                .            .                   }
      500,000 ( 0.00%)  0           0              500,000 ( 0.01%)       4 ( 0.00%)   0                  0                0            0                   keys_added_++;
      500,000 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0            500,000 ( 0.02%)       0            0                   previous_offset_ = offset;
    5,500,000 ( 0.02%)  2 ( 0.01%)  1 ( 0.01%)   4,500,000 ( 0.07%)       8 ( 0.00%)   4 ( 0.00%)         0                0            0               }
            .           .           .                    .                .            .                  .                .            .           
    5,500,000 ( 0.02%)  1 ( 0.01%)  1 ( 0.01%)     500,000 ( 0.01%)       0            0          3,500,000 ( 0.13%)       0            0               void add_key(const void* key_data, const size_t key_length, uint64_t offset) {
    3,000,000 ( 0.01%)  1 ( 0.01%)  1 ( 0.01%)     500,000 ( 0.01%)     100 ( 0.00%)   1 ( 0.00%)         0                0            0                   if (built_) {
    1,500,000 ( 0.00%)  0           0              500,000 ( 0.01%)       6 ( 0.00%)   0                  0                0            0                       throw std::logic_error{"cannot add key after perfect hash function has been built"};
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .           
    1,500,000 ( 0.00%)  0           0                    0                0            0                  0                0            0                   if (keys_added_ % 100'000 == 0) {
           20 ( 0.00%)  0           0                    0                0            0                  5 ( 0.00%)       0            0                       SILK_DEBUG << "[index] add key: " << to_hex(ByteView{reinterpret_cast<const uint8_t*>(key_data), key_length});
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   const auto key_hash = murmur_hash_3(key_data, key_length);
    2,000,000 ( 0.01%)  0           0                    0                0            0            500,000 ( 0.02%)       0            0                   add_key(key_hash, offset);
    5,500,000 ( 0.02%)  1 ( 0.01%)  1 ( 0.01%)   4,500,000 ( 0.07%)       8 ( 0.00%)   4 ( 0.00%)         0                0            0               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               void add_key(const std::string& key, uint64_t offset) {
            .           .           .                    .                .            .                  .                .            .                   add_key(key.c_str(), key.size(), offset);
            .           .           .                    .                .            .                  .                .            .               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               //! Build the MPHF using the RecSplit algorithm and save the resulting index file
            .           .           .                    .                .            .                  .                .            .               //! \warning duplicate keys will cause this method to never return
           12 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           1 ( 0.00%)       0            0                  8 ( 0.00%)       1 ( 0.00%)   1 ( 0.00%)      [[nodiscard]] bool build() {
            5 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   if (built_) {
            .           .           .                    .                .            .                  .                .            .                       throw std::logic_error{"perfect hash function already built"};
            .           .           .                    .                .            .                  .                .            .                   }
            3 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           2 ( 0.00%)       0            0                  0                0            0                   if (keys_added_ != key_count_) {
            .           .           .                    .                .            .                  .                .            .                       throw std::logic_error{"keys expected: " + std::to_string(key_count_) + " added: " + std::to_string(keys_added_)};
            .           .           .                    .                .            .                  .                .            .                   }
           11 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  5 ( 0.00%)       0            0                   const auto tmp_index_path{std::filesystem::path{index_path_}.concat(".tmp")};
            .           .           .                    .                .            .                  .                .            .                   std::ofstream index_output_stream{tmp_index_path, std::ios::binary};
           12 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           2 ( 0.00%)       1 ( 0.00%)   1 ( 0.00%)         2 ( 0.00%)       0            0                   SILK_DEBUG << "[index] creating temporary index file: " << tmp_index_path.string();
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write minimal app-specific data ID in the index file
            .           .           .                    .                .            .                  .                .            .                   Bytes uint64_buffer(8, '\0');
            .           .           .                    .                .            .                  .                .            .                   endian::store_big_u64(uint64_buffer.data(), base_data_id_);
            3 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   index_output_stream.write(reinterpret_cast<const char*>(uint64_buffer.data()), sizeof(uint64_t));
            4 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] written base data ID: " << base_data_id_;
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write number of keys
            .           .           .                    .                .            .                  .                .            .                   endian::store_big_u64(uint64_buffer.data(), keys_added_);
            4 ( 0.00%)  0           0                    2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   index_output_stream.write(reinterpret_cast<const char*>(uint64_buffer.data()), sizeof(uint64_t));
            4 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] written number of keys: " << keys_added_;
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write number of bytes per index record
            9 ( 0.00%)  0           0                    3 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   bytes_per_record_ = (std::bit_width(max_offset_) + 7) / 8;
            4 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   index_output_stream.write(reinterpret_cast<const char*>(&bytes_per_record_), sizeof(uint8_t));
            4 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] written bytes per record: " << int(bytes_per_record_);
            .           .           .                    .                .            .                  .                .            .           
            2 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   current_bucket_id_ = std::numeric_limits<uint64_t>::max();  // To make sure 0 bucket is detected
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   [[maybe_unused]] auto _ = gsl::finally([&]() { bucket_collector_.clear(); });
            4 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_TRACE << "[index] calculating file=" << index_path_.string();
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // We use an exception for collision error condition because ETL currently does not support loading errors
            .           .           .                    .                .            .                  .                .            .                   // TODO(canepat) refactor ETL to support errors in LoadFunc and propagate them to caller to get rid of CollisionError
            .           .           .                    .                .            .                  .                .            .                   struct CollisionError : public std::runtime_error {
            .           .           .                    .                .            .                  .                .            .                       explicit CollisionError(uint64_t _bucket_id) : runtime_error("collision"), bucket_id(_bucket_id) {}
            .           .           .                    .                .            .                  .                .            .                       uint64_t bucket_id;
            .           .           .                    .                .            .                  .                .            .                   };
            .           .           .                    .                .            .                  .                .            .                   try {
            .           .           .                    .                .            .                  .                .            .                       // Passing a void cursor is valid case for ETL when DB modification is not expected
            6 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           2 ( 0.00%)       0            0                  2 ( 0.00%)       0            0                       db::PooledCursor empty_cursor{};
   15,000,501 ( 0.05%)  3 ( 0.02%)  3 ( 0.03%)   6,500,245 ( 0.10%)     741 ( 0.00%)   3 ( 0.00%) 3,500,004 ( 0.13%)       1 ( 0.00%)   1 ( 0.00%)              bucket_collector_.load(empty_cursor, [&](const etl::Entry& entry, auto&, MDBX_put_flags_t) {
            .           .           .                    .                .            .                  .                .            .                           // k is the big-endian encoding of the bucket number and the v is the key that is assigned into that bucket
            .           .           .                    .                .            .                  .                .            .                           const uint64_t bucket_id = endian::load_big_u64(entry.key.data());
    2,000,000 ( 0.01%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0            500,000 ( 0.02%)       0            0                           SILK_TRACE << "[index] processing bucket_id=" << bucket_id;
    1,500,000 ( 0.00%)  0           0              500,000 ( 0.01%)       1 ( 0.00%)   1 ( 0.00%)         0                0            0                           if (current_bucket_id_ != bucket_id) {
          490 ( 0.00%)  0           0                    0                0            0                  0                0            0                               if (current_bucket_id_ != std::numeric_limits<uint64_t>::max()) {
          488 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         244 ( 0.00%)       0            0                244 ( 0.00%)       0            0                                   bool collision = recsplit_current_bucket(index_output_stream);
          488 ( 0.00%)  0           0                    0                0            0                  0                0            0                                   if (collision) throw CollisionError{bucket_id};
            .           .           .                    .                .            .                  .                .            .                               }
          245 ( 0.00%)  0           0                    0                0            0                245 ( 0.00%)       0            0                               current_bucket_id_ = bucket_id;
            .           .           .                    .                .            .                  .                .            .                           }
      500,001 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           0                0            0            500,000 ( 0.02%)     246 ( 0.01%)   1 ( 0.00%)                  current_bucket_.emplace_back(endian::load_big_u64(entry.key.data() + sizeof(uint64_t)));
      500,001 ( 0.00%)  0           0                    0                0            0            500,000 ( 0.02%)       1 ( 0.00%)   0                           current_bucket_offsets_.emplace_back(endian::load_big_u64(entry.value.data()));
            .           .           .                    .                .            .                  .                .            .                       });
            2 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       1 ( 0.00%)   1 ( 0.00%)         1 ( 0.00%)       0            0                   } catch (const CollisionError& error) {
            .           .           .                    .                .            .                  .                .            .                       SILK_WARN << "[index] collision detected for bucket=" << error.bucket_id;
            .           .           .                    .                .            .                  .                .            .                       return true;
            .           .           .                    .                .            .                  .                .            .                   }
            4 ( 0.00%)  0           0                    3 ( 0.00%)       1 ( 0.00%)   1 ( 0.00%)         0                0            0                   if (!current_bucket_.empty()) {
            3 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                       bool collision_detected = recsplit_current_bucket(index_output_stream);
            8 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           2 ( 0.00%)       1 ( 0.00%)   1 ( 0.00%)         0                0            0                       if (collision_detected) return true;
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .                   gr_builder_.append_fixed(1, 1);  // Sentinel (avoids checking for parts of size 1)
            .           .           .                    .                .            .                  .                .            .                   golomb_rice_codes_ = gr_builder_.build();
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Build Elias-Fano index for offsets (if any)
            3 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           2 ( 0.00%)       0            0                  0                0            0                   if (double_enum_index_) {
            .           .           .                    .                .            .                  .                .            .                       ef_offsets_ = std::make_unique<EliasFano>(keys_added_, max_offset_);
            4 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                       db::PooledCursor empty_cursor{};
            6 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                       offset_collector_.load(empty_cursor, [&](const etl::Entry& entry, auto&, MDBX_put_flags_t) {
            .           .           .                    .                .            .                  .                .            .                           const uint64_t offset = endian::load_big_u64(entry.key.data());
            .           .           .                    .                .            .                  .                .            .                           ef_offsets_->add_offset(offset);
            .           .           .                    .                .            .                  .                .            .                       });
            .           .           .                    .                .            .                  .                .            .                       ef_offsets_->build();
            2 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Construct double Elias-Fano index for bucket cumulative keys and bit positions
            .           .           .                    .                .            .                  .                .            .                   std::vector<uint64_t> cumulative_keys{bucket_size_accumulator_.begin(), bucket_size_accumulator_.end()};
            .           .           .                    .                .            .                  .                .            .                   std::vector<uint64_t> positions(bucket_position_accumulator_.begin(), bucket_position_accumulator_.end());
            5 ( 0.00%)  0           0                    2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   double_ef_index_.build(cumulative_keys, positions);
            .           .           .                    .                .            .                  .                .            .           
            1 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  1 ( 0.00%)       1 ( 0.00%)   0                   built_ = true;
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write out bucket count, bucket size, leaf size
            .           .           .                    .                .            .                  .                .            .                   endian::store_big_u64(uint64_buffer.data(), bucket_count_);
            4 ( 0.00%)  0           0                    2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   index_output_stream.write(reinterpret_cast<const char*>(uint64_buffer.data()), sizeof(uint64_t));
            4 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] written bucket count: " << bucket_count_;
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   endian::store_big_u16(uint64_buffer.data(), bucket_size_);
            4 ( 0.00%)  0           0                    2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   index_output_stream.write(reinterpret_cast<const char*>(uint64_buffer.data()), sizeof(uint16_t));
            4 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] written bucket size: " << bucket_size_;
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   endian::store_big_u16(uint64_buffer.data(), LEAF_SIZE);
            4 ( 0.00%)  0           0                    2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   index_output_stream.write(reinterpret_cast<const char*>(uint64_buffer.data()), sizeof(uint16_t));
            4 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] written leaf size: " << LEAF_SIZE;
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write out salt
            .           .           .                    .                .            .                  .                .            .                   endian::store_big_u32(uint64_buffer.data(), salt_);
            4 ( 0.00%)  0           0                    2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   index_output_stream.write(reinterpret_cast<const char*>(uint64_buffer.data()), sizeof(uint32_t));
            4 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] written murmur3 salt: " << salt_ << " [" << to_hex(uint64_buffer) << "]";
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write out start seeds
            1 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   constexpr uint8_t start_seed_length = kStartSeed.size();
            4 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   index_output_stream.write(reinterpret_cast<const char*>(&start_seed_length), sizeof(uint8_t));
            5 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] written start seed length: " << int(start_seed_length);
            .           .           .                    .                .            .                  .                .            .           
           40 ( 0.00%)  0           0                    0                0            0                  0                0            0                   for (const uint64_t s : kStartSeed) {
            .           .           .                    .                .            .                  .                .            .                       endian::store_big_u64(uint64_buffer.data(), s);
           80 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          40 ( 0.00%)       0            0                 20 ( 0.00%)       0            0                       index_output_stream.write(reinterpret_cast<const char*>(uint64_buffer.data()), sizeof(uint64_t));
            .           .           .                    .                .            .                  .                .            .                   }
            4 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] written start seed: first=" << kStartSeed[0] << " last=" << kStartSeed[kStartSeed.size() - 1];
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write out index flag
            3 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   const uint8_t enum_index_flag = double_enum_index_ ? 1 : 0;
            5 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   index_output_stream.write(reinterpret_cast<const char*>(&enum_index_flag), sizeof(uint8_t));
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write out Elias-Fano code for offsets (if any)
            2 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  0                0            0                   if (double_enum_index_) {
            .           .           .                    .                .            .                  .                .            .                       index_output_stream << *ef_offsets_;
            4 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  1 ( 0.00%)       0            0                       SILK_DEBUG << "[index] written EF code for offsets [size: " << ef_offsets_->count() - 1 << "]";
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write out the number of Golomb-Rice codes used i.e. the max index used plus one
            2 ( 0.00%)  0           0                    1 ( 0.00%)       1 ( 0.00%)   0                  0                0            0                   endian::store_big_u16(uint64_buffer.data(), golomb_param_max_index_ + 1);
            .           .           .                    .                .            .                  .                .            .                   // Erigon writes 4-instead-of-2 bytes here: 2 spurious come from previous buffer content, i.e. last seed value
            4 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   index_output_stream.write(reinterpret_cast<const char*>(uint64_buffer.data()), sizeof(uint32_t));
            4 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] written GR params count: " << golomb_param_max_index_ + 1 << " code size: " << golomb_rice_codes_.size();
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write out Golomb-Rice code
            .           .           .                    .                .            .                  .                .            .                   index_output_stream << golomb_rice_codes_;
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Write out Elias-Fano code for bucket cumulative keys and bit positions
            .           .           .                    .                .            .                  .                .            .                   index_output_stream << double_ef_index_;
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   index_output_stream.close();
            .           .           .                    .                .            .                  .                .            .           
            4 ( 0.00%)  0           0                    0                0            0                  1 ( 0.00%)       0            0                   SILK_DEBUG << "[index] renaming " << tmp_index_path.string() << " as " << index_path_.string();
            3 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           2 ( 0.00%)       0            0                  1 ( 0.00%)       0            0                   std::filesystem::rename(tmp_index_path, index_path_);
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   return false;
           12 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          10 ( 0.00%)       2 ( 0.00%)   2 ( 0.00%)         0                0            0               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               void reset_new_salt() {
            .           .           .                    .                .            .                  .                .            .                   built_ = false;
            .           .           .                    .                .            .                  .                .            .                   keys_added_ = 0;
            .           .           .                    .                .            .                  .                .            .                   bucket_collector_.clear();
            .           .           .                    .                .            .                  .                .            .                   offset_collector_.clear();
            .           .           .                    .                .            .                  .                .            .                   current_bucket_.clear();
            .           .           .                    .                .            .                  .                .            .                   current_bucket_offsets_.clear();
-- line 535 ----------------------------------------
-- line 634 ----------------------------------------
            .           .           .                    .                .            .                  .                .            .               uint64_t base_data_id() const { return base_data_id_; }
            .           .           .                    .                .            .                  .                .            .               uint64_t record_mask() const { return record_mask_; }
            .           .           .                    .                .            .                  .                .            .               uint64_t bucket_count() const { return bucket_count_; }
            .           .           .                    .                .            .                  .                .            .               uint16_t bucket_size() const { return bucket_size_; }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               std::size_t file_size() const { return std::filesystem::file_size(index_path_); }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               std::filesystem::file_time_type last_write_time() const {
            4 ( 0.00%)  0           0                    1 ( 0.00%)       0            0                  2 ( 0.00%)       0            0                   return std::filesystem::last_write_time(index_path_);
            .           .           .                    .                .            .                  .                .            .               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               uint8_t* memory_file_address() const { return encoded_file_ ? encoded_file_->address() : nullptr; }
            .           .           .                    .                .            .                  .                .            .               std::size_t memory_file_size() const { return encoded_file_ ? encoded_file_->length() : 0; }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .             private:
            .           .           .                    .                .            .                  .                .            .               static inline std::size_t skip_bits(std::size_t m) { return memo[m] & 0xFFFF; }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               static inline std::size_t skip_nodes(std::size_t m) { return (memo[m] >> 16) & 0x7FF; }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               static constexpr uint64_t golomb_param(const std::size_t m, const std::array<uint32_t, kMaxBucketSize>& memo) {
      265,812 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)     151,182 ( 0.00%)     747 ( 0.00%)   2 ( 0.00%)         9 ( 0.00%)       0            0                   if (m > golomb_param_max_index_) golomb_param_max_index_ = m;
      265,746 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)      88,598 ( 0.00%)   4,841 ( 0.01%)  66 ( 0.00%)         0                0            0                   return memo[m] >> 27;
            .           .           .                    .                .            .                  .                .            .               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               // Generates the precomputed table of 32-bit values holding the Golomb-Rice code
            .           .           .                    .                .            .                  .                .            .               // of a splitting (upper 5 bits), the number of nodes in the associated subtree
            .           .           .                    .                .            .                  .                .            .               // (following 11 bits) and the sum of the Golomb-Rice code lengths in the same
            .           .           .                    .                .            .                  .                .            .               // subtree (lower 16 bits).
            .           .           .                    .                .            .                  .                .            .               static constexpr void precompute_golomb_rice(const int m, std::array<uint32_t, kMaxBucketSize>* memo) {
      215,352 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           0                0            0            185,442 ( 0.01%)       0            0                   std::array<std::size_t, kMaxFanout> k{0};
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   const auto [fanout, unit] = SplittingStrategy<LEAF_SIZE>::split_params(m);
            .           .           .                    .                .            .                  .                .            .           
          400 ( 0.00%)  0           0                    0                0            0                  0                0            0                   k[fanout - 1] = m;
          544 ( 0.00%)  0           0                    0                0            0                  0                0            0                   for (std::size_t i{0}; i < fanout - 1; ++i) {
          128 ( 0.00%)  0           0                    0                0            0                112 ( 0.00%)       0            0                       k[i] = unit;
       17,882 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         112 ( 0.00%)       0            0              5,982 ( 0.00%)       0            0                       k[fanout - 1] -= k[i];
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   double sqrt_prod = 1;
       12,156 ( 0.00%)  0           0                    0                0            0                  0                0            0                   for (std::size_t i{0}; i < fanout; ++i) {
      102,942 ( 0.00%) 10 ( 0.06%) 10 ( 0.11%)       6,206 ( 0.00%)       0            0              6,094 ( 0.00%)       0            0                       sqrt_prod *= sqrt(k[i]);
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .           
      107,676 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)      29,910 ( 0.00%)       2 ( 0.00%)   2 ( 0.00%)    11,964 ( 0.00%)       0            0                   const double p = sqrt(m) / (pow(2 * M_PI, (fanout - 1.) / 2) * sqrt_prod);
      149,550 ( 0.00%)  4 ( 0.02%)  4 ( 0.04%)      29,910 ( 0.00%)       2 ( 0.00%)   2 ( 0.00%)    11,964 ( 0.00%)       0            0                   auto golomb_rice_length = static_cast<uint32_t>(ceil(log2(-std::log((sqrt(5) + 1) / 2) / log1p(-p))));  // log2 Golomb modulus
            .           .           .                    .                .            .                  .                .            .           
       11,964 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  0                0            0                   SILKWORM_ASSERT(golomb_rice_length <= 0x1F);  // Golomb-Rice code, stored in the 5 upper bits
       17,946 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0              5,982 ( 0.00%)       3 ( 0.00%)   0                   (*memo)[m] = golomb_rice_length << 27;
       12,156 ( 0.00%)  0           0                    0                0            0                  0                0            0                   for (std::size_t i{0}; i < fanout; ++i) {
       30,262 ( 0.00%)  3 ( 0.02%)  3 ( 0.03%)      18,170 ( 0.00%)       0            0                  0                0            0                       golomb_rice_length += (*memo)[k[i]] & 0xFFFF;
            .           .           .                    .                .            .                  .                .            .                   }
       11,964 ( 0.00%)  0           0                    0                0            0                  0                0            0                   SILKWORM_ASSERT(golomb_rice_length <= 0xFFFF);  // Sum of Golomb-Rice code lengths in the subtree, stored in the lower 16 bits
       11,964 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0              5,982 ( 0.00%)       0            0                   (*memo)[m] |= golomb_rice_length;
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   uint32_t nodes = 1;
       12,156 ( 0.00%)  0           0                    0                0            0                  0                0            0                   for (std::size_t i{0}; i < fanout; ++i) {
       30,374 ( 0.00%)  3 ( 0.02%)  3 ( 0.03%)      12,188 ( 0.00%)       0            0                  0                0            0                       nodes += ((*memo)[k[i]] >> 16) & 0x7FF;
            .           .           .                    .                .            .                  .                .            .                   }
       11,964 ( 0.00%)  0           0                    0                0            0                  0                0            0                   SILKWORM_ASSERT(LEAF_SIZE < 3 || nodes <= 0x7FF);  // Number of nodes in the subtree, stored in the middle 11 bits
       17,946 ( 0.00%)  0           0                    0                0            0              5,982 ( 0.00%)       0            0                   (*memo)[m] |= nodes << 16;
            .           .           .                    .                .            .                  .                .            .               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               static constexpr std::array<uint32_t, kMaxBucketSize> fill_golomb_rice() {
           10 ( 0.00%)  0           0                    0                0            0                  2 ( 0.00%)       0            0                   std::array<uint32_t, kMaxBucketSize> memo{0};
            .           .           .                    .                .            .                  .                .            .                   std::size_t s{0};
            .           .           .                    .                .            .                  .                .            .                   for (; s <= LEAF_SIZE; ++s) {
           14 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           4 ( 0.00%)       3 ( 0.00%)   3 ( 0.00%)         6 ( 0.00%)       0            0                       memo[s] = bij_memo[s] << 27 | (s > 1) << 16 | bij_memo[s];
            .           .           .                    .                .            .                  .                .            .                   }
       17,946 ( 0.00%)  0           0                    0                0            0                  0                0            0                   for (; s < kMaxBucketSize; ++s) {
        5,982 ( 0.00%)  0           0                    0                0            0                  0                0            0                       precompute_golomb_rice(static_cast<int>(s), &memo);
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .                   return memo;
            .           .           .                    .                .            .                  .                .            .               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               //! Compute and store the splittings and bijections of the current bucket
        3,430 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)         245 ( 0.00%)       0            0              1,715 ( 0.00%)     243 ( 0.01%)   1 ( 0.00%)      bool recsplit_current_bucket(std::ofstream& index_output_stream) {
            .           .           .                    .                .            .                  .                .            .                   // Extend bucket size accumulator to accommodate current bucket index + 1
        1,960 ( 0.00%)  0           0                  490 ( 0.00%)       0            0                  0                0            0                   while (bucket_size_accumulator_.size() <= (current_bucket_id_ + 1)) {
          735 ( 0.00%)  0           0                    0                0            0                  0                0            0                       bucket_size_accumulator_.push_back(bucket_size_accumulator_.back());
            .           .           .                    .                .            .                  .                .            .                   }
          735 ( 0.00%)  0           0                  245 ( 0.00%)       0            0                245 ( 0.00%)       0            0                   bucket_size_accumulator_.back() += current_bucket_.size();
          490 ( 0.00%)  0           0                  245 ( 0.00%)       0            0                  0                0            0                   SILKWORM_ASSERT(bucket_size_accumulator_.back() >= bucket_size_accumulator_[current_bucket_id_]);
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                   // Sets of size 0 and 1 are not further processed, just write them to index
          980 ( 0.00%)  0           0                  245 ( 0.00%)     245 ( 0.00%)   1 ( 0.00%)         0                0            0                   if (current_bucket_.size() > 1) {
    3,498,775 ( 0.01%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                  0                0            0                       for (std::size_t i{1}; i < current_bucket_.size(); ++i) {
    1,499,265 ( 0.00%)  0           0              499,755 ( 0.01%)  57,719 ( 0.15%) 254 ( 0.00%)         0                0            0                           if (current_bucket_[i] == current_bucket_[i - 1]) {
            .           .           .                    .                .            .                  .                .            .                               SILK_ERROR << "collision detected key=" << current_bucket_[i - 1];
            .           .           .                    .                .            .                  .                .            .                               return true;
            .           .           .                    .                .            .                  .                .            .                           }
            .           .           .                    .                .            .                  .                .            .                       }
          980 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                245 ( 0.00%)     244 ( 0.01%)   1 ( 0.00%)              buffer_bucket_.reserve(current_bucket_.size());
          735 ( 0.00%)  0           0                    0                0            0                245 ( 0.00%)       0            0                       buffer_offsets_.reserve(current_bucket_offsets_.size());
            .           .           .                    .                .            .                  .                .            .                       buffer_bucket_.resize(current_bucket_.size());
            .           .           .                    .                .            .                  .                .            .                       buffer_offsets_.resize(current_bucket_.size());
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                       std::vector<uint32_t> unary;
          490 ( 0.00%)  0           0                    0                0            0                  0                0            0                       recsplit(current_bucket_, current_bucket_offsets_, unary, index_output_stream);
          245 ( 0.00%)  0           0                    0                0            0                  0                0            0                       gr_builder_.append_unary_all(unary);
            .           .           .                    .                .            .                  .                .            .                   } else {
            .           .           .                    .                .            .                  .                .            .                       for (const auto offset : current_bucket_offsets_) {
            .           .           .                    .                .            .                  .                .            .                           Bytes uint64_buffer(8, '\0');
            .           .           .                    .                .            .                  .                .            .                           endian::store_big_u64(uint64_buffer.data(), offset);
            .           .           .                    .                .            .                  .                .            .                           index_output_stream.write(reinterpret_cast<const char*>(uint64_buffer.data()), 8);
            .           .           .                    .                .            .                  .                .            .                           SILK_DEBUG << "[index] written offset: " << offset;
            .           .           .                    .                .            .                  .                .            .                       }
            .           .           .                    .                .            .                  .                .            .                   }
            .           .           .                    .                .            .                  .                .            .                   // Extend bucket position accumulator to accommodate current bucket index + 1
        2,205 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)         490 ( 0.00%)       1 ( 0.00%)   0                  0                0            0                   while (bucket_position_accumulator_.size() <= current_bucket_id_ + 1) {
          490 ( 0.00%)  0           0                    0                0            0                  0                0            0                       bucket_position_accumulator_.push_back(bucket_position_accumulator_.back());
            .           .           .                    .                .            .                  .                .            .                   }
          490 ( 0.00%)  0           0                  245 ( 0.00%)       0            0                245 ( 0.00%)       0            0                   bucket_position_accumulator_.back() = gr_builder_.get_bits();
          490 ( 0.00%)  0           0                  245 ( 0.00%)       0            0                  0                0            0                   SILKWORM_ASSERT(bucket_position_accumulator_.back() >= bucket_position_accumulator_[current_bucket_id_]);
            .           .           .                    .                .            .                  .                .            .                   // Clear for the next bucket
            .           .           .                    .                .            .                  .                .            .                   current_bucket_.clear();
            .           .           .                    .                .            .                  .                .            .                   current_bucket_offsets_.clear();
          245 ( 0.00%)  0           0                    0                0            0                  0                0            0                   return false;
        2,940 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)       2,205 ( 0.00%)     490 ( 0.00%)   0                  0                0            0               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               //! Apply the RecSplit algorithm to the given bucket
            .           .           .                    .                .            .                  .                .            .               void recsplit(std::vector<uint64_t>& bucket,
            .           .           .                    .                .            .                  .                .            .                             std::vector<uint64_t>& offsets,
            .           .           .                    .                .            .                  .                .            .                             std::vector<uint32_t>& unary,
            .           .           .                    .                .            .                  .                .            .                             std::ofstream& index_ofs) {
        1,715 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0                735 ( 0.00%)       0            0                   recsplit(/*.level=*/0, bucket, offsets, /*.start=*/0, /*.end=*/bucket.size(), unary, index_ofs);
          490 ( 0.00%)  0           0                  490 ( 0.00%)       1 ( 0.00%)   1 ( 0.00%)         0                0            0               }
            .           .           .                    .                .            .                  .                .            .           
    1,252,220 ( 0.00%)  3 ( 0.02%)  3 ( 0.03%)     187,833 ( 0.00%)     386 ( 0.00%)   1 ( 0.00%)   813,943 ( 0.03%)  10,629 ( 0.34%)  35 ( 0.00%)      void recsplit(int level,
            .           .           .                    .                .            .                  .                .            .                             std::vector<uint64_t>& bucket,
            .           .           .                    .                .            .                  .                .            .                             std::vector<uint64_t>& offsets,
            .           .           .                    .                .            .                  .                .            .                             std::size_t start,
            .           .           .                    .                .            .                  .                .            .                             std::size_t end,
            .           .           .                    .                .            .                  .                .            .                             std::vector<uint32_t>& unary,
            .           .           .                    .                .            .                  .                .            .                             std::ofstream& index_ofs) {
      328,405 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)     114,585 ( 0.00%)   1,136 ( 0.00%)   2 ( 0.00%)    88,598 ( 0.00%)       0            0                   uint64_t salt = kStartSeed[level];
      328,405 ( 0.00%)  0           0               51,974 ( 0.00%)       0            0            151,209 ( 0.01%)       8 ( 0.00%)   4 ( 0.00%)          const uint16_t m = end - start;
      490,071 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)     125,150 ( 0.00%)     965 ( 0.00%)   2 ( 0.00%)         0                0            0                   SILKWORM_ASSERT(m > 1);
      250,421 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)      51,974 ( 0.00%)       0            0             15,746 ( 0.00%)       6 ( 0.00%)   3 ( 0.00%)          if (m <= LEAF_SIZE) {
            .           .           .                    .                .            .                  .                .            .                       // No need to build aggregation levels - just find bijection
      500,600 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)     187,725 ( 0.00%)       0            0            125,150 ( 0.00%)       0            0                       if (level == 7) {
      168,360 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)      33,672 ( 0.00%)       0            0             33,672 ( 0.00%)     488 ( 0.02%)   0                           SILK_DEBUG << "[index] recsplit m: " << m << " salt: " << salt << " start: " << start << " bucket[start]=" << bucket[start]
            .           .           .                    .                .            .                  .                .            .                                      << " current_bucket_id_=" << current_bucket_id_;
    1,428,820 ( 0.00%)  0           0               62,575 ( 0.00%)       0            0             62,575 ( 0.00%)       0            0                           for (std::size_t j = 0; j < m; j++) {
    1,077,504 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0            269,376 ( 0.01%)       0            0                               SILK_DEBUG << "[index] buffer m: " << m << " start: " << start << " j: " << j << " bucket[start + j]=" << bucket[start + j];
            .           .           .                    .                .            .                  .                .            .                           }
            .           .           .                    .                .            .                  .                .            .                       }
            .           .           .                    .                .            .                  .                .            .                       while (true) {
   77,890,272 ( 0.25%)  0           0                    0                0            0                  0                0            0                           uint32_t mask{0};
            .           .           .                    .                .            .                  .                .            .                           bool fail{false};
  304,830,192 ( 0.98%)  0           0           26,088,574 ( 0.40%)       0            0                  0                0            0                           for (uint16_t i{0}; !fail && i < m; i++) {
  440,703,563 ( 1.42%)  0           0          110,160,247 ( 1.67%)       7 ( 0.00%)   0                  0                0            0                               uint32_t bit = uint32_t(1) << remap16(remix(bucket[start + i] + salt), m);
  220,320,494 ( 0.71%)  0           0                    0                0            0                  0                0            0                               if ((mask & bit) != 0) {
            .           .           .                    .                .            .                  .                .            .                                   fail = true;
            .           .           .                    .                .            .                  .                .            .                               } else {
   84,259,398 ( 0.27%)  0           0                    0                0            0                  0                0            0                                   mask |= bit;
            .           .           .                    .                .            .                  .                .            .                               }
            .           .           .                    .                .            .                  .                .            .                           }
            .           .           .                    .                .            .                  .                .            .                           if (!fail) break;
   25,900,849 ( 0.08%)  0           0                    0                0            0                  0                0            0                           salt++;
            .           .           .                    .                .            .                  .                .            .                       }
    1,499,892 ( 0.00%)  0           0                    0                0            0                  0                0            0                       for (std::size_t i{0}; i < m; i++) {
      999,928 ( 0.00%)  0           0              499,964 ( 0.01%)       0            0                  0                0            0                           std::size_t j = remap16(remix(bucket[start + i] + salt), m);
      999,928 ( 0.00%)  0           0              499,964 ( 0.01%)       7 ( 0.00%)   0            499,964 ( 0.02%)       3 ( 0.00%)   0                           buffer_offsets_[j] = offsets[start + i];
            .           .           .                    .                .            .                  .                .            .                       }
            .           .           .                    .                .            .                  .                .            .                       Bytes uint64_buffer(8, '\0');
    1,499,892 ( 0.00%)  0           0                    0                0            0                  0                0            0                       for (auto i{0}; i < m; i++) {
            .           .           .                    .                .            .                  .                .            .                           endian::store_big_u64(uint64_buffer.data(), buffer_offsets_[i]);
    3,499,748 ( 0.01%)  1 ( 0.01%)  1 ( 0.01%)   1,499,892 ( 0.02%)       0            0            499,964 ( 0.02%)       1 ( 0.00%)   0                           index_ofs.write(reinterpret_cast<const char*>(uint64_buffer.data() + (8 - bytes_per_record_)), bytes_per_record_);
    1,499,892 ( 0.00%)  0           0              499,964 ( 0.01%)       0            0                  0                0            0                           if (level == 0) {
            .           .           .                    .                .            .                  .                .            .                               SILK_DEBUG << "[index] written offset: " << buffer_offsets_[i];
            .           .           .                    .                .            .                  .                .            .                           }
            .           .           .                    .                .            .                  .                .            .                       }
       62,575 ( 0.00%)  0           0               62,575 ( 0.00%)       0            0                  0                0            0                       salt -= kStartSeed[level];
            .           .           .                    .                .            .                  .                .            .                       const auto log2golomb = golomb_param(m, memo);
        7,740 ( 0.00%)  0           0                    0                0            0                  0                0            0                       gr_builder_.append_fixed(salt, log2golomb);
      187,725 ( 0.00%)  0           0                    0                0            0             62,575 ( 0.00%)       1 ( 0.00%)   0                       unary.push_back(static_cast<uint32_t>(salt >> log2golomb));
            .           .           .                    .                .            .                  .                .            .                   } else {
       26,023 ( 0.00%)  0           0                    0                0            0                  0                0            0                       const auto [fanout, unit] = SplitStrategy::split_params(m);
            .           .           .                    .                .            .                  .                .            .           
      104,092 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0             26,023 ( 0.00%)   1,463 ( 0.05%)   3 ( 0.00%)              SILK_DEBUG << "[index] m > _leaf: m=" << m << " fanout=" << fanout << " unit=" << unit;
            .           .           .                    .                .            .                  .                .            .           
      104,092 ( 0.00%)  0           0               52,046 ( 0.00%)     965 ( 0.00%)   2 ( 0.00%)         0                0            0                       SILKWORM_ASSERT(fanout <= kLowerAggregationBound);
        7,219 ( 0.00%)  0           0                    0                0            0                  0                0            0                       count_.resize(fanout);
    3,548,055 ( 0.01%)  0           0                    0                0            0                  0                0            0                       while (true) {
            .           .           .                    .                .            .                  .                .            .                           std::fill(count_.begin(), count_.end(), 0);
  673,733,171 ( 2.17%)  0           0                    0                0            0                  0                0            0                           for (std::size_t i{0}; i < m; i++) {
1,110,975,025 ( 3.58%)  0           0          444,390,010 ( 6.73%) 102,574 ( 0.27%)   0                  0                0            0                               count_[uint16_t(remap16(remix(bucket[start + i] + salt), m)) / unit]++;
            .           .           .                    .                .            .                  .                .            .                           }
            .           .           .                    .                .            .                  .                .            .                           bool broken{false};
    1,459,172 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)     729,586 ( 0.01%)     220 ( 0.00%)   0             52,046 ( 0.00%)       0            0                           for (std::size_t i = 0; i < fanout - 1; i++) {
    8,326,170 ( 0.03%)  0           0            4,163,085 ( 0.06%)       0            0                  0                0            0                               broken = broken || (count_[i] != unit);
            .           .           .                    .                .            .                  .                .            .                           }
            .           .           .                    .                .            .                  .                .            .                           if (!broken) break;
    3,548,055 ( 0.01%)  0           0                    0                0            0                  0                0            0                           salt++;
            .           .           .                    .                .            .                  .                .            .                       }
      124,704 ( 0.00%)  0           0               20,784 ( 0.00%)       0            0                  0                0            0                       for (std::size_t i{0}, c{0}; i < fanout; i++, c += unit) {
      208,198 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)      52,046 ( 0.00%)       0            0             88,389 ( 0.00%)       0            0                           count_[i] = c;
            .           .           .                    .                .            .                  .                .            .                       }
    9,830,185 ( 0.03%)  0           0                    0                0            0                  0                0            0                       for (std::size_t i{0}; i < m; i++) {
   13,072,216 ( 0.04%)  0           0            3,268,054 ( 0.05%)  48,671 ( 0.13%)   0                  0                0            0                           auto j = uint16_t(remap16(remix(bucket[start + i] + salt), m)) / unit;
    3,268,054 ( 0.01%)  0           0                    0                0            0          3,268,054 ( 0.12%) 141,526 ( 4.52%) 256 ( 0.01%)                  buffer_bucket_[count_[j]] = bucket[start + i];
    6,536,108 ( 0.02%)  1 ( 0.01%)  1 ( 0.01%)   3,268,054 ( 0.05%) 146,443 ( 0.39%) 256 ( 0.00%) 3,268,054 ( 0.12%) 119,759 ( 3.82%) 256 ( 0.01%)                  buffer_offsets_[count_[j]] = offsets[start + i];
    3,268,054 ( 0.01%)  0           0            3,268,054 ( 0.05%)       0            0                  0                0            0                           count_[j]++;
            .           .           .                    .                .            .                  .                .            .                       }
       26,023 ( 0.00%)  0           0                    0                0            0                  0                0            0                       std::copy(buffer_bucket_.data(), buffer_bucket_.data() + m, bucket.data() + start);
       78,069 ( 0.00%)  0           0               78,069 ( 0.00%)   2,021 ( 0.01%)   0                  0                0            0                       std::copy(buffer_offsets_.data(), buffer_offsets_.data() + m, offsets.data() + start);
            .           .           .                    .                .            .                  .                .            .           
       26,023 ( 0.00%)  0           0               26,023 ( 0.00%)     226 ( 0.00%)   0                  0                0            0                       salt -= kStartSeed[level];
            .           .           .                    .                .            .                  .                .            .                       const auto log2golomb = golomb_param(m, memo);
        5,162 ( 0.00%)  0           0                    0                0            0              2,581 ( 0.00%)      22 ( 0.00%)   0                       gr_builder_.append_fixed(salt, log2golomb);
       78,069 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0            0             26,023 ( 0.00%)   1,845 ( 0.06%)   2 ( 0.00%)              unary.push_back(static_cast<uint32_t>(salt >> log2golomb));
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .                       std::size_t i;
      650,129 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)     239,144 ( 0.00%)     490 ( 0.00%)   0             52,046 ( 0.00%)       0            0                       for (i = 0; i < m - unit; i += unit) {
      623,660 ( 0.00%)  0           0              187,098 ( 0.00%)       0            0            187,098 ( 0.01%)       1 ( 0.00%)   1 ( 0.00%)                  recsplit(level + 1, bucket, offsets, start + i, start + i + unit, unary, index_ofs);
            .           .           .                    .                .            .                  .                .            .                       }
      182,161 ( 0.00%)  0           0               26,023 ( 0.00%)       3 ( 0.00%)   0                  0                0            0                       if (m - i > 1) {
       78,033 ( 0.00%)  0           0               26,023 ( 0.00%)       0            0             25,987 ( 0.00%)       0            0                           recsplit(level + 1, bucket, offsets, start + i, end, unary, index_ofs);
           36 ( 0.00%)  0           0                    0                0            0                  0                0            0                       } else if (m - i == 1) {
            .           .           .                    .                .            .                  .                .            .                           Bytes uint64_buffer(8, '\0');
       26,023 ( 0.00%)  0           0               26,023 ( 0.00%)     308 ( 0.00%)   0                  0                0            0                           endian::store_big_u64(uint64_buffer.data(), offsets[start + i]);
      313,127 ( 0.00%)  0           0                   72 ( 0.00%)       0            0             62,611 ( 0.00%)       0            0                           index_ofs.write(reinterpret_cast<const char*>(uint64_buffer.data() + (8 - bytes_per_record_)), bytes_per_record_);
          108 ( 0.00%)  0           0                   36 ( 0.00%)       0            0                  0                0            0                           if (level == 0) {
            .           .           .                    .                .            .                  .                .            .                               SILK_DEBUG << "[index] written offset: " << offsets[start + i];
            .           .           .                    .                .            .                  .                .            .                           }
            .           .           .                    .                .            .                  .                .            .                       }
            .           .           .                    .                .            .                  .                .            .                   }
      688,721 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)     563,499 ( 0.01%)   1,280 ( 0.00%)   2 ( 0.00%)         0                0            0               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               hash128_t inline murmur_hash_3(const void* data, const size_t length) const {
    1,000,000 ( 0.00%)  0           0                    0                0            0            500,000 ( 0.02%)       0            0                   hash128_t h{};
            .           .           .                    .                .            .                  .                .            .                   hasher_->hash_x64_128(data, length, &h);
            .           .           .                    .                .            .                  .                .            .                   return h;
            .           .           .                    .                .            .                  .                .            .               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               // Maps a 128-bit to a bucket using the first 64-bit half.
            .           .           .                    .                .            .                  .                .            .               inline uint64_t hash128_to_bucket(const hash128_t& hash) const { return remap128(hash.first, bucket_count_); }
            .           .           .                    .                .            .                  .                .            .           
           54 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           6 ( 0.00%)       1 ( 0.00%)   0                 30 ( 0.00%)       1 ( 0.00%)   0               void check_minimum_length(std::size_t minimum_length) {
           30 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          12 ( 0.00%)       1 ( 0.00%)   0                  0                0            0                   if (encoded_file_ && encoded_file_->length() < minimum_length) {
            .           .           .                    .                .            .                  .                .            .                       throw std::runtime_error("RecSplit encoded file is too short: " + std::to_string(encoded_file_->length()));
            .           .           .                    .                .            .                  .                .            .                   }
           54 ( 0.00%)  0           0                   42 ( 0.00%)       0            0                  0                0            0               }
            .           .           .                    .                .            .                  .                .            .           
            .           .           .                    .                .            .                  .                .            .               friend std::ostream& operator<<(std::ostream& os, const RecSplit<LEAF_SIZE>& rs) {
            .           .           .                    .                .            .                  .                .            .                   size_t leaf_size = LEAF_SIZE;
            .           .           .                    .                .            .                  .                .            .                   os.write(reinterpret_cast<char*>(&leaf_size), sizeof(leaf_size));
            .           .           .                    .                .            .                  .                .            .                   os.write(reinterpret_cast<char*>(&rs.bucket_size_), sizeof(rs.bucket_size_));
            .           .           .                    .                .            .                  .                .            .                   os.write(reinterpret_cast<char*>(&rs.key_count_), sizeof(rs.key_count_));
            .           .           .                    .                .            .                  .                .            .                   os << rs.golomb_rice_codes_;
            .           .           .                    .                .            .                  .                .            .                   os << rs.double_ef_index_;
-- line 885 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/shared_ptr_base.h
--------------------------------------------------------------------------------
Ir                  I1mr        ILmr        Dr                  D1mr               DLmr            Dw               D1mw            DLmw            

-- line 119 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .               };
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .             template<_Lock_policy _Lp = __default_lock_policy>
         .           .           .                   .                  .               .                .               .               .               class _Sp_counted_base
         .           .           .                   .                  .               .                .               .               .               : public _Mutex_base<_Lp>
         .           .           .                   .                  .               .                .               .               .               {
         .           .           .                   .                  .               .                .               .               .               public:
         .           .           .                   .                  .               .                .               .               .                 _Sp_counted_base() noexcept
    32,245 ( 0.00%)  2 ( 0.01%)  1 ( 0.01%)          6 ( 0.00%)         0               0           32,236 ( 0.00%)      0               0                 : _M_use_count(1), _M_weak_count(1) { }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 virtual
         .           .           .                   .                  .               .                .               .               .                 ~_Sp_counted_base() noexcept
         .           .           .                   .                  .               .                .               .               .                 { }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 // Called when _M_use_count drops to zero, to release the resources
         .           .           .                   .                  .               .                .               .               .                 // managed by *this.
         .           .           .                   .                  .               .                .               .               .                 virtual void
-- line 135 ----------------------------------------
-- line 153 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .           	if (!_M_add_ref_lock_nothrow())
         .           .           .                   .                  .               .                .               .               .           	  __throw_bad_weak_ptr();
         .           .           .                   .                  .               .                .               .               .                 }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 bool
         .           .           .                   .                  .               .                .               .               .                 _M_add_ref_lock_nothrow() noexcept;
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 void
        21 ( 0.00%)  3 ( 0.02%)  1 ( 0.01%)          0                  0               0                7 ( 0.00%)      0               0                 _M_release() noexcept
         .           .           .                   .                  .               .                .               .               .                 {
         .           .           .                   .                  .               .                .               .               .                   // Be race-detector-friendly.  For more info see bits/c++config.
         .           .           .                   .                  .               .                .               .               .                   _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_use_count);
   744,988 ( 0.00%)  0           0                   0                  0               0                0               0               0           	if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
         .           .           .                   .                  .               .                .               .               .           	  {
         .           .           .                   .                  .               .                .               .               .                       _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_use_count);
    96,714 ( 0.00%)  7 ( 0.04%)  7 ( 0.07%)     64,476 ( 0.00%)        14 ( 0.00%)      7 ( 0.00%)  32,238 ( 0.00%)      0               0           	    _M_dispose();
         .           .           .                   .                  .               .                .               .               .           	    // There must be a memory barrier between dispose() and destroy()
         .           .           .                   .                  .               .                .               .               .           	    // to ensure that the effects of dispose() are observed in the
         .           .           .                   .                  .               .                .               .               .           	    // thread that runs destroy().
         .           .           .                   .                  .               .                .               .               .           	    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html
         .           .           .                   .                  .               .                .               .               .           	    if (_Mutex_base<_Lp>::_S_need_barriers)
         .           .           .                   .                  .               .                .               .               .           	      {
         .           .           .                   .                  .               .                .               .               .           		__atomic_thread_fence (__ATOMIC_ACQ_REL);
         .           .           .                   .                  .               .                .               .               .           	      }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                       // Be race-detector-friendly.  For more info see bits/c++config.
         .           .           .                   .                  .               .                .               .               .                       _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&_M_weak_count);
    64,476 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          0                  0               0                0               0               0           	    if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
         .           .           .                   .                  .               .                .               .               .           						       -1) == 1)
         .           .           .                   .                  .               .                .               .               .                         {
         .           .           .                   .                  .               .                .               .               .                           _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&_M_weak_count);
   128,948 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)     64,476 ( 0.00%)         2 ( 0.00%)      0           32,232 ( 0.00%)      0               0           	        _M_destroy();
         .           .           .                   .                  .               .                .               .               .                         }
         .           .           .                   .                  .               .                .               .               .           	  }
         8 ( 0.00%)  3 ( 0.02%)  1 ( 0.01%)          8 ( 0.00%)         0               0                0               0               0                 }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 void
         .           .           .                   .                  .               .                .               .               .                 _M_weak_add_ref() noexcept
         .           .           .                   .                  .               .                .               .               .                 { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 void
         .           .           .                   .                  .               .                .               .               .                 _M_weak_release() noexcept
         .           .           .                   .                  .               .                .               .               .                 {
-- line 195 ----------------------------------------
-- line 331 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .               class __weak_count;
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .             template<_Lock_policy _Lp = __default_lock_policy>
         .           .           .                   .                  .               .                .               .               .               class __shared_count;
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .             // Counted ptr with no deleter or allocator support
         .           .           .                   .                  .               .                .               .               .             template<typename _Ptr, _Lock_policy _Lp>
        20 ( 0.00%)  0           0                   0                  0               0                0               0               0               class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
         .           .           .                   .                  .               .                .               .               .               {
         .           .           .                   .                  .               .                .               .               .               public:
         .           .           .                   .                  .               .                .               .               .                 explicit
         .           .           .                   .                  .               .                .               .               .                 _Sp_counted_ptr(_Ptr __p) noexcept
        34 ( 0.00%)  4 ( 0.02%)  1 ( 0.01%)          0                  0               0               22 ( 0.00%)      0               0                 : _M_ptr(__p) { }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 virtual void
        10 ( 0.00%)  8 ( 0.05%)  4 ( 0.04%)          0                  0               0                0               0               0                 _M_dispose() noexcept
        50 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         30 ( 0.00%)         7 ( 0.00%)      5 ( 0.00%)       0               0               0                 { delete _M_ptr; }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 virtual void
        10 ( 0.00%)  8 ( 0.05%)  4 ( 0.04%)          0                  0               0                0               0               0                 _M_destroy() noexcept
         .           .           .                   .                  .               .                .               .               .                 { delete this; }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 virtual void*
         .           .           .                   .                  .               .                .               .               .                 _M_get_deleter(const std::type_info&) noexcept
         .           .           .                   .                  .               .                .               .               .                 { return nullptr; }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
         .           .           .                   .                  .               .                .               .               .                 _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;
-- line 359 ----------------------------------------
-- line 507 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .                 };
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .               public:
         .           .           .                   .                  .               .                .               .               .                 using __allocator_type = __alloc_rebind<_Alloc, _Sp_counted_ptr_inplace>;
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 // Alloc parameter is not a reference so doesn't alias anything in __args
         .           .           .                   .                  .               .                .               .               .                 template<typename... _Args>
         .           .           .                   .                  .               .                .               .               .           	_Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
    64,456 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)          0                  0               0           32,227 ( 0.00%)      0               0           	: _M_impl(__a)
         .           .           .                   .                  .               .                .               .               .           	{
         .           .           .                   .                  .               .                .               .               .           	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .           .           .                   .                  .               .                .               .               .           	  // 2070.  allocate_shared should use allocator_traits<A>::construct
         .           .           .                   .                  .               .                .               .               .           	  allocator_traits<_Alloc>::construct(__a, _M_ptr(),
         .           .           .                   .                  .               .                .               .               .           	      std::forward<_Args>(__args)...); // might throw
         .           .           .                   .                  .               .                .               .               .           	}
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 ~_Sp_counted_ptr_inplace() noexcept { }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 virtual void
   193,351 ( 0.00%)  5 ( 0.03%)  5 ( 0.05%)          0                  0               0          161,123 ( 0.01%)      0               0                 _M_dispose() noexcept
         .           .           .                   .                  .               .                .               .               .                 {
         .           .           .                   .                  .               .                .               .               .           	allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
   190,563 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)    190,563 ( 0.00%)        14 ( 0.00%)      0                0               0               0                 }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 // Override because the allocator needs to know the dynamic type
         .           .           .                   .                  .               .                .               .               .                 virtual void
    32,227 ( 0.00%)  5 ( 0.03%)  5 ( 0.05%)          0                  0               0                0               0               0                 _M_destroy() noexcept
         .           .           .                   .                  .               .                .               .               .                 {
         .           .           .                   .                  .               .                .               .               .           	__allocator_type __a(_M_impl._M_alloc());
         .           .           .                   .                  .               .                .               .               .           	__allocated_ptr<__allocator_type> __guard_ptr{ __a, this };
         .           .           .                   .                  .               .                .               .               .           	this->~_Sp_counted_ptr_inplace();
         .           .           .                   .                  .               .                .               .               .                 }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .               private:
         .           .           .                   .                  .               .                .               .               .                 friend class __shared_count<_Lp>; // To be able to call _M_ptr().
-- line 541 ----------------------------------------
-- line 584 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .           	struct __not_alloc_shared_tag<_Sp_alloc_shared_tag<_Tp>> { };
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .               public:
         .           .           .                   .                  .               .                .               .               .                 constexpr __shared_count() noexcept : _M_pi(0)
         .           .           .                   .                  .               .                .               .               .                 { }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 template<typename _Ptr>
         .           .           .                   .                  .               .                .               .               .                   explicit
        24 ( 0.00%)  3 ( 0.02%)  1 ( 0.01%)          0                  0               0               24 ( 0.00%)      2 ( 0.00%)      1 ( 0.00%)  	__shared_count(_Ptr __p) : _M_pi(0)
         .           .           .                   .                  .               .                .               .               .           	{
         .           .           .                   .                  .               .                .               .               .           	  __try
         .           .           .                   .                  .               .                .               .               .           	    {
        32 ( 0.00%)  2 ( 0.01%)  0                   0                  0               0               22 ( 0.00%)      0               0           	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
         .           .           .                   .                  .               .                .               .               .           	    }
         .           .           .                   .                  .               .                .               .               .           	  __catch(...)
         .           .           .                   .                  .               .                .               .               .           	    {
         .           .           .                   .                  .               .                .               .               .           	      delete __p;
         .           .           .                   .                  .               .                .               .               .           	      __throw_exception_again;
         .           .           .                   .                  .               .                .               .               .           	    }
         .           .           .                   .                  .               .                .               .               .           	}
         .           .           .                   .                  .               .                .               .               .           
-- line 604 ----------------------------------------
-- line 646 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .           	  typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
         .           .           .                   .                  .               .                .               .               .           	  typename _Sp_cp_type::__allocator_type __a2(__a._M_a);
         .           .           .                   .                  .               .                .               .               .           	  auto __guard = std::__allocate_guarded(__a2);
         .           .           .                   .                  .               .                .               .               .           	  _Sp_cp_type* __mem = __guard.get();
         .           .           .                   .                  .               .                .               .               .           	  auto __pi = ::new (__mem)
         .           .           .                   .                  .               .                .               .               .           	    _Sp_cp_type(__a._M_a, std::forward<_Args>(__args)...);
         .           .           .                   .                  .               .                .               .               .           	  __guard = nullptr;
         .           .           .                   .                  .               .                .               .               .           	  _M_pi = __pi;
    96,674 ( 0.00%)  0           0                   1 ( 0.00%)         0               0           32,225 ( 0.00%)    663 ( 0.02%)     18 ( 0.00%)  	  __p = __pi->_M_ptr();
         .           .           .                   .                  .               .                .               .               .           	}
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .           #if _GLIBCXX_USE_DEPRECATED
         .           .           .                   .                  .               .                .               .               .           #pragma GCC diagnostic push
         .           .           .                   .                  .               .                .               .               .           #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
         .           .           .                   .                  .               .                .               .               .                 // Special case for auto_ptr<_Tp> to provide the strong guarantee.
         .           .           .                   .                  .               .                .               .               .                 template<typename _Tp>
         .           .           .                   .                  .               .                .               .               .                   explicit
-- line 662 ----------------------------------------
-- line 696 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .                 explicit __shared_count(const __weak_count<_Lp>& __r);
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 // Does not throw if __r._M_get_use_count() == 0, caller must check.
         .           .           .                   .                  .               .                .               .               .                 explicit
         .           .           .                   .                  .               .                .               .               .                 __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t) noexcept;
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 ~__shared_count() noexcept
         .           .           .                   .                  .               .                .               .               .                 {
 1,146,927 ( 0.00%) 14 ( 0.08%) 13 ( 0.14%)    372,498 ( 0.01%)    85,107 ( 0.22%) 85,041 ( 1.65%)       0               0               0           	if (_M_pi != nullptr)
         2 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          0                  0               0                1 ( 0.00%)      0               0           	  _M_pi->_M_release();
         .           .           .                   .                  .               .                .               .               .                 }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 __shared_count(const __shared_count& __r) noexcept
         .           .           .                   .                  .               .                .               .               .                 : _M_pi(__r._M_pi)
         .           .           .                   .                  .               .                .               .               .                 {
         4 ( 0.00%)  0           0                   0                  0               0                0               0               0           	if (_M_pi != nullptr)
         .           .           .                   .                  .               .                .               .               .           	  _M_pi->_M_add_ref_copy();
         .           .           .                   .                  .               .                .               .               .                 }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 __shared_count&
         .           .           .                   .                  .               .                .               .               .                 operator=(const __shared_count& __r) noexcept
         .           .           .                   .                  .               .                .               .               .                 {
         .           .           .                   .                  .               .                .               .               .           	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 1,020,768 ( 0.00%)  0           0             340,256 ( 0.01%)         0               0                0               0               0           	if (__tmp != _M_pi)
         .           .           .                   .                  .               .                .               .               .           	  {
   680,512 ( 0.00%)  0           0                   0                  0               0                0               0               0           	    if (__tmp != nullptr)
         .           .           .                   .                  .               .                .               .               .           	      __tmp->_M_add_ref_copy();
   680,509 ( 0.00%)  2 ( 0.01%)  1 ( 0.01%)          0                  0               0                0               0               0           	    if (_M_pi != nullptr)
         6 ( 0.00%)  0           0                   0                  0               0                6 ( 0.00%)      0               0           	      _M_pi->_M_release();
   680,506 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)          0                  0               0          340,256 ( 0.01%)      0               0           	    _M_pi = __tmp;
         .           .           .                   .                  .               .                .               .               .           	  }
         .           .           .                   .                  .               .                .               .               .           	return *this;
         .           .           .                   .                  .               .                .               .               .                 }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 void
         .           .           .                   .                  .               .                .               .               .                 _M_swap(__shared_count& __r) noexcept
         .           .           .                   .                  .               .                .               .               .                 {
         1 ( 0.00%)  0           0                   1 ( 0.00%)         0               0                0               0               0           	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
         .           .           .                   .                  .               .                .               .               .           	__r._M_pi = _M_pi;
         .           .           .                   .                  .               .                .               .               .           	_M_pi = __tmp;
         .           .           .                   .                  .               .                .               .               .                 }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 long
         .           .           .                   .                  .               .                .               .               .                 _M_get_use_count() const noexcept
         .           .           .                   .                  .               .                .               .               .                 { return _M_pi ? _M_pi->_M_get_use_count() : 0; }
         .           .           .                   .                  .               .                .               .               .           
-- line 741 ----------------------------------------
-- line 1085 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .               public:
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .           #if __cplusplus > 201402L
         .           .           .                   .                  .               .                .               .               .                 using weak_type = __weak_ptr<_Tp, _Lp>;
         .           .           .                   .                  .               .                .               .               .           #endif
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 constexpr __shared_ptr() noexcept
 1,372,154 ( 0.00%)  3 ( 0.02%)  1 ( 0.01%)          0                  0               0          340,251 ( 0.01%) 81,820 ( 2.61%) 81,044 ( 3.42%)        : _M_ptr(0), _M_refcount()
         .           .           .                   .                  .               .                .               .               .                 { }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 template<typename _Yp, typename = _SafeConv<_Yp>>
         .           .           .                   .                  .               .                .               .               .           	explicit
         .           .           .                   .                  .               .                .               .               .           	__shared_ptr(_Yp* __p)
         8 ( 0.00%)  0           0                   0                  0               0                8 ( 0.00%)      0               0           	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
         .           .           .                   .                  .               .                .               .               .           	{
         .           .           .                   .                  .               .                .               .               .           	  static_assert( !is_void<_Yp>::value, "incomplete type" );
         .           .           .                   .                  .               .                .               .               .           	  static_assert( sizeof(_Yp) > 0, "incomplete type" );
         .           .           .                   .                  .               .                .               .               .           	  _M_enable_shared_from_this_with(__p);
         .           .           .                   .                  .               .                .               .               .           	}
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 template<typename _Yp, typename _Deleter, typename = _SafeConv<_Yp>>
         .           .           .                   .                  .               .                .               .               .           	__shared_ptr(_Yp* __p, _Deleter __d)
-- line 1107 ----------------------------------------
-- line 1144 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .           	__shared_ptr(__shared_ptr<_Yp, _Lp>&& __r,
         .           .           .                   .                  .               .                .               .               .           		     element_type* __p) noexcept
         .           .           .                   .                  .               .                .               .               .           	: _M_ptr(__p), _M_refcount()
         .           .           .                   .                  .               .                .               .               .           	{
         .           .           .                   .                  .               .                .               .               .           	  _M_refcount._M_swap(__r._M_refcount);
         .           .           .                   .                  .               .                .               .               .           	  __r._M_ptr = nullptr;
         .           .           .                   .                  .               .                .               .               .           	}
         .           .           .                   .                  .               .                .               .               .           
         6 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          3 ( 0.00%)         0               0                1 ( 0.00%)      0               0                 __shared_ptr(const __shared_ptr&) noexcept = default;
 1,296,570 ( 0.00%)  0           0             308,038 ( 0.00%)         0               0          340,256 ( 0.01%)      0               0                 __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
         .           .           .                   .                  .               .                .               .               .                 ~__shared_ptr() = default;
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           .           .                   .                  .               .                .               .               .           	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
         .           .           .                   .                  .               .                .               .               .           	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
         .           .           .                   .                  .               .                .               .               .           	{ }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 __shared_ptr(__shared_ptr&& __r) noexcept
        29 ( 0.00%)  2 ( 0.01%)  1 ( 0.01%)          9 ( 0.00%)         0               0               10 ( 0.00%)      0               0                 : _M_ptr(__r._M_ptr), _M_refcount()
         .           .           .                   .                  .               .                .               .               .                 {
         .           .           .                   .                  .               .                .               .               .           	_M_refcount._M_swap(__r._M_refcount);
         6 ( 0.00%)  0           0                   0                  0               0                3 ( 0.00%)      0               0           	__r._M_ptr = nullptr;
         .           .           .                   .                  .               .                .               .               .                 }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           .           .                   .                  .               .                .               .               .           	__shared_ptr(__shared_ptr<_Yp, _Lp>&& __r) noexcept
         1 ( 0.00%)  0           0                   1 ( 0.00%)         0               0                0               0               0           	: _M_ptr(__r._M_ptr), _M_refcount()
         .           .           .                   .                  .               .                .               .               .           	{
         .           .           .                   .                  .               .                .               .               .           	  _M_refcount._M_swap(__r._M_refcount);
         2 ( 0.00%)  0           0                   0                  0               0                1 ( 0.00%)      0               0           	  __r._M_ptr = nullptr;
         .           .           .                   .                  .               .                .               .               .           	}
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 template<typename _Yp, typename = _Compatible<_Yp>>
         .           .           .                   .                  .               .                .               .               .           	explicit __shared_ptr(const __weak_ptr<_Yp, _Lp>& __r)
         .           .           .                   .                  .               .                .               .               .           	: _M_refcount(__r._M_refcount) // may throw
         .           .           .                   .                  .               .                .               .               .           	{
         .           .           .                   .                  .               .                .               .               .           	  // It is now safe to copy __r._M_ptr, as
         .           .           .                   .                  .               .                .               .               .           	  // _M_refcount(__r._M_refcount) did not throw.
-- line 1181 ----------------------------------------
-- line 1288 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .                 template<typename _Yp, typename _Deleter, typename _Alloc>
         .           .           .                   .                  .               .                .               .               .           	_SafeConv<_Yp>
         .           .           .                   .                  .               .                .               .               .           	reset(_Yp* __p, _Deleter __d, _Alloc __a)
         .           .           .                   .                  .               .                .               .               .                   { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 /// Return the stored pointer.
         .           .           .                   .                  .               .                .               .               .                 element_type*
         .           .           .                   .                  .               .                .               .               .                 get() const noexcept
82,578,437 ( 0.27%)  3 ( 0.02%)  3 ( 0.03%) 41,475,499 ( 0.63%) 1,751,603 ( 4.63%)  7,047 ( 0.14%)       3 ( 0.00%)      0               0                 { return _M_ptr; }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 /// Return true if the stored pointer is not null.
         .           .           .                   .                  .               .                .               .               .                 explicit operator bool() const noexcept
         .           .           .                   .                  .               .                .               .               .                 { return _M_ptr != nullptr; }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 /// Return true if use_count() == 1.
         .           .           .                   .                  .               .                .               .               .                 bool
         .           .           .                   .                  .               .                .               .               .                 unique() const noexcept
-- line 1304 ----------------------------------------
-- line 1334 ----------------------------------------
         .           .           .                   .                  .               .                .               .               .           	owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const noexcept
         .           .           .                   .                  .               .                .               .               .           	{ return _M_refcount._M_less(__rhs._M_refcount); }
         .           .           .                   .                  .               .                .               .               .                 /// @}
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .               protected:
         .           .           .                   .                  .               .                .               .               .                 // This constructor is non-standard, it is used by allocate_shared.
         .           .           .                   .                  .               .                .               .               .                 template<typename _Alloc, typename... _Args>
         .           .           .                   .                  .               .                .               .               .           	__shared_ptr(_Sp_alloc_shared_tag<_Alloc> __tag, _Args&&... __args)
     2,785 ( 0.00%)  0           0                   0                  0               0            2,785 ( 0.00%)     70 ( 0.00%)      2 ( 0.00%)  	: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward<_Args>(__args)...)
         .           .           .                   .                  .               .                .               .               .           	{ _M_enable_shared_from_this_with(_M_ptr); }
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
         .           .           .                   .                  .               .                .               .               .           	       typename... _Args>
         .           .           .                   .                  .               .                .               .               .           	friend __shared_ptr<_Tp1, _Lp1>
         .           .           .                   .                  .               .                .               .               .           	__allocate_shared(const _Alloc& __a, _Args&&... __args);
         .           .           .                   .                  .               .                .               .               .           
         .           .           .                   .                  .               .                .               .               .                 // This constructor is used by __weak_ptr::lock() and
-- line 1350 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/ostream
--------------------------------------------------------------------------------
Ir                  I1mr        ILmr        Dr              D1mr        DLmr       Dw          D1mw       DLmw       

-- line 85 ----------------------------------------
         .           .           .               .           .          .           .          .          .                 { this->init(__sb); }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 /**
         .           .           .               .           .          .           .          .          .                  *  @brief  Base destructor.
         .           .           .               .           .          .           .          .          .                  *
         .           .           .               .           .          .           .          .          .                  *  This does very little apart from providing a virtual base dtor.
         .           .           .               .           .          .           .          .          .                 */
         .           .           .               .           .          .           .          .          .                 virtual
        49 ( 0.00%)  3 ( 0.02%)  3 ( 0.03%)     29 ( 0.00%)  3 ( 0.00%) 1 ( 0.00%) 20 ( 0.00%) 0          0                 ~basic_ostream() { }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 /// Safe prefix/suffix operations.
         .           .           .               .           .          .           .          .          .                 class sentry;
         .           .           .               .           .          .           .          .          .                 friend class sentry;
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 ///@{
         .           .           .               .           .          .           .          .          .                 /**
         .           .           .               .           .          .           .          .          .                  *  @brief  Interface for manipulators.
-- line 101 ----------------------------------------
-- line 124 ----------------------------------------
         .           .           .               .           .          .           .          .          .                 }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 __ostream_type&
         .           .           .               .           .          .           .          .          .                 operator<<(ios_base& (*__pf) (ios_base&))
         .           .           .               .           .          .           .          .          .                 {
         .           .           .               .           .          .           .          .          .           	// _GLIBCXX_RESOLVE_LIB_DEFECTS
         .           .           .               .           .          .           .          .          .           	// DR 60. What is a formatted input function?
         .           .           .               .           .          .           .          .          .           	// The inserters for manipulators are *not* formatted output functions.
         3 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)      2 ( 0.00%)  0          0           0          0          0           	__pf(*this);
         .           .           .               .           .          .           .          .          .           	return *this;
         .           .           .               .           .          .           .          .          .                 }
         .           .           .               .           .          .           .          .          .                 ///@}
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 ///@{
         .           .           .               .           .          .           .          .          .                 /**
         .           .           .               .           .          .           .          .          .                  *  @name Inserters
         .           .           .               .           .          .           .          .          .                  *
-- line 140 ----------------------------------------
-- line 159 ----------------------------------------
         .           .           .               .           .          .           .          .          .                  *  @param  __n A variable of builtin integral type.
         .           .           .               .           .          .           .          .          .                  *  @return  @c *this if successful
         .           .           .               .           .          .           .          .          .                  *
         .           .           .               .           .          .           .          .          .                  *  These functions use the stream's current locale (specifically, the
         .           .           .               .           .          .           .          .          .                  *  @c num_get facet) to perform numeric formatting.
         .           .           .               .           .          .           .          .          .                 */
         .           .           .               .           .          .           .          .          .                 __ostream_type&
         .           .           .               .           .          .           .          .          .                 operator<<(long __n)
         2 ( 0.00%)  0           0               0           0          0           1 ( 0.00%) 0          0                 { return _M_insert(__n); }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 __ostream_type&
         .           .           .               .           .          .           .          .          .                 operator<<(unsigned long __n)
       695 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)      9 ( 0.00%)  2 ( 0.00%) 0          10 ( 0.00%) 0          0                 { return _M_insert(__n); }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 __ostream_type&
         .           .           .               .           .          .           .          .          .                 operator<<(bool __n)
         .           .           .               .           .          .           .          .          .                 { return _M_insert(__n); }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 __ostream_type&
         .           .           .               .           .          .           .          .          .                 operator<<(short __n);
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 __ostream_type&
         .           .           .               .           .          .           .          .          .                 operator<<(unsigned short __n)
         .           .           .               .           .          .           .          .          .                 {
         .           .           .               .           .          .           .          .          .           	// _GLIBCXX_RESOLVE_LIB_DEFECTS
         .           .           .               .           .          .           .          .          .           	// 117. basic_ostream uses nonexistent num_put member functions.
77,923,944 ( 0.25%)  1 ( 0.01%)  1 ( 0.01%) 33,672 ( 0.00%)  0          0           0          0          0           	return _M_insert(static_cast<unsigned long>(__n));
         .           .           .               .           .          .           .          .          .                 }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 __ostream_type&
         .           .           .               .           .          .           .          .          .                 operator<<(int __n);
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 __ostream_type&
         .           .           .               .           .          .           .          .          .                 operator<<(unsigned int __n)
         .           .           .               .           .          .           .          .          .                 {
-- line 193 ----------------------------------------
-- line 390 ----------------------------------------
         .           .           .               .           .          .           .          .          .                  *  If @c fail() is not true, calls @c rdbuf()->pubseekoff(off,dir).
         .           .           .               .           .          .           .          .          .                  *  If that function fails, sets failbit.
         .           .           .               .           .          .           .          .          .                 */
         .           .           .               .           .          .           .          .          .                  __ostream_type&
         .           .           .               .           .          .           .          .          .                 seekp(off_type, ios_base::seekdir);
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .               protected:
         .           .           .               .           .          .           .          .          .                 basic_ostream()
       135 ( 0.00%) 10 ( 0.06%)  5 ( 0.05%)     44 ( 0.00%) 13 ( 0.00%) 4 ( 0.00%) 58 ( 0.00%) 1 ( 0.00%) 0                 { this->init(0); }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .           #if __cplusplus >= 201103L
         .           .           .               .           .          .           .          .          .                 // Non-standard constructor that does not call init()
         .           .           .               .           .          .           .          .          .                 basic_ostream(basic_iostream<_CharT, _Traits>&) { }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 basic_ostream(const basic_ostream&) = delete;
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .                 basic_ostream(basic_ostream&& __rhs)
-- line 406 ----------------------------------------
-- line 608 ----------------------------------------
         .           .           .               .           .          .           .          .          .             // Partial specializations
         .           .           .               .           .          .           .          .          .             template<typename _Traits>
         .           .           .               .           .          .           .          .          .               inline basic_ostream<char, _Traits>&
         .           .           .               .           .          .           .          .          .               operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
         .           .           .               .           .          .           .          .          .               {
         .           .           .               .           .          .           .          .          .                 if (!__s)
         .           .           .               .           .          .           .          .          .           	__out.setstate(ios_base::badbit);
         .           .           .               .           .          .           .          .          .                 else
    67,724 ( 0.00%) 26 ( 0.15%) 15 ( 0.16%)     10 ( 0.00%)  0          0          92 ( 0.00%) 0          0           	__ostream_insert(__out, __s,
         .           .           .               .           .          .           .          .          .           			 static_cast<streamsize>(_Traits::length(__s)));
         .           .           .               .           .          .           .          .          .                 return __out;
         .           .           .               .           .          .           .          .          .               }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .             // Signed and unsigned
         .           .           .               .           .          .           .          .          .             template<typename _Traits>
         .           .           .               .           .          .           .          .          .               inline basic_ostream<char, _Traits>&
         .           .           .               .           .          .           .          .          .               operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
-- line 624 ----------------------------------------
-- line 677 ----------------------------------------
         .           .           .               .           .          .           .          .          .              *  This manipulator is often mistakenly used when a simple newline is
         .           .           .               .           .          .           .          .          .              *  desired, leading to poor buffering performance.  See
         .           .           .               .           .          .           .          .          .              *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/streambufs.html#io.streambuf.buffering
         .           .           .               .           .          .           .          .          .              *  for more on this subject.
         .           .           .               .           .          .           .          .          .             */
         .           .           .               .           .          .           .          .          .             template<typename _CharT, typename _Traits>
         .           .           .               .           .          .           .          .          .               inline basic_ostream<_CharT, _Traits>&
         .           .           .               .           .          .           .          .          .               endl(basic_ostream<_CharT, _Traits>& __os)
        42 ( 0.00%)  6 ( 0.04%)  2 ( 0.02%)     30 ( 0.00%)  2 ( 0.00%) 0           6 ( 0.00%) 0          0               { return flush(__os.put(__os.widen('\n'))); }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .             /**
         .           .           .               .           .          .           .          .          .              *  @brief  Write a null character into the output sequence.
         .           .           .               .           .          .           .          .          .              *
         .           .           .               .           .          .           .          .          .              *  <em>Null character</em> is @c CharT() by definition.  For CharT
         .           .           .               .           .          .           .          .          .              *  of @c char, this correctly writes the ASCII @c NUL character
         .           .           .               .           .          .           .          .          .              *  string terminator.
         .           .           .               .           .          .           .          .          .             */
-- line 693 ----------------------------------------
-- line 699 ----------------------------------------
         .           .           .               .           .          .           .          .          .             /**
         .           .           .               .           .          .           .          .          .              *  @brief  Flushes the output stream.
         .           .           .               .           .          .           .          .          .              *
         .           .           .               .           .          .           .          .          .              *  This manipulator simply calls the stream's @c flush() member function.
         .           .           .               .           .          .           .          .          .             */
         .           .           .               .           .          .           .          .          .             template<typename _CharT, typename _Traits>
         .           .           .               .           .          .           .          .          .               inline basic_ostream<_CharT, _Traits>&
         .           .           .               .           .          .           .          .          .               flush(basic_ostream<_CharT, _Traits>& __os)
         6 ( 0.00%)  0           0               0           0          0           6 ( 0.00%) 0          0               { return __os.flush(); }
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .           #if __cplusplus >= 201103L
         .           .           .               .           .          .           .          .          .             // C++11 27.7.3.9 Rvalue stream insertion [ostream.rvalue]
         .           .           .               .           .          .           .          .          .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .           .           .               .           .          .           .          .          .             // 1203. More useful rvalue stream insertion
         .           .           .               .           .          .           .          .          .           
         .           .           .               .           .          .           .          .          .           #if __cpp_lib_concepts
         .           .           .               .           .          .           .          .          .             // Use concepts if possible because they're cheaper to evaluate.
-- line 715 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_algo.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr               D1mr           DLmr       Dw               D1mw            DLmw        

-- line 74 ----------------------------------------
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /// Swaps the median value of *__a, *__b and *__c under __comp to *__result
         .          .          .                .              .          .                .               .           .             template<typename _Iterator, typename _Compare>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
         .          .          .                .              .          .                .               .           .               void
         .          .          .                .              .          .                .               .           .               __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
         .          .          .                .              .          .                .               .           .           			   _Iterator __c, _Compare __comp)
         .          .          .                .              .          .                .               .           .               {
   202,290 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)       0              0          0                0               0           0                 if (__comp(__a, __b))
         .          .          .                .              .          .                .               .           .           	{
   150,190 ( 0.00%) 0          0                0              0          0                0               0           0           	  if (__comp(__b, __c))
         .          .          .                .              .          .                .               .           .           	    std::iter_swap(__result, __b);
    60,328 ( 0.00%) 0          0                0              0          0                0               0           0           	  else if (__comp(__a, __c))
         .          .          .                .              .          .                .               .           .           	    std::iter_swap(__result, __c);
         .          .          .                .              .          .                .               .           .           	  else
         .          .          .                .              .          .                .               .           .           	    std::iter_swap(__result, __a);
         .          .          .                .              .          .                .               .           .           	}
    52,100 ( 0.00%) 0          0                0              0          0                0               0           0                 else if (__comp(__a, __c))
         .          .          .                .              .          .                .               .           .           	std::iter_swap(__result, __a);
    27,896 ( 0.00%) 0          0                0              0          0                0               0           0                 else if (__comp(__b, __c))
         .          .          .                .              .          .                .               .           .           	std::iter_swap(__result, __c);
         .          .          .                .              .          .                .               .           .                 else
         .          .          .                .              .          .                .               .           .           	std::iter_swap(__result, __b);
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /// Provided for stable_partition to use.
         .          .          .                .              .          .                .               .           .             template<typename _InputIterator, typename _Predicate>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
-- line 101 ----------------------------------------
-- line 896 ----------------------------------------
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             template<typename _ForwardIterator, typename _BinaryPredicate>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
         .          .          .                .              .          .                .               .           .               _ForwardIterator
         .          .          .                .              .          .                .               .           .               __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
         .          .          .                .              .          .                .               .           .           		    _BinaryPredicate __binary_pred)
         .          .          .                .              .          .                .               .           .               {
         4 ( 0.00%) 0          0                0              0          0                0               0           0                 if (__first == __last)
         .          .          .                .              .          .                .               .           .           	return __last;
         .          .          .                .              .          .                .               .           .                 _ForwardIterator __next = __first;
         2 ( 0.00%) 0          0                0              0          0                0               0           0                 while (++__next != __last)
         .          .          .                .              .          .                .               .           .           	{
         1 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)       0              0          0                0               0           0           	  if (__binary_pred(__first, __next))
         .          .          .                .              .          .                .               .           .           	    return __first;
         .          .          .                .              .          .                .               .           .           	  __first = __next;
         .          .          .                .              .          .                .               .           .           	}
         .          .          .                .              .          .                .               .           .                 return __last;
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             template<typename _ForwardIterator, typename _BinaryPredicate>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
-- line 917 ----------------------------------------
-- line 1798 ----------------------------------------
         .          .          .                .              .          .                .               .           .               void
         .          .          .                .              .          .                .               .           .               __unguarded_linear_insert(_RandomAccessIterator __last,
         .          .          .                .              .          .                .               .           .           			      _Compare __comp)
         .          .          .                .              .          .                .               .           .               {
         .          .          .                .              .          .                .               .           .                 typename iterator_traits<_RandomAccessIterator>::value_type
         .          .          .                .              .          .                .               .           .           	__val = _GLIBCXX_MOVE(*__last);
         .          .          .                .              .          .                .               .           .                 _RandomAccessIterator __next = __last;
         .          .          .                .              .          .                .               .           .                 --__next;
 5,607,114 ( 0.02%) 0          0                0              0          0                0               0           0                 while (__comp(__val, __next))
         .          .          .                .              .          .                .               .           .           	{
         .          .          .                .              .          .                .               .           .           	  *__last = _GLIBCXX_MOVE(*__next);
         .          .          .                .              .          .                .               .           .           	  __last = __next;
         .          .          .                .              .          .                .               .           .           	  --__next;
         .          .          .                .              .          .                .               .           .           	}
         .          .          .                .              .          .                .               .           .                 *__last = _GLIBCXX_MOVE(__val);
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /// This is a helper function for the sort routine.
         .          .          .                .              .          .                .               .           .             template<typename _RandomAccessIterator, typename _Compare>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
         .          .          .                .              .          .                .               .           .               void
        33 ( 0.00%) 5 ( 0.03%) 5 ( 0.05%)       3 ( 0.00%)     0          0               24 ( 0.00%)      1 ( 0.00%)  0               __insertion_sort(_RandomAccessIterator __first,
         .          .          .                .              .          .                .               .           .           		     _RandomAccessIterator __last, _Compare __comp)
         .          .          .                .              .          .                .               .           .               {
         6 ( 0.00%) 0          0                0              0          0                0               0           0                 if (__first == __last) return;
         .          .          .                .              .          .                .               .           .           
       156 ( 0.00%) 4 ( 0.02%) 4 ( 0.04%)      64 ( 0.00%)     0          0                8 ( 0.00%)      2 ( 0.00%)  1 ( 0.00%)        for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
         .          .          .                .              .          .                .               .           .           	{
        64 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)       0              0          0                0               0           0           	  if (__comp(__i, __first))
         .          .          .                .              .          .                .               .           .           	    {
         .          .          .                .              .          .                .               .           .           	      typename iterator_traits<_RandomAccessIterator>::value_type
         .          .          .                .              .          .                .               .           .           		__val = _GLIBCXX_MOVE(*__i);
         .          .          .                .              .          .                .               .           .           	      _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
         .          .          .                .              .          .                .               .           .           	      *__first = _GLIBCXX_MOVE(__val);
         .          .          .                .              .          .                .               .           .           	    }
         .          .          .                .              .          .                .               .           .           	  else
         .          .          .                .              .          .                .               .           .           	    std::__unguarded_linear_insert(__i,
         .          .          .                .              .          .                .               .           .           				__gnu_cxx::__ops::__val_comp_iter(__comp));
         .          .          .                .              .          .                .               .           .           	}
        33 ( 0.00%) 0          0               27 ( 0.00%)     0          0                0               0           0               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /// This is a helper function for the sort routine.
         .          .          .                .              .          .                .               .           .             template<typename _RandomAccessIterator, typename _Compare>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
         .          .          .                .              .          .                .               .           .               inline void
         .          .          .                .              .          .                .               .           .               __unguarded_insertion_sort(_RandomAccessIterator __first,
         .          .          .                .              .          .                .               .           .           			       _RandomAccessIterator __last, _Compare __comp)
         .          .          .                .              .          .                .               .           .               {
 3,999,880 ( 0.01%) 4 ( 0.02%) 4 ( 0.04%) 999,968 ( 0.02%)     0          0                0               0           0                 for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
         .          .          .                .              .          .                .               .           .           	std::__unguarded_linear_insert(__i,
         .          .          .                .              .          .                .               .           .           				__gnu_cxx::__ops::__val_comp_iter(__comp));
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /**
         .          .          .                .              .          .                .               .           .              *  @doctodo
         .          .          .                .              .          .                .               .           .              *  This controls some aspect of the sort routines.
         .          .          .                .              .          .                .               .           .             */
-- line 1854 ----------------------------------------
-- line 1856 ----------------------------------------
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /// This is a helper function for the sort routine.
         .          .          .                .              .          .                .               .           .             template<typename _RandomAccessIterator, typename _Compare>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
         .          .          .                .              .          .                .               .           .               void
         .          .          .                .              .          .                .               .           .               __final_insertion_sort(_RandomAccessIterator __first,
         .          .          .                .              .          .                .               .           .           			   _RandomAccessIterator __last, _Compare __comp)
         .          .          .                .              .          .                .               .           .               {
         8 ( 0.00%) 0          0                0              0          0                0               0           0                 if (__last - __first > int(_S_threshold))
         .          .          .                .              .          .                .               .           .           	{
        10 ( 0.00%) 2 ( 0.01%) 2 ( 0.02%)       0              0          0                2 ( 0.00%)      0           0           	  std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
         .          .          .                .              .          .                .               .           .           	  std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
         .          .          .                .              .          .                .               .           .           					  __comp);
         .          .          .                .              .          .                .               .           .           	}
         .          .          .                .              .          .                .               .           .                 else
         4 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)       0              0          0                1 ( 0.00%)      0           0           	std::__insertion_sort(__first, __last, __comp);
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /// This is a helper function...
         .          .          .                .              .          .                .               .           .             template<typename _RandomAccessIterator, typename _Compare>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
         .          .          .                .              .          .                .               .           .               _RandomAccessIterator
         .          .          .                .              .          .                .               .           .               __unguarded_partition(_RandomAccessIterator __first,
         .          .          .                .              .          .                .               .           .           			  _RandomAccessIterator __last,
         .          .          .                .              .          .                .               .           .           			  _RandomAccessIterator __pivot, _Compare __comp)
         .          .          .                .              .          .                .               .           .               {
         .          .          .                .              .          .                .               .           .                 while (true)
         .          .          .                .              .          .                .               .           .           	{
27,428,442 ( 0.09%) 0          0                0              0          0                0               0           0           	  while (__comp(__first, __pivot))
         .          .          .                .              .          .                .               .           .           	    ++__first;
         .          .          .                .              .          .                .               .           .           	  --__last;
34,315,518 ( 0.11%) 0          0                0              0          0                0               0           0           	  while (__comp(__pivot, __last))
         .          .          .                .              .          .                .               .           .           	    --__last;
         .          .          .                .              .          .                .               .           .           	  if (!(__first < __last))
         .          .          .                .              .          .                .               .           .           	    return __first;
         .          .          .                .              .          .                .               .           .           	  std::iter_swap(__first, __last);
         .          .          .                .              .          .                .               .           .           	  ++__first;
         .          .          .                .              .          .                .               .           .           	}
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /// This is a helper function...
         .          .          .                .              .          .                .               .           .             template<typename _RandomAccessIterator, typename _Compare>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
         .          .          .                .              .          .                .               .           .               inline _RandomAccessIterator
         .          .          .                .              .          .                .               .           .               __unguarded_partition_pivot(_RandomAccessIterator __first,
         .          .          .                .              .          .                .               .           .           				_RandomAccessIterator __last, _Compare __comp)
         .          .          .                .              .          .                .               .           .               {
   303,435 ( 0.00%) 0          0                0              0          0                0               0           0                 _RandomAccessIterator __mid = __first + (__last - __first) / 2;
         .          .          .                .              .          .                .               .           .                 std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
         .          .          .                .              .          .                .               .           .           				  __comp);
         .          .          .                .              .          .                .               .           .                 return std::__unguarded_partition(__first + 1, __last, __first, __comp);
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             template<typename _RandomAccessIterator, typename _Compare>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
         .          .          .                .              .          .                .               .           .               inline void
-- line 1911 ----------------------------------------
-- line 1917 ----------------------------------------
         .          .          .                .              .          .                .               .           .                 std::__heap_select(__first, __middle, __last, __comp);
         .          .          .                .              .          .                .               .           .                 std::__sort_heap(__first, __middle, __comp);
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /// This is a helper function for the sort routine.
         .          .          .                .              .          .                .               .           .             template<typename _RandomAccessIterator, typename _Size, typename _Compare>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
         .          .          .                .              .          .                .               .           .               void
   809,195 ( 0.00%) 4 ( 0.02%) 4 ( 0.04%)       1 ( 0.00%)     0          0          708,044 ( 0.03%) 31,368 ( 1.00%) 49 ( 0.00%)      __introsort_loop(_RandomAccessIterator __first,
         .          .          .                .              .          .                .               .           .           		     _RandomAccessIterator __last,
         .          .          .                .              .          .                .               .           .           		     _Size __depth_limit, _Compare __comp)
         .          .          .                .              .          .                .               .           .               {
   404,588 ( 0.00%) 0          0                0              0          0                0               0           0                 while (__last - __first > int(_S_threshold))
         .          .          .                .              .          .                .               .           .           	{
   404,580 ( 0.00%) 0          0          101,145 ( 0.00%)   488 ( 0.00%) 0                0               0           0           	  if (__depth_limit == 0)
         .          .          .                .              .          .                .               .           .           	    {
         .          .          .                .              .          .                .               .           .           	      std::__partial_sort(__first, __last, __last, __comp);
         .          .          .                .              .          .                .               .           .           	      return;
         .          .          .                .              .          .                .               .           .           	    }
   101,145 ( 0.00%) 0          0          101,145 ( 0.00%)     0          0                0               0           0           	  --__depth_limit;
         .          .          .                .              .          .                .               .           .           	  _RandomAccessIterator __cut =
         .          .          .                .              .          .                .               .           .           	    std::__unguarded_partition_pivot(__first, __last, __comp);
   404,580 ( 0.00%) 0          0          101,145 ( 0.00%)   764 ( 0.00%) 0          101,145 ( 0.00%)      0           0           	  std::__introsort_loop(__cut, __last, __depth_limit, __comp);
         .          .          .                .              .          .                .               .           .           	  __last = __cut;
         .          .          .                .              .          .                .               .           .           	}
 1,112,636 ( 0.00%) 4 ( 0.02%) 4 ( 0.04%) 910,339 ( 0.01%) 5,330 ( 0.01%) 2 ( 0.00%)       0               0           0               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             // sort
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             template<typename _RandomAccessIterator, typename _Compare>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
         .          .          .                .              .          .                .               .           .               inline void
         .          .          .                .              .          .                .               .           .               __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
         .          .          .                .              .          .                .               .           .           	   _Compare __comp)
         .          .          .                .              .          .                .               .           .               {
         8 ( 0.00%) 0          0                0              0          0                0               0           0                 if (__first != __last)
         .          .          .                .              .          .                .               .           .           	{
        16 ( 0.00%) 2 ( 0.01%) 2 ( 0.02%)       0              0          0                4 ( 0.00%)      0           0           	  std::__introsort_loop(__first, __last,
         .          .          .                .              .          .                .               .           .           				std::__lg(__last - __first) * 2,
         .          .          .                .              .          .                .               .           .           				__comp);
         .          .          .                .              .          .                .               .           .           	  std::__final_insertion_sort(__first, __last, __comp);
         .          .          .                .              .          .                .               .           .           	}
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             template<typename _RandomAccessIterator, typename _Size, typename _Compare>
         .          .          .                .              .          .                .               .           .               _GLIBCXX20_CONSTEXPR
-- line 1962 ----------------------------------------
-- line 2247 ----------------------------------------
         .          .          .                .              .          .                .               .           .                 __glibcxx_function_requires(_LessThanOpConcept<
         .          .          .                .              .          .                .               .           .           	_Tp, typename iterator_traits<_ForwardIterator>::value_type>)
         .          .          .                .              .          .                .               .           .                 __glibcxx_requires_partitioned_lower(__first, __last, __val);
         .          .          .                .              .          .                .               .           .                 __glibcxx_requires_partitioned_upper(__first, __last, __val);
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .                 _ForwardIterator __i
         .          .          .                .              .          .                .               .           .           	= std::__lower_bound(__first, __last, __val,
         .          .          .                .              .          .                .               .           .           			     __gnu_cxx::__ops::__iter_less_val());
       888 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)     188 ( 0.00%)     0          0                0               0           0                 return __i != __last && !(__val < *__i);
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /**
         .          .          .                .              .          .                .               .           .              *  @brief Determines whether an element exists in a range.
         .          .          .                .              .          .                .               .           .              *  @ingroup binary_search_algorithms
         .          .          .                .              .          .                .               .           .              *  @param  __first   An iterator.
         .          .          .                .              .          .                .               .           .              *  @param  __last    Another iterator.
         .          .          .                .              .          .                .               .           .              *  @param  __val     The search term.
-- line 2263 ----------------------------------------
-- line 4287 ----------------------------------------
         .          .          .                .              .          .                .               .           .               {
         .          .          .                .              .          .                .               .           .                 // concept requirements
         .          .          .                .              .          .                .               .           .                 __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
         .          .          .                .              .          .                .               .           .                 __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
         .          .          .                .              .          .                .               .           .           	    // "the type returned by a _UnaryOperation"
         .          .          .                .              .          .                .               .           .           	    __typeof__(__unary_op(*__first))>)
         .          .          .                .              .          .                .               .           .                 __glibcxx_requires_valid_range(__first, __last);
         .          .          .                .              .          .                .               .           .           
       133 ( 0.00%) 0          0                0              0          0                0               0           0                 for (; __first != __last; ++__first, (void)++__result)
        35 ( 0.00%) 0          0                0              0          0               35 ( 0.00%)      0           0           	*__result = __unary_op(*__first);
         .          .          .                .              .          .                .               .           .                 return __result;
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /**
         .          .          .                .              .          .                .               .           .              *  @brief Perform an operation on corresponding elements of two sequences.
         .          .          .                .              .          .                .               .           .              *  @ingroup mutating_algorithms
         .          .          .                .              .          .                .               .           .              *  @param  __first1     An input iterator.
         .          .          .                .              .          .                .               .           .              *  @param  __last1      An input iterator.
-- line 4304 ----------------------------------------
-- line 4834 ----------------------------------------
         .          .          .                .              .          .                .               .           .                 // concept requirements
         .          .          .                .              .          .                .               .           .                 __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
         .          .          .                .              .          .                .               .           .           	    _RandomAccessIterator>)
         .          .          .                .              .          .                .               .           .                 __glibcxx_function_requires(_LessThanComparableConcept<
         .          .          .                .              .          .                .               .           .           	    typename iterator_traits<_RandomAccessIterator>::value_type>)
         .          .          .                .              .          .                .               .           .                 __glibcxx_requires_valid_range(__first, __last);
         .          .          .                .              .          .                .               .           .                 __glibcxx_requires_irreflexive(__first, __last);
         .          .          .                .              .          .                .               .           .           
         1 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)       0              0          0                0               0           0                 std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
         .          .          .                .              .          .                .               .           .               }
         .          .          .                .              .          .                .               .           .           
         .          .          .                .              .          .                .               .           .             /**
         .          .          .                .              .          .                .               .           .              *  @brief Sort the elements of a sequence using a predicate for comparison.
         .          .          .                .              .          .                .               .           .              *  @ingroup sorting_algorithms
         .          .          .                .              .          .                .               .           .              *  @param  __first   An iterator.
         .          .          .                .              .          .                .               .           .              *  @param  __last    Another iterator.
         .          .          .                .              .          .                .               .           .              *  @param  __comp    A comparison functor.
-- line 4850 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/unique_ptr.h
--------------------------------------------------------------------------------
Ir                  I1mr        ILmr        Dr                  D1mr             DLmr           Dw              D1mw        DLmw       

-- line 77 ----------------------------------------
         .           .           .                   .                .              .               .           .          .                 /// Calls `delete __ptr`
         .           .           .                   .                .              .               .           .          .                 void
         .           .           .                   .                .              .               .           .          .                 operator()(_Tp* __ptr) const
         .           .           .                   .                .              .               .           .          .                 {
         .           .           .                   .                .              .               .           .          .           	static_assert(!is_void<_Tp>::value,
         .           .           .                   .                .              .               .           .          .           		      "can't delete pointer to incomplete type");
         .           .           .                   .                .              .               .           .          .           	static_assert(sizeof(_Tp)>0,
         .           .           .                   .                .              .               .           .          .           		      "can't delete pointer to incomplete type");
     9,320 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          6 ( 0.00%)       4 ( 0.00%)     0             339 ( 0.00%)  0          0           	delete __ptr;
     2,281 ( 0.00%)  0           0                   0                0              0               0           0          0                 }
         .           .           .                   .                .              .               .           .          .               };
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
         .           .           .                   .                .              .               .           .          .             // DR 740 - omit specialization for array objects with a compile time length
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .             /// Specialization of default_delete for arrays, used by `unique_ptr<T[]>`
         .           .           .                   .                .              .               .           .          .             template<typename _Tp>
         .           .           .                   .                .              .               .           .          .               struct default_delete<_Tp[]>
-- line 94 ----------------------------------------
-- line 147 ----------------------------------------
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 using pointer = typename _Ptr<_Tp, _Dp>::type;
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 static_assert( !is_rvalue_reference<_Dp>::value,
         .           .           .                   .                .              .               .           .          .           		     "unique_ptr's deleter type must be a function object type"
         .           .           .                   .                .              .               .           .          .           		     " or an lvalue reference type" );
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 __uniq_ptr_impl() = default;
     2,784 ( 0.00%)  0           0                   0                0              0           2,784 ( 0.00%)  0          0                 __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 template<typename _Del>
         .           .           .                   .                .              .               .           .          .                 __uniq_ptr_impl(pointer __p, _Del&& __d)
         .           .           .                   .                .              .               .           .          .           	: _M_t(__p, std::forward<_Del>(__d)) { }
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 __uniq_ptr_impl(__uniq_ptr_impl&& __u) noexcept
         .           .           .                   .                .              .               .           .          .                 : _M_t(std::move(__u._M_t))
     2,840 ( 0.00%)  6 ( 0.04%)  4 ( 0.04%)          0                0              0           2,840 ( 0.00%)  0          0                 { __u._M_ptr() = nullptr; }
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 __uniq_ptr_impl& operator=(__uniq_ptr_impl&& __u) noexcept
         .           .           .                   .                .              .               .           .          .                 {
         .           .           .                   .                .              .               .           .          .           	reset(__u.release());
         .           .           .                   .                .              .               .           .          .           	_M_deleter() = std::forward<_Dp>(__u._M_deleter());
         .           .           .                   .                .              .               .           .          .           	return *this;
         .           .           .                   .                .              .               .           .          .                 }
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 pointer&   _M_ptr() { return std::get<0>(_M_t); }
82,462,198 ( 0.27%) 18 ( 0.11%) 11 ( 0.12%) 82,462,192 ( 1.25%) 237,253 ( 0.63%)   134 ( 0.00%)      0           0          0                 pointer    _M_ptr() const { return std::get<0>(_M_t); }
         .           .           .                   .                .              .               .           .          .                 _Dp&       _M_deleter() { return std::get<1>(_M_t); }
         .           .           .                   .                .              .               .           .          .                 const _Dp& _M_deleter() const { return std::get<1>(_M_t); }
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 void reset(pointer __p) noexcept
         .           .           .                   .                .              .               .           .          .                 {
    45,933 ( 0.00%) 15 ( 0.09%) 12 ( 0.13%)     23,499 ( 0.00%)     577 ( 0.00%)     7 ( 0.00%) 22,434 ( 0.00%)  0          0           	const pointer __old_p = _M_ptr();
    23,480 ( 0.00%)  3 ( 0.02%)  3 ( 0.03%)          9 ( 0.00%)       1 ( 0.00%)     0          23,471 ( 0.00%)  0          0           	_M_ptr() = __p;
    69,122 ( 0.00%)  2 ( 0.01%)  1 ( 0.01%)          0                0              0               0           0          0           	if (__old_p)
        16 ( 0.00%)  0           0                   0                0              0               9 ( 0.00%)  0          0           	  _M_deleter()(__old_p);
         .           .           .                   .                .              .               .           .          .                 }
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 pointer release() noexcept
         .           .           .                   .                .              .               .           .          .                 {
        10 ( 0.00%)  0           0                  10 ( 0.00%)       1 ( 0.00%)     0               0           0          0           	pointer __p = _M_ptr();
       259 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)          0                0              0             259 ( 0.00%) 19 ( 0.00%) 1 ( 0.00%)  	_M_ptr() = nullptr;
         .           .           .                   .                .              .               .           .          .           	return __p;
         .           .           .                   .                .              .               .           .          .                 }
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 void
         .           .           .                   .                .              .               .           .          .                 swap(__uniq_ptr_impl& __rhs) noexcept
         .           .           .                   .                .              .               .           .          .                 {
         .           .           .                   .                .              .               .           .          .           	using std::swap;
         .           .           .                   .                .              .               .           .          .           	swap(this->_M_ptr(), __rhs._M_ptr());
-- line 196 ----------------------------------------
-- line 347 ----------------------------------------
         .           .           .                   .                .              .               .           .          .                 /// Converting constructor from @c auto_ptr
         .           .           .                   .                .              .               .           .          .                 template<typename _Up, typename = _Require<
         .           .           .                   .                .              .               .           .          .           	       is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
         .           .           .                   .                .              .               .           .          .           	unique_ptr(auto_ptr<_Up>&& __u) noexcept;
         .           .           .                   .                .              .               .           .          .           #pragma GCC diagnostic pop
         .           .           .                   .                .              .               .           .          .           #endif
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 /// Destructor, invokes the deleter if the stored pointer is not null.
         2 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)          0                0              0               0           0          0                 ~unique_ptr() noexcept
         .           .           .                   .                .              .               .           .          .                 {
         .           .           .                   .                .              .               .           .          .           	static_assert(__is_invocable<deleter_type&, pointer>::value,
         .           .           .                   .                .              .               .           .          .           		      "unique_ptr's deleter must be invocable with a pointer");
         .           .           .                   .                .              .               .           .          .           	auto& __ptr = _M_t._M_ptr();
   176,017 ( 0.00%) 52 ( 0.30%) 47 ( 0.49%)     58,667 ( 0.00%)   6,683 ( 0.02%) 5,905 ( 0.11%)      4 ( 0.00%)  0          0           	if (__ptr != nullptr)
       358 ( 0.00%) 20 ( 0.12%) 17 ( 0.18%)         35 ( 0.00%)       1 ( 0.00%)     1 ( 0.00%)    215 ( 0.00%)  1 ( 0.00%) 0           	  get_deleter()(std::move(__ptr));
         .           .           .                   .                .              .               .           .          .           	__ptr = pointer();
         2 ( 0.00%)  0           0                   2 ( 0.00%)       0              0               0           0          0                 }
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 // Assignment.
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .                 /** @brief Move assignment operator.
         .           .           .                   .                .              .               .           .          .                  *
         .           .           .                   .                .              .               .           .          .                  * Invokes the deleter if this object owns a pointer.
         .           .           .                   .                .              .               .           .          .                  */
         .           .           .                   .                .              .               .           .          .                 unique_ptr& operator=(unique_ptr&&) = default;
-- line 371 ----------------------------------------
-- line 954 ----------------------------------------
         .           .           .                   .                .              .               .           .          .               { struct __invalid_type { }; };
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .             /// @endcond
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .             /// std::make_unique for single objects
         .           .           .                   .                .              .               .           .          .             template<typename _Tp, typename... _Args>
         .           .           .                   .                .              .               .           .          .               inline typename _MakeUniq<_Tp>::__single_object
         .           .           .                   .                .              .               .           .          .               make_unique(_Args&&... __args)
    18,379 ( 0.00%) 26 ( 0.15%) 17 ( 0.18%)        290 ( 0.00%)       6 ( 0.00%)     1 ( 0.00%)  6,139 ( 0.00%)  1 ( 0.00%) 0               { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .             /// std::make_unique for arrays of unknown bound
         .           .           .                   .                .              .               .           .          .             template<typename _Tp>
         .           .           .                   .                .              .               .           .          .               inline typename _MakeUniq<_Tp>::__array
         .           .           .                   .                .              .               .           .          .               make_unique(size_t __num)
         .           .           .                   .                .              .               .           .          .               { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }
         .           .           .                   .                .              .               .           .          .           
         .           .           .                   .                .              .               .           .          .             /// Disable std::make_unique for arrays of known bound
-- line 970 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/mriccobene/CLionProjects/silkworm/silkworm/node/huffman/decompressor.cpp
--------------------------------------------------------------------------------
Ir                   I1mr        ILmr        Dr                   D1mr             DLmr             Dw                   D1mw           DLmw        

-- line 42 ----------------------------------------
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           //! Minimum compressed file size given the metadata header
          .           .           .                    .                .                .                    .              .           .           constexpr std::size_t kMinimumFileSize = 32;
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           //! Maximum allowed depth in compressed file
          .           .           .                    .                .                .                    .              .           .           constexpr std::size_t kMaxAllowedDepth = 2048;
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           DecodingTable::DecodingTable(std::size_t max_depth) : max_depth_(max_depth) {
     17,744 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)           0                0                0                3,042 ( 0.00%)     1 ( 0.00%)  1 ( 0.00%)      bit_length_ = max_depth_ > kMaxTableBitLength ? kMaxTableBitLength : max_depth_;
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           CodeWord::CodeWord() : CodeWord(0, 0, {}, nullptr, nullptr) {}
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           CodeWord::CodeWord(uint16_t code, uint8_t length, ByteView pattern)
          .           .           .                    .                .                .                    .              .           .               : CodeWord(code, length, pattern, nullptr, nullptr) {}
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           CodeWord::CodeWord(uint16_t code, uint8_t length, ByteView pattern, std::unique_ptr<PatternTable> table, CodeWord* next)
    193,344 ( 0.00%) 11 ( 0.06%)  6 ( 0.06%)      61,664 ( 0.00%)       0                0              131,680 ( 0.00%)     4 ( 0.00%)  0               : code_(code), code_length_(length), pattern_(pattern), table_(std::move(table)), next_(next) {}
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           void CodeWord::reset_content(uint16_t code, uint8_t length, ByteView pattern) {
          .           .           .                    .                .                .                    .              .           .               code_ = code;
          .           .           .                    .                .                .                    .              .           .               code_length_ = length;
          .           .           .                    .                .                .                    .              .           .               pattern_ = pattern;
          .           .           .                    .                .                .                    .              .           .               table_ = nullptr;
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
-- line 67 ----------------------------------------
-- line 93 ----------------------------------------
          .           .           .                    .                .                .                    .              .           .           //! 2 -> [4 8 12 16 20 ... 504 508]
          .           .           .                    .                .                .                    .              .           .           //! ...
          .           .           .                    .                .                .                    .              .           .           //! 7 -> [128 256 384]
          .           .           .                    .                .                .                    .              .           .           //! 8 -> [256]
          .           .           .                    .                .                .                    .              .           .           //! 9 -> []
          .           .           .                    .                .                .                    .              .           .           //! @return the word distances for power of 2
          .           .           .                    .                .                .                    .              .           .           static PatternTable::WordDistances build_word_distances() {
          .           .           .                    .                .                .                    .              .           .               PatternTable::WordDistances word_distances{};
         92 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)          36 ( 0.00%)       0                0                    2 ( 0.00%)     0           0               for (std::size_t i{1}; i < PatternTable::kNumPowers; ++i) {
          .           .           .                    .                .                .                    .              .           .                   std::vector<int> distances{};
         90 ( 0.00%)  0           0                    0                0                0                    0              0           0                   distances.reserve((std::size_t(1) << (PatternTable::kNumPowers - 1 - i)) - 1);
      4,156 ( 0.00%)  0           0                    0                0                0                    0              0           0                   for (int j{1 << i}; 0 < j && j < PatternTable::kMaxPower; j += (1 << i)) {
          .           .           .                    .                .                .                    .              .           .                       distances.push_back(j);
          .           .           .                    .                .                .                    .              .           .                   }
          .           .           .                    .                .                .                    .              .           .                   word_distances[i] = std::move(distances);
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               return word_distances;
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           //! Initialize once and for all the word distances in the data for each power of 2
          8 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           0                0                0                    0              0           0           const PatternTable::WordDistances PatternTable::word_distances_{build_word_distances()};
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           //! Initialize condensed table threshold for bit length using default value
          .           .           .                    .                .                .                    .              .           .           std::size_t PatternTable::condensed_table_bit_length_threshold_{kDefaultCondensedTableBitLengthThreshold};
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           void PatternTable::set_condensed_table_bit_length_threshold(std::size_t condensed_table_bit_length_threshold) {
          .           .           .                    .                .                .                    .              .           .               if (condensed_table_bit_length_threshold > kMaxTableBitLength) {
          .           .           .                    .                .                .                    .              .           .                   throw std::invalid_argument{
          .           .           .                    .                .                .                    .              .           .                       "bit length threshold for condensed tables is too big: " +
          .           .           .                    .                .                .                    .              .           .                       std::to_string(condensed_table_bit_length_threshold) +
          .           .           .                    .                .                .                    .              .           .                       " max allowed value is: " +
          .           .           .                    .                .                .                    .              .           .                       std::to_string(kMaxTableBitLength)};
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               condensed_table_bit_length_threshold_ = condensed_table_bit_length_threshold;
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
     16,728 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0                5,576 ( 0.00%)     0           0           PatternTable::PatternTable(std::size_t max_depth) : DecodingTable(max_depth) {
      5,576 ( 0.00%)  0           0                2,788 ( 0.00%)       4 ( 0.00%)       0                    0              0           0               if (bit_length_ <= condensed_table_bit_length_threshold_) {
      5,576 ( 0.00%)  0           0                    0                0                0                    0              0           0                   codewords_.resize(std::size_t(1) << bit_length_);
          .           .           .                    .                .                .                    .              .           .               }
     11,152 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)       8,364 ( 0.00%)       0                0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           std::size_t PatternTable::build_condensed(std::span<Pattern> patterns) {
         32 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)          12 ( 0.00%)       0                0                    8 ( 0.00%)     0           0               return build_condensed(patterns, max_depth_, 0, 0, 0);
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
  1,603,160 ( 0.01%)  7 ( 0.04%)  4 ( 0.04%)     184,980 ( 0.00%)       0                0              616,600 ( 0.02%) 1,059 ( 0.03%) 35 ( 0.00%)  std::size_t PatternTable::build_condensed(std::span<Pattern> patterns, uint64_t highest_depth, uint16_t code, int bits, uint64_t depth) {
    246,640 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0               61,660 ( 0.00%)   581 ( 0.02%) 25 ( 0.00%)      SILK_DEBUG << "#patterns: " << patterns.size() << " highest_depth: " << highest_depth << " code: " << code
          .           .           .                    .                .                .                    .              .           .                          << " bits: " << std::bitset<CHAR_BIT>(static_cast<unsigned int>(bits)) << " depth: " << depth;
    123,320 ( 0.00%)  0           0                    0                0                0                    0              0           0               if (patterns.empty()) {
          .           .           .                    .                .                .                    .              .           .                   return 0;
          .           .           .                    .                .                .                    .              .           .               }
    184,980 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)     184,980 ( 0.00%)  11,043 ( 0.03%)       0                    0              0           0               const auto first_pattern = patterns.front();
    184,980 ( 0.00%)  0           0              123,320 ( 0.00%)       0                0                    0              0           0               if (depth == first_pattern.depth) {
    117,760 ( 0.00%)  0           0                    0                0                0               58,880 ( 0.00%)     1 ( 0.00%)  0                   insert_word(std::make_shared<CodeWord>(code, static_cast<uint8_t>(bits), first_pattern.value, nullptr, nullptr));
     58,880 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0                    0              0           0                   return 1;
          .           .           .                    .                .                .                    .              .           .               }
     64,440 ( 0.00%)  0           0                    0                0                0                    0              0           0               if (bits == kMaxTableBitLength) {
          .           .           .                    .                .                .                    .              .           .                   auto new_table{std::make_unique<PatternTable>(highest_depth)};
     11,136 ( 0.00%)  0           0                    0                0                0                2,784 ( 0.00%)     0           0                   const auto last_cw = insert_word(std::make_shared<CodeWord>(code, 0, ByteView{}, std::move(new_table), nullptr));
     33,408 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)      13,920 ( 0.00%)       0                0                5,568 ( 0.00%)     0           0                   return last_cw->table()->build_condensed(patterns, highest_depth, 0, 0, depth);
          .           .           .                    .                .                .                    .              .           .               }
    441,540 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)      88,308 ( 0.00%)       0                0              117,744 ( 0.00%)     0           0               const auto b0 = build_condensed(patterns, highest_depth - 1, code, bits + 1, depth + 1);
    412,104 ( 0.00%)  0           0              117,744 ( 0.00%)       0                0               58,872 ( 0.00%)     0           0               return b0 + build_condensed(patterns.subspan(b0), highest_depth - 1, static_cast<uint16_t>((1 << bits) | code), bits + 1, depth + 1);
    739,920 ( 0.00%)  7 ( 0.04%)  4 ( 0.04%)     554,940 ( 0.01%)   1,330 ( 0.00%)       0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
    322,240 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0              193,344 ( 0.01%)     1 ( 0.00%)  0           CodeWord* PatternTable::insert_word(std::shared_ptr<CodeWord> codeword) {
          .           .           .                    .                .                .                    .              .           .               CodeWord* inserted{nullptr};
     96,672 ( 0.00%)  0           0               64,448 ( 0.00%)      55 ( 0.00%)       0                    0              0           0               if (bit_length_ <= condensed_table_bit_length_threshold_) {
     64,448 ( 0.00%)  0           0                    0                0                0                    0              0           0                   const auto code_step = 1 << codeword->code_length();
          .           .           .                    .                .                .                    .              .           .                   const auto code_from = codeword->code();
          .           .           .                    .                .                .                    .              .           .                   const auto code_to =
    244,696 ( 0.00%)  8 ( 0.05%)  4 ( 0.04%)      51,352 ( 0.00%)       0                0               57,900 ( 0.00%)   802 ( 0.03%) 21 ( 0.00%)              bit_length_ != codeword->code_length() && codeword->code_length() > 0 ? code_from | 1 << bit_length_ : code_from + code_step;
  1,489,896 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)     712,724 ( 0.01%)       0                0               32,224 ( 0.00%)     0           0                   for (auto c{code_from}; c < code_to; c += code_step) {
    340,250 ( 0.00%)  0           0                    0                0                0                    0              0           0                       auto* cw = codewords_[c].get();
    680,500 ( 0.00%)  0           0                    0                0                0                    0              0           0                       if (cw == nullptr) {
          .           .           .                    .                .                .                    .              .           .                           codewords_[c] = codeword;
          .           .           .                    .                .                .                    .              .           .                           inserted = codewords_[c].get();
          .           .           .                    .                .                .                    .              .           .                       } else {
          .           .           .                    .                .                .                    .              .           .                           cw->reset_content(c, codeword->code_length(), codeword->pattern());
          .           .           .                    .                .                .                    .              .           .                           inserted = cw;
          .           .           .                    .                .                .                    .              .           .                       }
          .           .           .                    .                .                .                    .              .           .                   }
          .           .           .                    .                .                .                    .              .           .               } else {
-- line 176 ----------------------------------------
-- line 182 ----------------------------------------
          .           .           .                    .                .                .                    .              .           .                   } else {
          .           .           .                    .                .                .                    .              .           .                       SILKWORM_ASSERT(!codewords_.empty());
          .           .           .                    .                .                .                    .              .           .                       codewords_.push_back(std::move(codeword));
          .           .           .                    .                .                .                    .              .           .                       inserted = codewords_.back().get();
          .           .           .                    .                .                .                    .              .           .                   }
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               return inserted;
    290,016 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)     225,568 ( 0.00%)       0                0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
205,514,670 ( 0.66%)  2 ( 0.01%)  2 ( 0.02%)           0                0                0          123,308,802 ( 4.43%)     0           0           const CodeWord* PatternTable::search_condensed(uint16_t code) const {
123,308,802 ( 0.40%)  0           0           82,205,868 ( 1.25%)       5 ( 0.00%)       2 ( 0.00%)           0              0           0               if (bit_length_ <= condensed_table_bit_length_threshold_) {
 41,102,934 ( 0.13%)  0           0                    0                0                0                    0              0           0                   return codeword(code);
          .           .           .                    .                .                .                    .              .           .               } else {
          .           .           .                    .                .                .                    .              .           .                   CodeWord* previous{nullptr};
          .           .           .                    .                .                .                    .              .           .                   for (auto* current = head_; current != nullptr; previous = current, current = current->next()) {
          .           .           .                    .                .                .                    .              .           .                       if (current->code() == code) {
          .           .           .                    .                .                .                    .              .           .                           if (previous != nullptr) {
          .           .           .                    .                .                .                    .              .           .                               previous->set_next(current->next());
          .           .           .                    .                .                .                    .              .           .                               current->set_next(head_);
          .           .           .                    .                .                .                    .              .           .                               head_ = current;
-- line 202 ----------------------------------------
-- line 213 ----------------------------------------
          .           .           .                    .                .                .                    .              .           .                               current->set_next(head_);
          .           .           .                    .                .                .                    .              .           .                               head_ = current;
          .           .           .                    .                .                .                    .              .           .                           }
          .           .           .                    .                .                .                    .              .           .                           return current;
          .           .           .                    .                .                .                    .              .           .                       }
          .           .           .                    .                .                .                    .              .           .                   }
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               return nullptr;
205,514,670 ( 0.66%)  0           0          164,411,736 ( 2.49%)       0                0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           bool PatternTable::check_distance(std::size_t power, int distance) {
          .           .           .                    .                .                .                    .              .           .               const auto& distances = PatternTable::word_distances_[power];
          .           .           .                    .                .                .                    .              .           .               auto it = std::find_if(distances.cbegin(), distances.cend(), [distance](const int d) {
          .           .           .                    .                .                .                    .              .           .                   return d == distance;
          .           .           .                    .                .                .                    .              .           .               });
          .           .           .                    .                .                .                    .              .           .               return it != distances.cend();
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
      3,556 ( 0.00%)  0           0                    0                0                0                1,524 ( 0.00%)     0           0           PositionTable::PositionTable(std::size_t max_depth) : DecodingTable(max_depth) {
        508 ( 0.00%)  0           0                    0                0                0                    0              0           0               positions_.resize(std::size_t(1) << bit_length_);
      1,016 ( 0.00%)  0           0                  254 ( 0.00%)       0                0                    0              0           0               lengths_.resize(std::size_t(1) << bit_length_);
      1,270 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)         254 ( 0.00%)       0                0                    0              0           0               children_.resize(std::size_t(1) << bit_length_);
      2,032 ( 0.00%)  0           0                1,778 ( 0.00%)       0                0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           int PositionTable::build(std::span<Position> positions) {
         12 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)           4 ( 0.00%)       0                0                    4 ( 0.00%)     0           0               return build_tree(positions, max_depth_, 0, 0, 0);
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
    129,796 ( 0.00%) 19 ( 0.11%) 10 ( 0.11%)      14,424 ( 0.00%)       0                0               67,296 ( 0.00%)   479 ( 0.02%) 14 ( 0.00%)  int PositionTable::build_tree(std::span<Position> positions, uint64_t highest_depth, uint16_t code, int bits, uint64_t depth) {
     19,232 ( 0.00%)  0           0                    0                0                0                4,808 ( 0.00%)   134 ( 0.00%)  5 ( 0.00%)      SILK_DEBUG << "build_tree #positions: " << positions.size() << " highest_depth: " << highest_depth << " code: " << code
          .           .           .                    .                .                .                    .              .           .                          << " bits: " << std::bitset<CHAR_BIT>(static_cast<unsigned int>(bits)) << " depth: " << depth;
      9,616 ( 0.00%)  0           0                4,804 ( 0.00%)       0                0                    0              0           0               if (positions.empty()) {
          4 ( 0.00%)  0           0                    0                0                0                    0              0           0                   return 0;
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               const auto& first_position = positions.front();
     19,228 ( 0.00%)  8 ( 0.05%)  4 ( 0.04%)      14,420 ( 0.00%)     555 ( 0.00%)       0                    0              0           0               if (depth == first_position.depth) {
     11,405 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)       6,843 ( 0.00%)       4 ( 0.00%)       0                    0              0           0                   if (bit_length_ == static_cast<std::size_t>(bits)) {
      5,820 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)       3,880 ( 0.00%)       0                0                  970 ( 0.00%)    20 ( 0.00%)  0                       positions_[code] = first_position.value;
      4,221 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)       1,940 ( 0.00%)       3 ( 0.00%)       0                2,281 ( 0.00%)    10 ( 0.00%)  0                       lengths_[code] = static_cast<uint8_t>(bits);
          .           .           .                    .                .                .                    .              .           .                       children_[code] = nullptr;
          .           .           .                    .                .                .                    .              .           .                   } else {
      5,244 ( 0.00%)  0           0                1,311 ( 0.00%)       0                0                    0              0           0                       const auto code_step = 1 << bits;
          .           .           .                    .                .                .                    .              .           .                       const auto code_from = code;
      5,244 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)       2,622 ( 0.00%)       0                0                2,622 ( 0.00%)   206 ( 0.01%)  9 ( 0.00%)              const auto code_to = code_from | 1 << bit_length_;
    116,144 ( 0.00%)  6 ( 0.04%)  4 ( 0.04%)      88,720 ( 0.00%)       0                0                1,311 ( 0.00%)     0           0                       for (auto c{code_from}; c < code_to; c += code_step) {
    133,080 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)     110,900 ( 0.00%)       0                0               22,180 ( 0.00%)   516 ( 0.02%)  0                           positions_[c] = first_position.value;
     66,540 ( 0.00%)  0           0               44,360 ( 0.00%)       0                0               22,180 ( 0.00%)    41 ( 0.00%)  0                           lengths_[c] = static_cast<uint8_t>(bits);
          .           .           .                    .                .                .                    .              .           .                           children_[c] = nullptr;
          .           .           .                    .                .                .                    .              .           .                       }
          .           .           .                    .                .                .                    .              .           .                   }
      2,281 ( 0.00%)  0           0                    0                0                0                    0              0           0                   return 1;
          .           .           .                    .                .                .                    .              .           .               }
      5,046 ( 0.00%)  0           0                2,523 ( 0.00%)       0                0                    0              0           0               if (bits == kMaxTableBitLength) {
          .           .           .                    .                .                .                    .              .           .                   auto child_table{std::make_unique<PositionTable>(highest_depth)};
      1,250 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)         500 ( 0.00%)       0                0                  500 ( 0.00%)    54 ( 0.00%)  0                   positions_[code] = 0;
        500 ( 0.00%)  0           0                  250 ( 0.00%)       0                0                  250 ( 0.00%)    11 ( 0.00%)  0                   lengths_[code] = 0;
          .           .           .                    .                .                .                    .              .           .                   children_[code] = std::move(child_table);
      2,500 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)       1,000 ( 0.00%)       0                0                  500 ( 0.00%)     0           0                   return children_[code]->build_tree(positions, highest_depth, 0, 0, depth);
          .           .           .                    .                .                .                    .              .           .               }
     36,420 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)      11,373 ( 0.00%)       0                0                6,827 ( 0.00%)    15 ( 0.00%)  0               const int b0 = build_tree(positions, highest_depth - 1, code, bits + 1, depth + 1);
     32,362 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)       9,346 ( 0.00%)      21 ( 0.00%)       0                4,554 ( 0.00%)     4 ( 0.00%)  0               return b0 + build_tree(positions.subspan(static_cast<std::size_t>(b0)), highest_depth - 1, static_cast<uint16_t>((1 << bits) | code), bits + 1, depth + 1);
     52,888 ( 0.00%) 12 ( 0.07%)  6 ( 0.06%)      43,272 ( 0.00%)     122 ( 0.00%)       0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           std::ostream& operator<<(std::ostream& out, const PositionTable& pt) {
          .           .           .                    .                .                .                    .              .           .               out << "Position Table:\n";
          .           .           .                    .                .                .                    .              .           .               out << "bit length: " << pt.bit_length_ << "\n";
          .           .           .                    .                .                .                    .              .           .               out << std::setfill('0');
          .           .           .                    .                .                .                    .              .           .               for (std::size_t i{0}; i < pt.positions_.size(); ++i) {
          .           .           .                    .                .                .                    .              .           .                   const uint64_t position = pt.positions_[i];
          .           .           .                    .                .                .                    .              .           .                   const uint64_t length = pt.lengths_[i];
-- line 282 ----------------------------------------
-- line 287 ----------------------------------------
          .           .           .                    .                .                .                    .              .           .                   } else {
          .           .           .                    .                .                .                    .              .           .                       out << " child: NULL\n";
          .           .           .                    .                .                .                    .              .           .                   }
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               out << std::dec;
          .           .           .                    .                .                .                    .              .           .               return out;
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
         16 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)           0                0                0                    4 ( 0.00%)     0           0           Decompressor::Decompressor(std::filesystem::path compressed_path, std::optional<MemoryMappedRegion> compressed_region)
         40 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)          16 ( 0.00%)       0                0                   20 ( 0.00%)     2 ( 0.00%)  0               : compressed_path_(std::move(compressed_path)), compressed_region_{std::move(compressed_region)} {}
          .           .           .                    .                .                .                    .              .           .           
         36 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           0                0                0                   24 ( 0.00%)     0           0           Decompressor::~Decompressor() {
          .           .           .                    .                .                .                    .              .           .               close();
         28 ( 0.00%)  0           0                   24 ( 0.00%)       4 ( 0.00%)       0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
         52 ( 0.00%)  8 ( 0.05%)  4 ( 0.04%)           4 ( 0.00%)       0                0                   28 ( 0.00%)     0           0           void Decompressor::open() {
          .           .           .                    .                .                .                    .              .           .               compressed_file_ = std::make_unique<MemoryMappedFile>(compressed_path_, compressed_region_);
          8 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           4 ( 0.00%)       0                0                    0              0           0               if (compressed_file_->length() < kMinimumFileSize) {
          .           .           .                    .                .                .                    .              .           .                   throw std::runtime_error("compressed file is too short: " + std::to_string(compressed_file_->length()));
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               const auto address = compressed_file_->address();
          .           .           .                    .                .                .                    .              .           .           
          4 ( 0.00%)  0           0                    0                0                0                    4 ( 0.00%)     0           0               compressed_file_->advise_sequential();
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Read header from compressed file
          4 ( 0.00%)  0           0                    0                0                0                    4 ( 0.00%)     0           0               words_count_ = endian::load_big_u64(address);
          4 ( 0.00%)  0           0                    0                0                0                    4 ( 0.00%)     0           0               empty_words_count_ = endian::load_big_u64(address + kWordsCountSize);
         16 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0                    4 ( 0.00%)     0           0               SILK_DEBUG << "Decompress words count: " << words_count_ << " empty words count: " << empty_words_count_;
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Read patterns from compressed file
          .           .           .                    .                .                .                    .              .           .               const auto pattern_dict_length = endian::load_big_u64(address + kWordsCountSize + kEmptyWordsCountSize);
         16 ( 0.00%)  0           0                    0                0                0                    4 ( 0.00%)     0           0               SILK_DEBUG << "Decompress pattern dictionary length: " << pattern_dict_length;
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               const std::size_t patterns_dict_offset{kWordsCountSize + kEmptyWordsCountSize + kDictionaryLengthSize};
         20 ( 0.00%)  8 ( 0.05%)  4 ( 0.04%)           4 ( 0.00%)       0                0                    4 ( 0.00%)     0           0               read_patterns(ByteView{address + patterns_dict_offset, pattern_dict_length});
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Read positions from compressed file
          .           .           .                    .                .                .                    .              .           .               const auto position_dict_length = endian::load_big_u64(address + patterns_dict_offset + pattern_dict_length);
         16 ( 0.00%)  0           0                    0                0                0                    4 ( 0.00%)     0           0               SILK_DEBUG << "Decompress position dictionary length: " << position_dict_length;
          .           .           .                    .                .                .                    .              .           .           
          8 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           4 ( 0.00%)       0                0                    0              0           0               const std::size_t positions_dict_offset{patterns_dict_offset + pattern_dict_length + kDictionaryLengthSize};
         16 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)           4 ( 0.00%)       0                0                    4 ( 0.00%)     0           0               read_positions(ByteView{address + positions_dict_offset, position_dict_length});
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Store the start offset and length of the data words
         12 ( 0.00%)  0           0                    4 ( 0.00%)       3 ( 0.00%)       0                    4 ( 0.00%)     2 ( 0.00%)  0               words_start_ = address + positions_dict_offset + position_dict_length;
         12 ( 0.00%)  0           0                    0                0                0                    4 ( 0.00%)     1 ( 0.00%)  0               words_length_ = compressed_file_->length() - (positions_dict_offset + position_dict_length);
          8 ( 0.00%)  0           0                    4 ( 0.00%)       0                0                    0              0           0               SILKWORM_ASSERT(address + compressed_file_->length() == words_start_ + words_length_);
         16 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0                    4 ( 0.00%)     0           0               SILK_DEBUG << "Decompressor words start offset: " << (words_start_ - address) << " words length: " << words_length_
          .           .           .                    .                .                .                    .              .           .                          << " total length: " << compressed_file_->length();
          .           .           .                    .                .                .                    .              .           .           
         20 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)          12 ( 0.00%)       4 ( 0.00%)       0                    0              0           0               compressed_file_->advise_random();
         28 ( 0.00%)  0           0                   24 ( 0.00%)       4 ( 0.00%)       0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
         13 ( 0.00%)  2 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       0                0                    6 ( 0.00%)     0           0           bool Decompressor::read_ahead(ReadAheadFuncRef fn) {
          .           .           .                    .                .                .                    .              .           .               ensure(bool(compressed_file_), "decompressor closed, call open first");
          3 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           1 ( 0.00%)       0                0                    2 ( 0.00%)     0           0               compressed_file_->advise_sequential();
          2 ( 0.00%)  0           0                    1 ( 0.00%)       1 ( 0.00%)       1 ( 0.00%)           1 ( 0.00%)     0           0               [[maybe_unused]] auto _ = gsl::finally([&]() { compressed_file_->advise_random(); });
          .           .           .                    .                .                .                    .              .           .               Iterator it{this};
          .           .           .                    .                .                .                    .              .           .               return fn(it);
         11 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)           8 ( 0.00%)       2 ( 0.00%)       2 ( 0.00%)           0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
         18 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)           0                0                0                    9 ( 0.00%)     0           0           void Decompressor::close() {
          .           .           .                    .                .                .                    .              .           .               compressed_file_.reset();
         15 ( 0.00%)  2 ( 0.01%)  1 ( 0.01%)          15 ( 0.00%)       0                0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
         60 ( 0.00%)  8 ( 0.05%)  4 ( 0.04%)           4 ( 0.00%)       0                0                   40 ( 0.00%)     0           0           void Decompressor::read_patterns(ByteView dict) {
          .           .           .                    .                .                .                    .              .           .               // Check the dictionary size to prevent overflow in pb::ArrayInputStream constructor
          8 ( 0.00%)  0           0                    0                0                0                    0              0           0               if (dict.length() > std::numeric_limits<int>::max()) {
          .           .           .                    .                .                .                    .              .           .                   throw std::runtime_error("dict is too long: " + std::to_string(dict.length()));
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Compression uses Google ProtocolBuffers encoding (see also Go "varint" encoding)
         32 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           4 ( 0.00%)       0                0                    8 ( 0.00%)     0           0               pb::ArrayInputStream raw_input{dict.data(), static_cast<int>(dict.length())};
          .           .           .                    .                .                .                    .              .           .               pb::CodedInputStream coded_input{&raw_input};
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               std::vector<Pattern> patterns;
          .           .           .                    .                .                .                    .              .           .               patterns.reserve(kMaxTablePatterns);
          4 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)           0                0                0                    4 ( 0.00%)     0           0               uint64_t pattern_highest_depth{0};
    206,108 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)      29,444 ( 0.00%)       0                0               29,444 ( 0.00%)     0           0               while (coded_input.CurrentPosition() < raw_input.ByteCount()) {
          .           .           .                    .                .                .                    .              .           .                   uint64_t pattern_depth{0};
          .           .           .                    .                .                .                    .              .           .                   bool read_ok = coded_input.ReadVarint64(&pattern_depth);
          .           .           .                    .                .                .                    .              .           .                   if (!read_ok) {
          .           .           .                    .                .                .                    .              .           .                       throw std::runtime_error{"pattern dict is invalid: depth read failed at " + std::to_string(coded_input.CurrentPosition())};
          .           .           .                    .                .                .                    .              .           .                   }
    117,760 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)           0                0                0               29,440 ( 0.00%)     0           0                   SILK_DEBUG << "pattern depth: " << pattern_depth << " coded input position: " << coded_input.CurrentPosition();
     58,880 ( 0.00%)  0           0               29,440 ( 0.00%)       0                0                    0              0           0                   if (pattern_depth > kMaxAllowedDepth) {
          .           .           .                    .                .                .                    .              .           .                       throw std::runtime_error{"pattern dict is invalid: pattern depth " + std::to_string(pattern_depth) +
          .           .           .                    .                .                .                    .              .           .                                                " is greater than max allowed: " + std::to_string(kMaxAllowedDepth)};
          .           .           .                    .                .                .                    .              .           .                   }
    117,760 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)      58,880 ( 0.00%)       0                0                    0              0           0                   if (pattern_depth > pattern_highest_depth) {
          .           .           .                    .                .                .                    .              .           .                       pattern_highest_depth = pattern_depth;
        175 ( 0.00%)  0           0                    0                0                0                   70 ( 0.00%)     0           0                       SILK_DEBUG << "pattern highest depth: " << pattern_highest_depth;
          .           .           .                    .                .                .                    .              .           .                   }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .                   uint64_t pattern_data_length{0};
          .           .           .                    .                .                .                    .              .           .                   read_ok = coded_input.ReadVarint64(&pattern_data_length);
         30 ( 0.00%)  0           0                    0                0                0                    0              0           0                   if (!read_ok) {
          .           .           .                    .                .                .                    .              .           .                       throw std::runtime_error{"pattern dict is invalid: length read failed at " + std::to_string(coded_input.CurrentPosition())};
          .           .           .                    .                .                .                    .              .           .                   }
         45 ( 0.00%)  0           0                    0                0                0                    0              0           0                   if (pattern_data_length > std::numeric_limits<int>::max()) {
          .           .           .                    .                .                .                    .              .           .                       throw std::runtime_error{"pattern data length is too long: " + std::to_string(pattern_data_length)};
          .           .           .                    .                .                .                    .              .           .                   }
    117,760 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0               29,440 ( 0.00%)     0           0                   SILK_DEBUG << "pattern data length: " << pattern_data_length << " coded input position: " << coded_input.CurrentPosition();
          .           .           .                    .                .                .                    .              .           .           
     88,320 ( 0.00%)  0           0               29,440 ( 0.00%)       0                0               29,440 ( 0.00%)     0           0                   ByteView pattern_data{dict.data() + coded_input.CurrentPosition(), pattern_data_length};
     29,440 ( 0.00%)  0           0                    0                0                0                    0              0           0                   read_ok = coded_input.Skip(static_cast<int>(pattern_data_length));
          .           .           .                    .                .                .                    .              .           .                   if (!read_ok) {
          .           .           .                    .                .                .                    .              .           .                       throw std::runtime_error{"pattern dict is invalid: data skip failed at " + std::to_string(coded_input.CurrentPosition())};
          .           .           .                    .                .                .                    .              .           .                   }
    117,760 ( 0.00%)  0           0                    0                0                0               29,440 ( 0.00%)     0           0                   SILK_DEBUG << "count: " << patterns.size() << " data size: " << pattern_data.size() << " coded input position: " << coded_input.CurrentPosition();
          .           .           .                    .                .                .                    .              .           .           
    176,640 ( 0.00%)  0           0               58,880 ( 0.00%)       0                0               58,880 ( 0.00%)     0           0                   patterns.emplace_back(Pattern{pattern_depth, pattern_data});
          .           .           .                    .                .                .                    .              .           .               }
         24 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)           4 ( 0.00%)       0                0                    4 ( 0.00%)     0           0               if (coded_input.CurrentPosition() != raw_input.ByteCount()) {
          .           .           .                    .                .                .                    .              .           .                   throw std::runtime_error{"pattern stream not exhausted: " + std::to_string(raw_input.ByteCount() - coded_input.CurrentPosition())};
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .           
         48 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)           8 ( 0.00%)       8 ( 0.00%)       0                    8 ( 0.00%)     0           0               SILK_DEBUG << "Pattern count: " << patterns.size() << " highest depth: " << pattern_highest_depth;
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               pattern_dict_ = std::make_unique<PatternTable>(pattern_highest_depth);
          8 ( 0.00%)  0           0                    4 ( 0.00%)       0                0                    0              0           0               if (dict.length() > 0) {
          .           .           .                    .                .                .                    .              .           .                   pattern_dict_->build_condensed({patterns.data(), patterns.size()});
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .           
         16 ( 0.00%)  0           0                    0                0                0                    4 ( 0.00%)     0           0               SILK_DEBUG << "#codewords: " << pattern_dict_->num_codewords();
         16 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0                    4 ( 0.00%)     0           0               SILK_TRACE << *pattern_dict_;
         52 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)          36 ( 0.00%)       8 ( 0.00%)       0                    4 ( 0.00%)     0           0           }
          .           .           .                    .                .                .                    .              .           .           
         52 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           4 ( 0.00%)       0                0                   36 ( 0.00%)     1 ( 0.00%)  0           void Decompressor::read_positions(ByteView dict) {
          .           .           .                    .                .                .                    .              .           .               // Check the dictionary size to prevent overflow in pb::ArrayInputStream constructor
         12 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0                    0              0           0               if (dict.length() > std::numeric_limits<int>::max()) {
          .           .           .                    .                .                .                    .              .           .                   throw std::runtime_error("position dict is too long: " + std::to_string(dict.length()));
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Compression uses Google ProtocolBuffers encoding (see also Go "varint" encoding)
         20 ( 0.00%)  0           0                    4 ( 0.00%)       0                0                    4 ( 0.00%)     0           0               pb::ArrayInputStream raw_input{dict.data(), static_cast<int>(dict.length())};
          .           .           .                    .                .                .                    .              .           .               pb::CodedInputStream coded_input{&raw_input};
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               std::vector<Position> positions;
          .           .           .                    .                .                .                    .              .           .               positions.reserve(kMaxTablePositions);
          4 ( 0.00%)  0           0                    0                0                0                    0              0           0               uint64_t position_highest_depth{0};
     13,710 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)           0                0                0                2,285 ( 0.00%)     0           0               while (coded_input.CurrentPosition() < raw_input.ByteCount()) {
          .           .           .                    .                .                .                    .              .           .                   uint64_t position_depth{0};
          .           .           .                    .                .                .                    .              .           .                   bool read_ok = coded_input.ReadVarint64(&position_depth);
          .           .           .                    .                .                .                    .              .           .                   if (!read_ok) {
          .           .           .                    .                .                .                    .              .           .                       throw std::runtime_error("position dict is invalid: depth read failed at " + std::to_string(coded_input.CurrentPosition()));
          .           .           .                    .                .                .                    .              .           .                   }
      9,124 ( 0.00%)  0           0                    0                0                0                2,281 ( 0.00%)     0           0                   SILK_DEBUG << "position depth: " << position_depth << " coded input position: " << coded_input.CurrentPosition();
      4,562 ( 0.00%)  0           0                    0                0                0                    0              0           0                   if (position_depth > kMaxAllowedDepth) {
          .           .           .                    .                .                .                    .              .           .                       throw std::runtime_error{"position dict is invalid: position depth " + std::to_string(position_depth) +
          .           .           .                    .                .                .                    .              .           .                                                " is greater than max allowed: " + std::to_string(kMaxAllowedDepth)};
          .           .           .                    .                .                .                    .              .           .                   }
      4,562 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0                    0              0           0                   if (position_depth > position_highest_depth) {
          .           .           .                    .                .                .                    .              .           .                       position_highest_depth = position_depth;
        200 ( 0.00%)  0           0                    0                0                0                   40 ( 0.00%)     0           0                       SILK_DEBUG << "position highest depth: " << position_highest_depth;
          .           .           .                    .                .                .                    .              .           .                   }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .                   uint64_t position{0};
          .           .           .                    .                .                .                    .              .           .                   read_ok = coded_input.ReadVarint64(&position);
      3,702 ( 0.00%)  0           0                    0                0                0                    0              0           0                   if (!read_ok) {
          .           .           .                    .                .                .                    .              .           .                       throw std::runtime_error("position dict is invalid: position read failed at " + std::to_string(coded_input.CurrentPosition()));
          .           .           .                    .                .                .                    .              .           .                   }
      5,553 ( 0.00%)  0           0                    0                0                0                    0              0           0                   if (position > std::numeric_limits<int>::max()) {
          .           .           .                    .                .                .                    .              .           .                       throw std::runtime_error("position is too long: " + std::to_string(position));
          .           .           .                    .                .                .                    .              .           .                   }
      9,124 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                0                0                2,281 ( 0.00%)     0           0                   SILK_DEBUG << "count: " << positions.size() << " position: " << position << " coded input position: " << coded_input.CurrentPosition();
          .           .           .                    .                .                .                    .              .           .           
      6,843 ( 0.00%)  0           0                2,281 ( 0.00%)       0                0                2,281 ( 0.00%)     0           0                   positions.emplace_back(Position{position_depth, position});
          .           .           .                    .                .                .                    .              .           .               }
         20 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           0                0                0                    4 ( 0.00%)     0           0               if (coded_input.CurrentPosition() != raw_input.ByteCount()) {
          .           .           .                    .                .                .                    .              .           .                   throw std::runtime_error{"position stream not exhausted: " + std::to_string(raw_input.ByteCount() - coded_input.CurrentPosition())};
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .           
         40 ( 0.00%)  0           0                    8 ( 0.00%)       2 ( 0.00%)       0                    4 ( 0.00%)     0           0               SILK_DEBUG << "Position count: " << positions.size() << " highest depth: " << position_highest_depth;
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               position_dict_ = std::make_unique<PositionTable>(position_highest_depth);
          8 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           4 ( 0.00%)       0                0                    0              0           0               if (dict.length() > 0) {
          .           .           .                    .                .                .                    .              .           .                   position_dict_->build({positions.data(), positions.size()});
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .           
         16 ( 0.00%)  0           0                    0                0                0                    4 ( 0.00%)     0           0               SILK_DEBUG << "#positions: " << position_dict_->num_positions();
         16 ( 0.00%)  0           0                    0                0                0                    4 ( 0.00%)     0           0               SILK_TRACE << *position_dict_;
         52 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)          40 ( 0.00%)       8 ( 0.00%)       0                    4 ( 0.00%)     0           0           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           Decompressor::Iterator::Iterator(const Decompressor* decoder) : decoder_(decoder) {}
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           ByteView Decompressor::Iterator::data() const {
  8,039,604 ( 0.03%)  0           0            8,039,604 ( 0.12%)       0                0                    0              0           0               return ByteView{decoder_->words_start_, decoder_->words_length_};
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           [[nodiscard]] bool Decompressor::Iterator::has_prefix(ByteView prefix) {
          .           .           .                    .                .                .                    .              .           .               const auto prefix_size{prefix.size()};
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               const auto start_offset = word_offset_;
          .           .           .                    .                .                .                    .              .           .               [[maybe_unused]] auto _ = gsl::finally([&]() { word_offset_ = start_offset; bit_position_ = 0; });
          .           .           .                    .                .                .                    .              .           .           
-- line 483 ----------------------------------------
-- line 549 ----------------------------------------
          .           .           .                    .                .                .                    .              .           .                       return false;
          .           .           .                    .                .                .                    .              .           .                   }
          .           .           .                    .                .                .                    .              .           .                   post_loop_offset += position_diff;
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               SILK_TRACE << "Iterator::has_prefix word_offset_=" << word_offset_ << "; post_loop_offset=" << post_loop_offset;
          .           .           .                    .                .                .                    .              .           .               return true;
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
  9,000,000 ( 0.03%)  2 ( 0.01%)  2 ( 0.02%)   1,500,000 ( 0.02%)      10 ( 0.00%)       4 ( 0.00%)   3,500,000 ( 0.13%)     0           0           uint64_t Decompressor::Iterator::next(Bytes& buffer) {
  2,000,000 ( 0.01%)  0           0              500,000 ( 0.01%)       0                0            1,000,000 ( 0.04%)     4 ( 0.00%)  2 ( 0.00%)      const auto start_offset = word_offset_;
          .           .           .                    .                .                .                    .              .           .           
  1,000,000 ( 0.00%)  0           0                    0                0                0              500,000 ( 0.02%)     4 ( 0.00%)  2 ( 0.00%)      uint64_t word_length = next_position(true);
  1,000,000 ( 0.00%)  0           0                    0                0                0                    0              0           0               if (word_length == 0) {
          .           .           .                    .                .                .                    .              .           .                   throw std::runtime_error{"invalid zero word length in: " + decoder_->compressed_filename()};
          .           .           .                    .                .                .                    .              .           .               }
  1,000,000 ( 0.00%)  0           0                    0                0                0              500,000 ( 0.02%)     0           0               --word_length;  // because when we create HT we do ++ (0 is terminator)
  2,000,000 ( 0.01%)  1 ( 0.01%)  1 ( 0.01%)           0                0                0              500,000 ( 0.02%)     0           0               SILK_TRACE << "Iterator::next start_offset=" << start_offset << " word_length=" << word_length;
  1,000,000 ( 0.00%)  0           0              500,000 ( 0.01%)       0                0                    0              0           0               if (word_length == 0) {
          .           .           .                    .                .                .                    .              .           .                   if (bit_position_ > 0) {
          .           .           .                    .                .                .                    .              .           .                       ++word_offset_;
          .           .           .                    .                .                .                    .              .           .                       bit_position_ = 0;
          .           .           .                    .                .                .                    .              .           .                   }
          .           .           .                    .                .                .                    .              .           .                   return word_offset_;
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Track position into buffer where to insert part of the word
    500,000 ( 0.00%)  0           0              500,000 ( 0.01%)       0                0                    0              0           0               std::size_t buffer_position = buffer.size();
    500,000 ( 0.00%)  0           0              500,000 ( 0.01%)       0                0                    0              0           0               std::size_t last_uncovered = buffer.size();
  1,000,000 ( 0.00%)  0           0              500,000 ( 0.01%)       0                0                    0              0           0               buffer.resize(buffer.length() + word_length);
  2,000,000 ( 0.01%)  1 ( 0.01%)  1 ( 0.01%)           0                0                0              500,000 ( 0.02%)     0           0               SILK_TRACE << "Iterator::next buffer resized to: " << buffer.length();
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Fill in the patterns
117,333,990 ( 0.38%)  1 ( 0.01%)  1 ( 0.01%)           0                0                0           19,555,665 ( 0.70%)     0           0               for (auto pos{next_position(false)}; pos != 0; pos = next_position(false)) {
          .           .           .                    .                .                .                    .              .           .                   // Positions where to insert patterns are encoded relative to one another
 19,055,665 ( 0.06%)  0           0                    0                0                0                    0              0           0                   buffer_position += pos - 1;
 76,222,660 ( 0.25%)  1 ( 0.01%)  1 ( 0.01%)           0                0                0           19,055,665 ( 0.68%)     0           0                   const ByteView pattern = next_pattern();
 77,222,660 ( 0.25%)  0           0                    0                0                0           19,555,665 ( 0.70%)     0           0                   SILK_TRACE << "Iterator::next data-from-patterns pos=" << pos << " pattern=" << to_hex(pattern);
 38,111,330 ( 0.12%)  0           0                    0                0                0                    0              0           0                   if (buffer_position > buffer.size()) {
          .           .           .                    .                .                .                    .              .           .                       return word_offset_;
          .           .           .                    .                .                .                    .              .           .                   }
 95,278,325 ( 0.31%)  2 ( 0.01%)  2 ( 0.02%)  19,055,665 ( 0.29%)       0                0                    0              0           0                   pattern.copy(buffer.data() + buffer_position, std::min(pattern.size(), buffer.size() - buffer_position));
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               if (bit_position_ > 0) {
  1,500,000 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)   1,000,000 ( 0.02%)       0                0                    0              0           0                   ++word_offset_;
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               uint64_t post_loop_offset = word_offset_;
  1,000,000 ( 0.00%)  0           0              500,000 ( 0.01%)      33 ( 0.00%)       0              500,000 ( 0.02%)     0           0               word_offset_ = start_offset;
    500,000 ( 0.00%)  0           0                    0                0                0              500,000 ( 0.02%)     0           0               bit_position_ = 0;
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Reset the iterator state
  1,500,000 ( 0.00%)  0           0                    0                0                0              500,000 ( 0.02%)     0           0               (void)next_position(true);
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Restore the beginning of buffer
          .           .           .                    .                .                .                    .              .           .               buffer_position = last_uncovered;
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .               // Fill in data which is not the patterns
117,333,990 ( 0.38%)  0           0                    0                0                0           19,555,665 ( 0.70%)     0           0               for (auto pos{next_position(false)}; pos != 0; pos = next_position(false)) {
          .           .           .                    .                .                .                    .              .           .                   // Positions where to insert patterns are encoded relative to one another
 57,166,995 ( 0.18%)  1 ( 0.01%)  1 ( 0.01%)  19,055,665 ( 0.29%)       0                0           19,055,665 ( 0.68%)     0           0                   buffer_position += pos - 1;
 38,111,330 ( 0.12%)  0           0                    0                0                0                    0              0           0                   if (buffer_position > last_uncovered) {
  4,359,736 ( 0.01%)  0           0                    0                0                0            2,179,868 ( 0.08%)     0           0                       std::size_t position_diff = buffer_position - last_uncovered;
  8,719,472 ( 0.03%)  0           0                    0                0                0            2,179,868 ( 0.08%)     0           0                       SILK_TRACE << "Iterator::next other-data pos=" << pos << " last_uncovered=" << last_uncovered
          .           .           .                    .                .                .                    .              .           .                                  << " buffer_position=" << buffer_position << " position_diff=" << position_diff
          .           .           .                    .                .                .                    .              .           .                                  << " data=" << to_hex(ByteView{data().data() + post_loop_offset, position_diff});
  6,539,604 ( 0.02%)  0           0            2,179,868 ( 0.03%)       0                0                    0              0           0                       data().copy(buffer.data() + last_uncovered, std::min(position_diff, buffer.size() - last_uncovered), post_loop_offset);
  2,179,868 ( 0.01%)  0           0            2,179,868 ( 0.03%)       0                0                    0              0           0                       post_loop_offset += position_diff;
          .           .           .                    .                .                .                    .              .           .                   }
 76,222,660 ( 0.25%)  0           0           19,055,665 ( 0.29%)       0                0           19,055,665 ( 0.68%)     0           0                   last_uncovered = buffer_position + next_pattern().size();
          .           .           .                    .                .                .                    .              .           .               }
  1,500,000 ( 0.00%)  0           0              500,000 ( 0.01%)       0                0                    0              0           0               if (word_length > last_uncovered) {
  1,000,000 ( 0.00%)  0           0                    0                0                0                    0              0           0                   std::size_t position_diff = word_length - last_uncovered;
  2,000,000 ( 0.01%)  1 ( 0.01%)  1 ( 0.01%)           0                0                0              500,000 ( 0.02%)     0           0                   SILK_TRACE << "Iterator::next other-data last_uncovered=" << last_uncovered
          .           .           .                    .                .                .                    .              .           .                              << " buffer_position=" << buffer_position << " position_diff=" << position_diff
          .           .           .                    .                .                .                    .              .           .                              << " data=" << to_hex(ByteView{data().data() + post_loop_offset, position_diff});
  2,500,000 ( 0.01%)  0           0              500,000 ( 0.01%)       0                0                    0              0           0                   data().copy(buffer.data() + last_uncovered, std::min(position_diff, buffer.size() - last_uncovered), post_loop_offset);
    500,000 ( 0.00%)  0           0                    0                0                0                    0              0           0                   post_loop_offset += position_diff;
          .           .           .                    .                .                .                    .              .           .               }
    500,000 ( 0.00%)  0           0                    0                0                0              500,000 ( 0.02%)     0           0               word_offset_ = post_loop_offset;
    500,000 ( 0.00%)  0           0                    0                0                0              500,000 ( 0.02%)     0           0               bit_position_ = 0;
  2,000,000 ( 0.01%)  0           0                    0                0                0              500,000 ( 0.02%)     0           0               SILK_TRACE << "Iterator::next word_offset_=" << word_offset_;
          .           .           .                    .                .                .                    .              .           .               return post_loop_offset;
  6,000,000 ( 0.02%)  0           0            4,500,000 ( 0.07%)       0                0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           uint64_t Decompressor::Iterator::next_uncompressed(Bytes& buffer) {
          .           .           .                    .                .                .                    .              .           .               uint64_t word_length = next_position(true);
          .           .           .                    .                .                .                    .              .           .               if (word_length == 0) {
          .           .           .                    .                .                .                    .              .           .                   throw std::runtime_error{"invalid zero word length in: " + decoder_->compressed_filename()};
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               --word_length;  // because when we create HT we do ++ (0 is terminator)
          .           .           .                    .                .                .                    .              .           .               if (word_length == 0) {
-- line 638 ----------------------------------------
-- line 719 ----------------------------------------
          .           .           .                    .                .                .                    .              .           .               return word_offset_;
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           void Decompressor::Iterator::reset(uint64_t data_offset) {
          .           .           .                    .                .                .                    .              .           .               word_offset_ = data_offset;
          .           .           .                    .                .                .                    .              .           .               bit_position_ = 0;
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
457,335,960 ( 1.47%)  2 ( 0.01%)  2 ( 0.02%)  38,111,330 ( 0.58%)       0                0          266,779,310 ( 9.58%)     0           0           ByteView Decompressor::Iterator::next_pattern() {
 38,111,330 ( 0.12%)  0           0           38,111,330 ( 0.58%)       0                0                    0              0           0               const PatternTable* table = decoder_->pattern_dict_.get();
 76,222,660 ( 0.25%)  0           0                    0                0                0                    0              0           0               if (table->bit_length() == 0) {
          .           .           .                    .                .                .                    .              .           .                   return table->codeword(0)->pattern();
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               uint8_t length{0};
          .           .           .                    .                .                .                    .              .           .               ByteView pattern{};
          .           .           .                    .                .                .                    .              .           .               while (length == 0) {
          .           .           .                    .                .                .                    .              .           .                   const uint16_t code = next_code(table->bit_length());
          .           .           .                    .                .                .                    .              .           .           
123,308,802 ( 0.40%)  0           0                    0                0                0           41,102,934 ( 1.48%)     4 ( 0.00%)  2 ( 0.00%)          const auto* codeword{table->search_condensed(code)};
 82,205,868 ( 0.26%)  0           0                    0                0                0                    0              0           0                   if (codeword == nullptr) {
          .           .           .                    .                .                .                    .              .           .                       const auto error_msg =
          .           .           .                    .                .                .                    .              .           .                           "Unexpected missing codeword for code: " + std::to_string(code) +
          .           .           .                    .                .                .                    .              .           .                           " in snapshot: " + decoder_->compressed_path().string();
          .           .           .                    .                .                .                    .              .           .                       SILK_ERROR << error_msg;
          .           .           .                    .                .                .                    .              .           .                       throw std::runtime_error{error_msg};
          .           .           .                    .                .                .                    .              .           .                   }
          .           .           .                    .                .                .                    .              .           .                   length = codeword->code_length();
 82,205,868 ( 0.26%)  0           0                    0                0                0                    0              0           0                   if (length == 0) {
          .           .           .                    .                .                .                    .              .           .                       table = codeword->table();
  2,991,604 ( 0.01%)  0           0                    0                0                0                    0              0           0                       bit_position_ += 9;  // CHAR_BIT + 1
          .           .           .                    .                .                .                    .              .           .                   } else {
 38,111,330 ( 0.12%)  1 ( 0.01%)  1 ( 0.01%)           0                0                0                    0              0           0                       bit_position_ += length;
          .           .           .                    .                .                .                    .              .           .                       pattern = codeword->pattern();
          .           .           .                    .                .                .                    .              .           .                   }
208,506,274 ( 0.67%)  0           0                    0                0                0           41,102,934 ( 1.48%)     0           0                   word_offset_ += bit_position_ / CHAR_BIT;
 82,205,868 ( 0.26%)  0           0                    0                0                0           41,102,934 ( 1.48%)     0           0                   bit_position_ = bit_position_ % CHAR_BIT;
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               return pattern;
457,335,960 ( 1.47%)  1 ( 0.01%)  1 ( 0.01%) 343,001,970 ( 5.20%)       0                0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
802,226,600 ( 2.59%)  2 ( 0.01%)  2 ( 0.02%) 120,333,990 ( 1.82%)       0                0          320,890,640 (11.52%)     8 ( 0.00%)  4 ( 0.00%)  uint64_t Decompressor::Iterator::next_position(bool clean) {
 82,222,660 ( 0.27%)  0           0            1,000,000 ( 0.02%)       0                0                    0              0           0               if (clean && bit_position_ > 0) {
          .           .           .                    .                .                .                    .              .           .                   word_offset_++;
          .           .           .                    .                .                .                    .              .           .                   bit_position_ = 0;
          .           .           .                    .                .                .                    .              .           .               }
160,445,320 ( 0.52%)  1 ( 0.01%)  1 ( 0.01%)           0                0                0           40,111,330 ( 1.44%)     4 ( 0.00%)  2 ( 0.00%)      SILK_TRACE << "Iterator::next_position word_offset_=" << word_offset_ << " bit_position_=" << int(bit_position_);
 40,111,330 ( 0.13%)  0           0           40,111,330 ( 0.61%)       0                0                    0              0           0               const PositionTable* table = decoder_->position_dict_.get();
 80,222,660 ( 0.26%)  0           0                    0                0                0                    0              0           0               if (table->bit_length() == 0) {
          .           .           .                    .                .                .                    .              .           .                   SILK_TRACE << "Iterator::next_position table->position(0)=" << table->position(0);
          .           .           .                    .                .                .                    .              .           .                   return table->position(0);
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               uint8_t length{0};
          .           .           .                    .                .                .                    .              .           .               uint64_t position{0};
          .           .           .                    .                .                .                    .              .           .               while (length == 0) {
          .           .           .                    .                .                .                    .              .           .                   const uint16_t code = next_code(table->bit_length());
 80,718,020 ( 0.26%)  0           0                    0                0                0                    0              0           0                   length = table->length(code);
 80,718,020 ( 0.26%)  0           0                    0                0                0                    0              0           0                   if (length == 0) {
          .           .           .                    .                .                .                    .              .           .                       table = table->child(code);
    247,680 ( 0.00%)  0           0                    0                0                0                    0              0           0                       bit_position_ += 9;  // CHAR_BIT + 1
          .           .           .                    .                .                .                    .              .           .                   } else {
 80,222,660 ( 0.26%)  0           0                    0                0                0           40,111,330 ( 1.44%)     0           0                       bit_position_ += length;
160,445,320 ( 0.52%)  0           0                    0                0                0           40,111,330 ( 1.44%)     0           0                       SILK_TRACE << "Iterator::next_position table->position(code)=" << table->position(code);
          .           .           .                    .                .                .                    .              .           .                       position = table->position(code);
          .           .           .                    .                .                .                    .              .           .                   }
201,795,050 ( 0.65%)  1 ( 0.01%)  1 ( 0.01%)  80,222,660 ( 1.22%)       0                0              247,680 ( 0.01%)     0           0                   word_offset_ += bit_position_ / CHAR_BIT;
 80,718,020 ( 0.26%)  0           0                    0                0                0           40,359,010 ( 1.45%)     0           0                   bit_position_ = bit_position_ % CHAR_BIT;
          .           .           .                    .                .                .                    .              .           .               }
          .           .           .                    .                .                .                    .              .           .               return position;
481,335,960 ( 1.55%)  0           0          361,001,970 ( 5.47%)       0                0                    0              0           0           }
          .           .           .                    .                .                .                    .              .           .           
          .           .           .                    .                .                .                    .              .           .           uint16_t Decompressor::Iterator::next_code(std::size_t bit_length) {
645,216,984 ( 2.08%)  2 ( 0.01%)  2 ( 0.02%) 319,369,208 ( 4.84%)  11,301 ( 0.03%)  11,297 ( 0.22%)           0              0           0               uint16_t code = static_cast<uint16_t>(decoder_->words_start_[word_offset_]) >> bit_position_;
768,000,868 ( 2.48%)  1 ( 0.01%)  1 ( 0.01%)  81,452,386 ( 1.23%)       0                0                    0              0           0               if (static_cast<std::size_t>(CHAR_BIT - bit_position_) < bit_length && word_offset_ + 1 < data_size()) {
244,357,158 ( 0.79%)  0           0           81,452,386 ( 1.23%) 174,872 ( 0.46%) 174,872 ( 3.39%)           0              0           0                   code |= decoder_->words_start_[word_offset_ + 1] << (CHAR_BIT - bit_position_);
          .           .           .                    .                .                .                    .              .           .               }
447,173,370 ( 1.44%)  1 ( 0.01%)  1 ( 0.01%)           0                0                0                    0              0           0               code &= (1 << bit_length) - 1;
          .           .           .                    .                .                .                    .              .           .               return code;
          .           .           .                    .                .                .                    .              .           .           }
          .           .           .                    .                .                .                    .              .           .           
         32 ( 0.00%)  4 ( 0.02%)  4 ( 0.04%)          12 ( 0.00%)       0                0                   12 ( 0.00%)     0           0           }  // namespace silkworm::huffman

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/char_traits.h
--------------------------------------------------------------------------------
Ir                   I1mr        ILmr        Dr                   D1mr               DLmr             Dw                  D1mw           DLmw        

-- line 95 ----------------------------------------
          .           .           .                    .                  .                .                   .              .           .                 typedef typename _Char_types<_CharT>::off_type    off_type;
          .           .           .                    .                  .                .                   .              .           .                 typedef typename _Char_types<_CharT>::state_type  state_type;
          .           .           .                    .                  .                .                   .              .           .           #if __cpp_lib_three_way_comparison
          .           .           .                    .                  .                .                   .              .           .                 using comparison_category = std::strong_ordering;
          .           .           .                    .                  .                .                   .              .           .           #endif
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX14_CONSTEXPR void
          .           .           .                    .                  .                .                   .              .           .                 assign(char_type& __c1, const char_type& __c2)
 38,274,289 ( 0.12%) 12 ( 0.07%) 12 ( 0.13%)     549,162 ( 0.01%)         0                0          34,421,569 ( 1.24%) 4,327 ( 0.14%) 12 ( 0.00%)        { __c1 = __c2; }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX_CONSTEXPR bool
          .           .           .                    .                  .                .                   .              .           .                 eq(const char_type& __c1, const char_type& __c2)
          .           .           .                    .                  .                .                   .              .           .                 { return __c1 == __c2; }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX_CONSTEXPR bool
          .           .           .                    .                  .                .                   .              .           .                 lt(const char_type& __c1, const char_type& __c2)
          .           .           .                    .                  .                .                   .              .           .                 { return __c1 < __c2; }
-- line 111 ----------------------------------------
-- line 149 ----------------------------------------
          .           .           .                    .                  .                .                   .              .           .                 { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
          .           .           .                    .                  .                .                   .              .           .               };
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .             template<typename _CharT>
          .           .           .                    .                  .                .                   .              .           .               _GLIBCXX14_CONSTEXPR int
          .           .           .                    .                  .                .                   .              .           .               char_traits<_CharT>::
          .           .           .                    .                  .                .                   .              .           .               compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
          .           .           .                    .                  .                .                   .              .           .               {
553,592,007 ( 1.78%)  1 ( 0.01%)  1 ( 0.01%)           0                  0                0                   0              0           0                 for (std::size_t __i = 0; __i < __n; ++__i)
567,334,906 ( 1.83%)  0           0          371,994,236 ( 5.64%) 7,175,125 (18.95%) 384,372 ( 7.44%)          0              0           0           	if (lt(__s1[__i], __s2[__i]))
          .           .           .                    .                  .                .                   .              .           .           	  return -1;
157,966,462 ( 0.51%)  0           0                    0                  0                0                   0              0           0           	else if (lt(__s2[__i], __s1[__i]))
          .           .           .                    .                  .                .                   .              .           .           	  return 1;
          .           .           .                    .                  .                .                   .              .           .                 return 0;
          .           .           .                    .                  .                .                   .              .           .               }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .             template<typename _CharT>
          .           .           .                    .                  .                .                   .              .           .               _GLIBCXX14_CONSTEXPR std::size_t
          .           .           .                    .                  .                .                   .              .           .               char_traits<_CharT>::
          .           .           .                    .                  .                .                   .              .           .               length(const char_type* __p)
-- line 168 ----------------------------------------
-- line 237 ----------------------------------------
          .           .           .                    .                  .                .                   .              .           .             template<typename _CharT>
          .           .           .                    .                  .                .                   .              .           .               _GLIBCXX20_CONSTEXPR
          .           .           .                    .                  .                .                   .              .           .               typename char_traits<_CharT>::char_type*
          .           .           .                    .                  .                .                   .              .           .               char_traits<_CharT>::
          .           .           .                    .                  .                .                   .              .           .               copy(char_type* __s1, const char_type* __s2, std::size_t __n)
          .           .           .                    .                  .                .                   .              .           .               {
          .           .           .                    .                  .                .                   .              .           .                 // NB: Inline std::copy so no recursive dependencies.
          .           .           .                    .                  .                .                   .              .           .                 std::copy(__s2, __s2 + __n, __s1);
  6,462,016 ( 0.02%)  1 ( 0.01%)  1 ( 0.01%)           0                  0                0                   0              0           0                 return __s1;
          .           .           .                    .                  .                .                   .              .           .               }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .             template<typename _CharT>
          .           .           .                    .                  .                .                   .              .           .               _GLIBCXX20_CONSTEXPR
          .           .           .                    .                  .                .                   .              .           .               typename char_traits<_CharT>::char_type*
          .           .           .                    .                  .                .                   .              .           .               char_traits<_CharT>::
          .           .           .                    .                  .                .                   .              .           .               assign(char_type* __s, std::size_t __n, char_type __a)
          .           .           .                    .                  .                .                   .              .           .               {
-- line 253 ----------------------------------------
-- line 349 ----------------------------------------
          .           .           .                    .                  .                .                   .              .           .                 typedef streamoff         off_type;
          .           .           .                    .                  .                .                   .              .           .                 typedef mbstate_t         state_type;
          .           .           .                    .                  .                .                   .              .           .           #if __cpp_lib_three_way_comparison
          .           .           .                    .                  .                .                   .              .           .                 using comparison_category = strong_ordering;
          .           .           .                    .                  .                .                   .              .           .           #endif
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX17_CONSTEXPR void
          .           .           .                    .                  .                .                   .              .           .                 assign(char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
  7,006,861 ( 0.02%) 72 ( 0.42%) 36 ( 0.38%)   1,500,877 ( 0.02%)         2 ( 0.00%)       0           5,505,579 ( 0.20%)    39 ( 0.00%) 21 ( 0.00%)        { __c1 = __c2; }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX_CONSTEXPR bool
          .           .           .                    .                  .                .                   .              .           .                 eq(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
          .           .           .                    .                  .                .                   .              .           .                 { return __c1 == __c2; }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX_CONSTEXPR bool
          .           .           .                    .                  .                .                   .              .           .                 lt(const char_type& __c1, const char_type& __c2) _GLIBCXX_NOEXCEPT
          .           .           .                    .                  .                .                   .              .           .                 {
-- line 365 ----------------------------------------
-- line 366 ----------------------------------------
          .           .           .                    .                  .                .                   .              .           .           	// LWG 467.
          .           .           .                    .                  .                .                   .              .           .           	return (static_cast<unsigned char>(__c1)
          .           .           .                    .                  .                .                   .              .           .           		< static_cast<unsigned char>(__c2));
          .           .           .                    .                  .                .                   .              .           .                 }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX17_CONSTEXPR int
          .           .           .                    .                  .                .                   .              .           .                 compare(const char_type* __s1, const char_type* __s2, size_t __n)
          .           .           .                    .                  .                .                   .              .           .                 {
        182 ( 0.00%)  0           0                    0                  0                0                   0              0           0           	if (__n == 0)
          .           .           .                    .                  .                .                   .              .           .           	  return 0;
          .           .           .                    .                  .                .                   .              .           .           #if __cplusplus >= 201703L
          .           .           .                    .                  .                .                   .              .           .           	if (__builtin_constant_p(__n)
          .           .           .                    .                  .                .                   .              .           .           	    && __constant_char_array_p(__s1, __n)
          .           .           .                    .                  .                .                   .              .           .           	    && __constant_char_array_p(__s2, __n))
          .           .           .                    .                  .                .                   .              .           .           	  {
          .           .           .                    .                  .                .                   .              .           .           	    for (size_t __i = 0; __i < __n; ++__i)
          .           .           .                    .                  .                .                   .              .           .           	      if (lt(__s1[__i], __s2[__i]))
          .           .           .                    .                  .                .                   .              .           .           		return -1;
          .           .           .                    .                  .                .                   .              .           .           	      else if (lt(__s2[__i], __s1[__i]))
          .           .           .                    .                  .                .                   .              .           .           		return 1;
          .           .           .                    .                  .                .                   .              .           .           	    return 0;
          .           .           .                    .                  .                .                   .              .           .           	  }
          .           .           .                    .                  .                .                   .              .           .           #endif
        284 ( 0.00%)  3 ( 0.02%)  2 ( 0.02%)          82 ( 0.00%)         0                0                  98 ( 0.00%)     0           0           	return __builtin_memcmp(__s1, __s2, __n);
          .           .           .                    .                  .                .                   .              .           .                 }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX17_CONSTEXPR size_t
          .           .           .                    .                  .                .                   .              .           .                 length(const char_type* __s)
          .           .           .                    .                  .                .                   .              .           .                 {
          .           .           .                    .                  .                .                   .              .           .           #if __cplusplus >= 201703L
          .           .           .                    .                  .                .                   .              .           .           	if (__constant_string_p(__s))
          .           .           .                    .                  .                .                   .              .           .           	  return __gnu_cxx::char_traits<char_type>::length(__s);
          .           .           .                    .                  .                .                   .              .           .           #endif
        575 ( 0.00%) 25 ( 0.15%)  8 ( 0.08%)           0                  0                0                 153 ( 0.00%)     2 ( 0.00%)  0           	return __builtin_strlen(__s);
          .           .           .                    .                  .                .                   .              .           .                 }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX17_CONSTEXPR const char_type*
          .           .           .                    .                  .                .                   .              .           .                 find(const char_type* __s, size_t __n, const char_type& __a)
          .           .           .                    .                  .                .                   .              .           .                 {
          .           .           .                    .                  .                .                   .              .           .           	if (__n == 0)
          .           .           .                    .                  .                .                   .              .           .           	  return 0;
          .           .           .                    .                  .                .                   .              .           .           #if __cplusplus >= 201703L
          .           .           .                    .                  .                .                   .              .           .           	if (__builtin_constant_p(__n)
          .           .           .                    .                  .                .                   .              .           .           	    && __builtin_constant_p(__a)
          .           .           .                    .                  .                .                   .              .           .           	    && __constant_char_array_p(__s, __n))
          .           .           .                    .                  .                .                   .              .           .           	  return __gnu_cxx::char_traits<char_type>::find(__s, __n, __a);
          .           .           .                    .                  .                .                   .              .           .           #endif
      1,129 ( 0.00%)  0           0                  343 ( 0.00%)         0                0                 276 ( 0.00%)     1 ( 0.00%)  0           	return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
          .           .           .                    .                  .                .                   .              .           .                 }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX20_CONSTEXPR char_type*
          .           .           .                    .                  .                .                   .              .           .                 move(char_type* __s1, const char_type* __s2, size_t __n)
          .           .           .                    .                  .                .                   .              .           .                 {
          .           .           .                    .                  .                .                   .              .           .           	if (__n == 0)
          .           .           .                    .                  .                .                   .              .           .           	  return __s1;
          .           .           .                    .                  .                .                   .              .           .           #ifdef __cpp_lib_is_constant_evaluated
          .           .           .                    .                  .                .                   .              .           .           	if (std::is_constant_evaluated())
          .           .           .                    .                  .                .                   .              .           .           	  return __gnu_cxx::char_traits<char_type>::move(__s1, __s2, __n);
          .           .           .                    .                  .                .                   .              .           .           #endif
         40 ( 0.00%)  0           0                   10 ( 0.00%)         0                0                  20 ( 0.00%)     0           0           	return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
          .           .           .                    .                  .                .                   .              .           .                 }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX20_CONSTEXPR char_type*
          .           .           .                    .                  .                .                   .              .           .                 copy(char_type* __s1, const char_type* __s2, size_t __n)
          .           .           .                    .                  .                .                   .              .           .                 {
      1,598 ( 0.00%)  4 ( 0.02%)  2 ( 0.02%)           0                  0                0                   0              0           0           	if (__n == 0)
          .           .           .                    .                  .                .                   .              .           .           	  return __s1;
          .           .           .                    .                  .                .                   .              .           .           #ifdef __cpp_lib_is_constant_evaluated
          .           .           .                    .                  .                .                   .              .           .           	if (std::is_constant_evaluated())
          .           .           .                    .                  .                .                   .              .           .           	  return __gnu_cxx::char_traits<char_type>::copy(__s1, __s2, __n);
          .           .           .                    .                  .                .                   .              .           .           #endif
 13,007,757 ( 0.04%) 62 ( 0.36%) 40 ( 0.42%)   2,000,064 ( 0.03%)        20 ( 0.00%)       9 ( 0.00%)  5,003,295 ( 0.18%)     5 ( 0.00%)  0           	return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
          .           .           .                    .                  .                .                   .              .           .                 }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX20_CONSTEXPR char_type*
          .           .           .                    .                  .                .                   .              .           .                 assign(char_type* __s, size_t __n, char_type __a)
          .           .           .                    .                  .                .                   .              .           .                 {
          .           .           .                    .                  .                .                   .              .           .           	if (__n == 0)
          .           .           .                    .                  .                .                   .              .           .           	  return __s;
          .           .           .                    .                  .                .                   .              .           .           #ifdef __cpp_lib_is_constant_evaluated
          .           .           .                    .                  .                .                   .              .           .           	if (std::is_constant_evaluated())
          .           .           .                    .                  .                .                   .              .           .           	  return __gnu_cxx::char_traits<char_type>::assign(__s, __n, __a);
          .           .           .                    .                  .                .                   .              .           .           #endif
  5,492,268 ( 0.02%)  1 ( 0.01%)  0                    0                  0                0           1,498,066 ( 0.05%)     0           0           	return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
          .           .           .                    .                  .                .                   .              .           .                 }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 static _GLIBCXX_CONSTEXPR char_type
          .           .           .                    .                  .                .                   .              .           .                 to_char_type(const int_type& __c) _GLIBCXX_NOEXCEPT
          .           .           .                    .                  .                .                   .              .           .                 { return static_cast<char_type>(__c); }
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .                 // To keep both the byte 0xff and the eof symbol 0xffffffff
          .           .           .                    .                  .                .                   .              .           .                 // from ending up as 0xffffffff.
-- line 457 ----------------------------------------
-- line 964 ----------------------------------------
          .           .           .                    .                  .                .                   .              .           .               template<typename _ChTraits>
          .           .           .                    .                  .                .                   .              .           .                 constexpr auto
          .           .           .                    .                  .                .                   .              .           .                 __char_traits_cmp_cat(int __cmp) noexcept
          .           .           .                    .                  .                .                   .              .           .                 {
          .           .           .                    .                  .                .                   .              .           .           	if constexpr (requires { typename _ChTraits::comparison_category; })
          .           .           .                    .                  .                .                   .              .           .           	  {
          .           .           .                    .                  .                .                   .              .           .           	    using _Cat = typename _ChTraits::comparison_category;
          .           .           .                    .                  .                .                   .              .           .           	    static_assert( !is_void_v<common_comparison_category_t<_Cat>> );
         65 ( 0.00%)  2 ( 0.01%)  2 ( 0.02%)           0                  0                0                   5 ( 0.00%)     0           0           	    return static_cast<_Cat>(__cmp <=> 0);
          .           .           .                    .                  .                .                   .              .           .           	  }
          .           .           .                    .                  .                .                   .              .           .           	else
          .           .           .                    .                  .                .                   .              .           .           	  return static_cast<weak_ordering>(__cmp <=> 0);
          .           .           .                    .                  .                .                   .              .           .                 }
          .           .           .                    .                  .                .                   .              .           .             } // namespace __detail
          .           .           .                    .                  .                .                   .              .           .           #endif // C++20
          .           .           .                    .                  .                .                   .              .           .           
          .           .           .                    .                  .                .                   .              .           .           _GLIBCXX_END_NAMESPACE_VERSION
-- line 980 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/mriccobene/CLionProjects/silkworm/silkworm/node/recsplit/support/murmur_hash3.cpp
--------------------------------------------------------------------------------
Ir                 I1mr       ILmr       Dr                 D1mr         DLmr       Dw               D1mw       DLmw       

-- line 37 ----------------------------------------
        .          .          .                  .            .          .                .          .          .           #define BIG_CONSTANT(x) (x)
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .           // Other compilers
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .           #else  // defined(_MSC_VER)
        .          .          .                  .            .          .                .          .          .           #define FORCE_INLINE inline __attribute__((always_inline))
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .           inline uint64_t rotl64(uint64_t x, int8_t r) {
4,000,000 ( 0.01%) 1 ( 0.01%) 1 ( 0.01%)         0            0          0                0          0          0               return (x << r) | (x >> (64 - r));
        .          .          .                  .            .          .                .          .          .           }
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .           #define ROTL64(x, y) rotl64(x, y)
        .          .          .                  .            .          .                .          .          .           #define BIG_CONSTANT(x) (x##LLU)
        .          .          .                  .            .          .                .          .          .           #endif  // !defined(_MSC_VER)
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .           // Block read - if your platform needs to do endian-swapping or can only
        .          .          .                  .            .          .                .          .          .           // handle aligned reads, do the conversion here
-- line 53 ----------------------------------------
-- line 54 ----------------------------------------
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .           FORCE_INLINE uint64_t getblock64(const uint64_t* p, std::size_t i) {
        .          .          .                  .            .          .                .          .          .               return p[i];
        .          .          .                  .            .          .                .          .          .           }
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .           // Finalization mix - force all bits of a hash block to avalanche
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .           FORCE_INLINE uint64_t fmix64(uint64_t k) {
3,000,000 ( 0.01%) 0          0                  0            0          0                0          0          0               k ^= k >> 33;
1,500,000 ( 0.00%) 2 ( 0.01%) 2 ( 0.02%)         0            0          0                0          0          0               k *= BIG_CONSTANT(0xff51afd7ed558ccd);
3,000,000 ( 0.01%) 0          0                  0            0          0                0          0          0               k ^= k >> 33;
1,500,000 ( 0.00%) 0          0                  0            0          0                0          0          0               k *= BIG_CONSTANT(0xc4ceb9fe1a85ec53);
3,000,000 ( 0.01%) 1 ( 0.01%) 1 ( 0.01%)         0            0          0                0          0          0               k ^= k >> 33;
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .               return k;
        .          .          .                  .            .          .                .          .          .           }
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .           void MurmurHash3_x64_128(const void* key, const uint64_t len,
2,000,000 ( 0.01%) 1 ( 0.01%) 1 ( 0.01%)         0            0          0          500,000 ( 0.02%) 0          0                                    const uint32_t seed, void* out) {
        .          .          .                  .            .          .                .          .          .               const auto* data = reinterpret_cast<const uint8_t*>(key);
        .          .          .                  .            .          .                .          .          .               const std::size_t num_blocks = len / 16;
        .          .          .                  .            .          .                .          .          .           
  500,000 ( 0.00%) 0          0                  0            0          0                0          0          0               uint64_t h1 = seed;
  500,000 ( 0.00%) 0          0                  0            0          0                0          0          0               uint64_t h2 = seed;
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .               const uint64_t c1 = BIG_CONSTANT(0x87c37b91114253d5);
        .          .          .                  .            .          .                .          .          .               const uint64_t c2 = BIG_CONSTANT(0x4cf5ad432745937f);
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .               //----------
        .          .          .                  .            .          .                .          .          .               // body
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .               const auto* blocks = reinterpret_cast<const uint64_t*>(data);
        .          .          .                  .            .          .                .          .          .           
5,500,000 ( 0.02%) 0          0                  0            0          0                0          0          0               for (std::size_t i{0}; i < num_blocks; i++) {
        .          .          .                  .            .          .                .          .          .                   uint64_t k1 = getblock64(blocks, i * 2 + 0);
        .          .          .                  .            .          .                .          .          .                   uint64_t k2 = getblock64(blocks, i * 2 + 1);
        .          .          .                  .            .          .                .          .          .           
2,500,000 ( 0.01%) 0          0          1,000,000 ( 0.02%)   0          0                0          0          0                   k1 *= c1;
        .          .          .                  .            .          .                .          .          .                   k1 = ROTL64(k1, 31);
2,500,000 ( 0.01%) 1 ( 0.01%) 1 ( 0.01%)         0            0          0                0          0          0                   k1 *= c2;
1,000,000 ( 0.00%) 0          0                  0            0          0                0          0          0                   h1 ^= k1;
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .                   h1 = ROTL64(h1, 27);
1,000,000 ( 0.00%) 0          0                  0            0          0                0          0          0                   h1 += h2;
1,000,000 ( 0.00%) 0          0                  0            0          0                0          0          0                   h1 = h1 * 5 + 0x52dce729;
        .          .          .                  .            .          .                .          .          .           
2,000,000 ( 0.01%) 0          0          1,000,000 ( 0.02%)   0          0                0          0          0                   k2 *= c2;
        .          .          .                  .            .          .                .          .          .                   k2 = ROTL64(k2, 33);
1,000,000 ( 0.00%) 0          0                  0            0          0                0          0          0                   k2 *= c1;
1,000,000 ( 0.00%) 0          0                  0            0          0                0          0          0                   h2 ^= k2;
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .                   h2 = ROTL64(h2, 31);
1,000,000 ( 0.00%) 0          0                  0            0          0                0          0          0                   h2 += h1;
1,000,000 ( 0.00%) 0          0                  0            0          0                0          0          0                   h2 = h2 * 5 + 0x38495ab5;
        .          .          .                  .            .          .                .          .          .               }
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .               //----------
        .          .          .                  .            .          .                .          .          .               // tail
        .          .          .                  .            .          .                .          .          .           
1,500,000 ( 0.00%) 0          0                  0            0          0                0          0          0               const auto* tail = reinterpret_cast<const uint8_t*>(data + num_blocks * 16);
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .               uint64_t k1 = 0;
        .          .          .                  .            .          .                .          .          .               uint64_t k2 = 0;
        .          .          .                  .            .          .                .          .          .           
3,000,000 ( 0.01%) 0          0            500,000 ( 0.01%) 956 ( 0.00%) 1 ( 0.00%)       0          0          0               switch (len & 15) {
        .          .          .                  .            .          .                .          .          .                   case 15:
        .          .          .                  .            .          .                .          .          .                       k2 ^= static_cast<uint64_t>(tail[14]) << 48;
        .          .          .                  .            .          .                .          .          .                       [[fallthrough]];
        .          .          .                  .            .          .                .          .          .                   case 14:
        .          .          .                  .            .          .                .          .          .                       k2 ^= static_cast<uint64_t>(tail[13]) << 40;
        .          .          .                  .            .          .                .          .          .                       [[fallthrough]];
        .          .          .                  .            .          .                .          .          .                   case 13:
        .          .          .                  .            .          .                .          .          .                       k2 ^= static_cast<uint64_t>(tail[12]) << 32;
-- line 126 ----------------------------------------
-- line 169 ----------------------------------------
        .          .          .                  .            .          .                .          .          .                       k1 = ROTL64(k1, 31);
        .          .          .                  .            .          .                .          .          .                       k1 *= c2;
        .          .          .                  .            .          .                .          .          .                       h1 ^= k1;
        .          .          .                  .            .          .                .          .          .               }
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .               //----------
        .          .          .                  .            .          .                .          .          .               // finalization
        .          .          .                  .            .          .                .          .          .           
  500,000 ( 0.00%) 0          0                  0            0          0                0          0          0               h1 ^= len;
  500,000 ( 0.00%) 0          0                  0            0          0                0          0          0               h2 ^= len;
        .          .          .                  .            .          .                .          .          .           
  500,000 ( 0.00%) 0          0                  0            0          0                0          0          0               h1 += h2;
  500,000 ( 0.00%) 0          0                  0            0          0                0          0          0               h2 += h1;
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .               h1 = fmix64(h1);
        .          .          .                  .            .          .                .          .          .               h2 = fmix64(h2);
        .          .          .                  .            .          .                .          .          .           
3,500,000 ( 0.01%) 0          0                  0            0          0                0          0          0               h1 += h2;
        .          .          .                  .            .          .                .          .          .               h2 += h1;
        .          .          .                  .            .          .                .          .          .           
  500,000 ( 0.00%) 0          0                  0            0          0          500,000 ( 0.02%) 0          0               reinterpret_cast<uint64_t*>(out)[0] = h1;
        .          .          .                  .            .          .                .          .          .               reinterpret_cast<uint64_t*>(out)[1] = h2;
1,000,000 ( 0.00%) 0          0          1,000,000 ( 0.02%)   0          0                0          0          0           }
        .          .          .                  .            .          .                .          .          .           
        .          .          .                  .            .          .                .          .          .           }  // namespace silkworm::succinct

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/mriccobene/CLionProjects/silkworm/silkworm/node/etl/util.cpp
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                  D1mr                DLmr               Dw         D1mw       DLmw       

-- line 28 ----------------------------------------
          .          .          .                   .                   .                  .          .          .          .               if (strerror_r(err_code, msg, sizeof(msg)) != 0) {
          .          .          .                   .                   .                  .          .          .          .                   (void)strncpy(msg, "Unknown error", sizeof(msg));
          .          .          .                   .                   .                  .          .          .          .               }
          .          .          .                   .                   .                  .          .          .          .           #endif
          .          .          .                   .                   .                  .          .          .          .               msg[sizeof(msg) - 1] = '\0';
          .          .          .                   .                   .                  .          .          .          .               return {msg};
          .          .          .                   .                   .                  .          .          .          .           }
          .          .          .                   .                   .                  .          .          .          .           
189,050,472 ( 0.61%) 2 ( 0.01%) 2 ( 0.02%) 94,525,236 ( 1.43%) 12,950,132 (34.20%) 1,052,871 (20.39%) 0          0          0           bool operator<(const Entry& a, const Entry& b) {
          .          .          .                   .                   .                  .          .          .          .               auto diff{a.key.compare(b.key)};
          .          .          .                   .                   .                  .          .          .          .               if (diff == 0) {
          .          .          .                   .                   .                  .          .          .          .                   return a.value < b.value;
          .          .          .                   .                   .                  .          .          .          .               }
          .          .          .                   .                   .                  .          .          .          .               return diff < 0;
  9,888,410 ( 0.03%) 1 ( 0.01%) 1 ( 0.01%)  4,944,205 ( 0.07%)          0                  0          0          0          0           }
          .          .          .                   .                   .                  .          .          .          .           
          .          .          .                   .                   .                  .          .          .          .           }  // namespace silkworm::etl

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir                  I1mr        ILmr        Dr                 D1mr               DLmr             Dw                  D1mw               DLmw               

-- line 97 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .           	{
         .           .           .                  .                  .                .                   .                  .                  .           	  for(; __num > 0; ++__first1, ++__first2, --__num)
         .           .           .                  .                  .                .                   .                  .                  .           	    if (*__first1 != *__first2)
         .           .           .                  .                  .                .                   .                  .                  .           	      return *__first1 < *__first2 ? -1 : 1;
         .           .           .                  .                  .                .                   .                  .                  .           	  return 0;
         .           .           .                  .                  .                .                   .                  .                  .           	}
         .           .           .                  .                  .                .                   .                  .                  .                 else
         .           .           .                  .                  .                .                   .                  .                  .           #endif
         4 ( 0.00%)  0           0                  1 ( 0.00%)         0                0                   1 ( 0.00%)         0                  0           	return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
         .           .           .                  .                  .                .                   .                  .                  .               }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .           #if __cplusplus < 201103L
         .           .           .                  .                  .                .                   .                  .                  .             // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
         .           .           .                  .                  .                .                   .                  .                  .             // nutshell, we are partially implementing the resolution of DR 187,
         .           .           .                  .                  .                .                   .                  .                  .             // when it's safe, i.e., the value_types are equal.
         .           .           .                  .                  .                .                   .                  .                  .             template<bool _BoolType>
         .           .           .                  .                  .                .                   .                  .                  .               struct __iter_swap
-- line 113 ----------------------------------------
-- line 251 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .             template<typename _Tp>
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX14_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               inline const _Tp&
         .           .           .                  .                  .                .                   .                  .                  .               max(const _Tp& __a, const _Tp& __b)
         .           .           .                  .                  .                .                   .                  .                  .               {
         .           .           .                  .                  .                .                   .                  .                  .                 // concept requirements
         .           .           .                  .                  .                .                   .                  .                  .                 __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
         .           .           .                  .                  .                .                   .                  .                  .                 //return  __a < __b ? __b : __a;
         8 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         0                  0                0                   0                  0                  0                 if (__a < __b)
         .           .           .                  .                  .                .                   .                  .                  .           	return __b;
         .           .           .                  .                  .                .                   .                  .                  .                 return __a;
         .           .           .                  .                  .                .                   .                  .                  .               }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             /**
         .           .           .                  .                  .                .                   .                  .                  .              *  @brief This does what you think it does.
         .           .           .                  .                  .                .                   .                  .                  .              *  @ingroup sorting_algorithms
         .           .           .                  .                  .                .                   .                  .                  .              *  @param  __a  A thing of arbitrary type.
-- line 267 ----------------------------------------
-- line 377 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .                 template<typename _II, typename _OI>
         .           .           .                  .                  .                .                   .                  .                  .           	_GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .           	static _OI
         .           .           .                  .                  .                .                   .                  .                  .           	__copy_m(_II __first, _II __last, _OI __result)
         .           .           .                  .                  .                .                   .                  .                  .           	{
         .           .           .                  .                  .                .                   .                  .                  .           	  typedef typename iterator_traits<_II>::difference_type _Distance;
         .           .           .                  .                  .                .                   .                  .                  .           	  for(_Distance __n = __last - __first; __n > 0; --__n)
         .           .           .                  .                  .                .                   .                  .                  .           	    {
     1,244 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)       246 ( 0.00%)        63 ( 0.00%)      62 ( 0.00%)        246 ( 0.00%)        60 ( 0.00%)        38 ( 0.00%)  	      *__result = *__first;
         .           .           .                  .                  .                .                   .                  .                  .           	      ++__first;
         8 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         0                  0                0                   0                  0                  0           	      ++__result;
         .           .           .                  .                  .                .                   .                  .                  .           	    }
         .           .           .                  .                  .                .                   .                  .                  .           	  return __result;
         .           .           .                  .                  .                .                   .                  .                  .           	}
         .           .           .                  .                  .                .                   .                  .                  .               };
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .           #if __cplusplus >= 201103L
         .           .           .                  .                  .                .                   .                  .                  .             template<>
         .           .           .                  .                  .                .                   .                  .                  .               struct __copy_move<true, false, random_access_iterator_tag>
-- line 395 ----------------------------------------
-- line 421 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .           	{
         .           .           .                  .                  .                .                   .                  .                  .           #if __cplusplus >= 201103L
         .           .           .                  .                  .                .                   .                  .                  .           	  using __assignable = conditional<_IsMove,
         .           .           .                  .                  .                .                   .                  .                  .           					   is_move_assignable<_Tp>,
         .           .           .                  .                  .                .                   .                  .                  .           					   is_copy_assignable<_Tp>>;
         .           .           .                  .                  .                .                   .                  .                  .           	  // trivial types can have deleted assignment
         .           .           .                  .                  .                .                   .                  .                  .           	  static_assert( __assignable::type::value, "type is not assignable" );
         .           .           .                  .                  .                .                   .                  .                  .           #endif
         4 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0           	  const ptrdiff_t _Num = __last - __first;
45,471,078 ( 0.15%)  1 ( 0.01%)  1 ( 0.01%)         2 ( 0.00%)         0                0                   0                  0                  0           	  if (_Num)
95,899,875 ( 0.31%) 24 ( 0.14%) 24 ( 0.25%) 7,037,230 ( 0.11%) 3,310,383 ( 8.74%) 958,925 (18.57%) 40,107,101 ( 1.44%) 1,954,006 (62.37%) 1,942,380 (82.06%)  	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
         5 ( 0.00%)  0           0                  0                  0                0                   2 ( 0.00%)         0                  0           	  return __result + _Num;
         .           .           .                  .                  .                .                   .                  .                  .           	}
         .           .           .                  .                  .                .                   .                  .                  .               };
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .           _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             template<typename _Tp, typename _Ref, typename _Ptr>
         .           .           .                  .                  .                .                   .                  .                  .               struct _Deque_iterator;
         .           .           .                  .                  .                .                   .                  .                  .           
-- line 440 ----------------------------------------
-- line 709 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .               struct __copy_move_backward<true, false, random_access_iterator_tag>
         .           .           .                  .                  .                .                   .                  .                  .               {
         .           .           .                  .                  .                .                   .                  .                  .                 template<typename _BI1, typename _BI2>
         .           .           .                  .                  .                .                   .                  .                  .           	_GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .           	static _BI2
         .           .           .                  .                  .                .                   .                  .                  .           	__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
         .           .           .                  .                  .                .                   .                  .                  .           	{
         .           .           .                  .                  .                .                   .                  .                  .           	  typename iterator_traits<_BI1>::difference_type
        27 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         0                  0                0                   0                  0                  0           	    __n = __last - __first;
        79 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0           	  for (; __n > 0; --__n)
         3 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         0                  0                0                   0                  0                  0           	    *--__result = std::move(*--__last);
         .           .           .                  .                  .                .                   .                  .                  .           	  return __result;
         .           .           .                  .                  .                .                   .                  .                  .           	}
         .           .           .                  .                  .                .                   .                  .                  .               };
         .           .           .                  .                  .                .                   .                  .                  .           #endif
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             template<bool _IsMove>
         .           .           .                  .                  .                .                   .                  .                  .               struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
         .           .           .                  .                  .                .                   .                  .                  .               {
-- line 727 ----------------------------------------
-- line 734 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .           	  using __assignable = conditional<_IsMove,
         .           .           .                  .                  .                .                   .                  .                  .           					   is_move_assignable<_Tp>,
         .           .           .                  .                  .                .                   .                  .                  .           					   is_copy_assignable<_Tp>>;
         .           .           .                  .                  .                .                   .                  .                  .           	  // trivial types can have deleted assignment
         .           .           .                  .                  .                .                   .                  .                  .           	  static_assert( __assignable::type::value, "type is not assignable" );
         .           .           .                  .                  .                .                   .                  .                  .           #endif
         .           .           .                  .                  .                .                   .                  .                  .           	  const ptrdiff_t _Num = __last - __first;
         .           .           .                  .                  .                .                   .                  .                  .           	  if (_Num)
         1 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         0                  0                0                   0                  0                  0           	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
         .           .           .                  .                  .                .                   .                  .                  .           	  return __result - _Num;
         .           .           .                  .                  .                .                   .                  .                  .           	}
         .           .           .                  .                  .                .                   .                  .                  .               };
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             template<bool _IsMove, typename _BI1, typename _BI2>
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               inline _BI2
         .           .           .                  .                  .                .                   .                  .                  .               __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
-- line 750 ----------------------------------------
-- line 915 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .             template<typename _ForwardIterator, typename _Tp>
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               inline typename
         .           .           .                  .                  .                .                   .                  .                  .               __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
         .           .           .                  .                  .                .                   .                  .                  .               __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
         .           .           .                  .                  .                .                   .                  .                  .           	      const _Tp& __value)
         .           .           .                  .                  .                .                   .                  .                  .               {
         .           .           .                  .                  .                .                   .                  .                  .                 const _Tp __tmp = __value;
 7,148,160 ( 0.02%)  0           0          3,574,078 ( 0.05%)         0                0                   0                  0                  0                 for (; __first != __last; ++__first)
21,502,885 ( 0.07%)  9 ( 0.05%)  6 ( 0.06%)    26,541 ( 0.00%)         0                0           3,575,451 ( 0.13%)         3 ( 0.00%)         2 ( 0.00%)  	*__first = __tmp;
         .           .           .                  .                  .                .                   .                  .                  .               }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             // Specialization: for char types we can use memset.
         .           .           .                  .                  .                .                   .                  .                  .             template<typename _Tp>
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               inline typename
         .           .           .                  .                  .                .                   .                  .                  .               __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
         .           .           .                  .                  .                .                   .                  .                  .               __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
-- line 932 ----------------------------------------
-- line 936 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .                 if (std::is_constant_evaluated())
         .           .           .                  .                  .                .                   .                  .                  .           	{
         .           .           .                  .                  .                .                   .                  .                  .           	  for (; __first != __last; ++__first)
         .           .           .                  .                  .                .                   .                  .                  .           	    *__first = __tmp;
         .           .           .                  .                  .                .                   .                  .                  .           	  return;
         .           .           .                  .                  .                .                   .                  .                  .           	}
         .           .           .                  .                  .                .                   .                  .                  .           #endif
         .           .           .                  .                  .                .                   .                  .                  .                 if (const size_t __len = __last - __first)
 1,063,127 ( 0.00%)  3 ( 0.02%)  3 ( 0.03%)         0                  0                0             562,869 ( 0.02%)         0                  0           	__builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
         .           .           .                  .                  .                .                   .                  .                  .               }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             template<typename _Ite, typename _Cont, typename _Tp>
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               inline void
         .           .           .                  .                  .                .                   .                  .                  .               __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
         .           .           .                  .                  .                .                   .                  .                  .           	      ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
         .           .           .                  .                  .                .                   .                  .                  .           	      const _Tp& __value)
-- line 952 ----------------------------------------
-- line 1107 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               inline _OutputIterator
         .           .           .                  .                  .                .                   .                  .                  .               __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
         .           .           .                  .                  .                .                   .                  .                  .           	       std::random_access_iterator_tag)
         .           .           .                  .                  .                .                   .                  .                  .               {
         .           .           .                  .                  .                .                   .                  .                  .           #if __cplusplus >= 201103L
         .           .           .                  .                  .                .                   .                  .                  .                 static_assert(is_integral<_Size>{}, "fill_n must pass integral size");
         .           .           .                  .                  .                .                   .                  .                  .           #endif
    38,245 ( 0.00%)  0           0                  0                  0                0                 505 ( 0.00%)        12 ( 0.00%)        12 ( 0.00%)        if (__n <= 0)
         .           .           .                  .                  .                .                   .                  .                  .           	return __first;
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .                 __glibcxx_requires_can_increment(__first, __n);
         .           .           .                  .                  .                .                   .                  .                  .           
       823 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0                 std::__fill_a(__first, __first + __n, __value);
       260 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0                 return __first + __n;
         .           .           .                  .                  .                .                   .                  .                  .               }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             /**
         .           .           .                  .                  .                .                   .                  .                  .              *  @brief Fills the range [first,first+n) with copies of value.
         .           .           .                  .                  .                .                   .                  .                  .              *  @ingroup mutating_algorithms
         .           .           .                  .                  .                .                   .                  .                  .              *  @param  __first  An output iterator.
         .           .           .                  .                  .                .                   .                  .                  .              *  @param  __n      The count of copies to perform.
         .           .           .                  .                  .                .                   .                  .                  .              *  @param  __value  A reference-to-const of arbitrary type.
-- line 1129 ----------------------------------------
-- line 1451 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .               __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
         .           .           .                  .                  .                .                   .                  .                  .           		  const _Tp& __val, _Compare __comp)
         .           .           .                  .                  .                .                   .                  .                  .               {
         .           .           .                  .                  .                .                   .                  .                  .                 typedef typename iterator_traits<_ForwardIterator>::difference_type
         .           .           .                  .                  .                .                   .                  .                  .           	_DistanceType;
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .                 _DistanceType __len = std::distance(__first, __last);
         .           .           .                  .                  .                .                   .                  .                  .           
     1,024 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0                 while (__len > 0)
         .           .           .                  .                  .                .                   .                  .                  .           	{
       888 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         0                  0                0                   0                  0                  0           	  _DistanceType __half = __len >> 1;
         .           .           .                  .                  .                .                   .                  .                  .           	  _ForwardIterator __middle = __first;
         .           .           .                  .                  .                .                   .                  .                  .           	  std::advance(__middle, __half);
       512 ( 0.00%)  0           0                256 ( 0.00%)         0                0                   0                  0                  0           	  if (__comp(__middle, __val))
         .           .           .                  .                  .                .                   .                  .                  .           	    {
         .           .           .                  .                  .                .                   .                  .                  .           	      __first = __middle;
         .           .           .                  .                  .                .                   .                  .                  .           	      ++__first;
       136 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0           	      __len = __len - __half - 1;
         .           .           .                  .                  .                .                   .                  .                  .           	    }
         .           .           .                  .                  .                .                   .                  .                  .           	  else
         .           .           .                  .                  .                .                   .                  .                  .           	    __len = __half;
         .           .           .                  .                  .                .                   .                  .                  .           	}
         .           .           .                  .                  .                .                   .                  .                  .                 return __first;
         .           .           .                  .                  .                .                   .                  .                  .               }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             /**
-- line 1476 ----------------------------------------
-- line 1507 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .             { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             inline _GLIBCXX_CONSTEXPR unsigned
         .           .           .                  .                  .                .                   .                  .                  .             __lg(unsigned __n)
         .           .           .                  .                  .                .                   .                  .                  .             { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             inline _GLIBCXX_CONSTEXPR long
         .           .           .                  .                  .                .                   .                  .                  .             __lg(long __n)
        20 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0             { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             inline _GLIBCXX_CONSTEXPR unsigned long
         .           .           .                  .                  .                .                   .                  .                  .             __lg(unsigned long __n)
         .           .           .                  .                  .                .                   .                  .                  .             { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             inline _GLIBCXX_CONSTEXPR long long
         .           .           .                  .                  .                .                   .                  .                  .             __lg(long long __n)
         .           .           .                  .                  .                .                   .                  .                  .             { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
-- line 1523 ----------------------------------------
-- line 2044 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             /// This is an overload used by find algos for the Input Iterator case.
         .           .           .                  .                  .                .                   .                  .                  .             template<typename _InputIterator, typename _Predicate>
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               inline _InputIterator
         .           .           .                  .                  .                .                   .                  .                  .               __find_if(_InputIterator __first, _InputIterator __last,
         .           .           .                  .                  .                .                   .                  .                  .           	      _Predicate __pred, input_iterator_tag)
         .           .           .                  .                  .                .                   .                  .                  .               {
        17 ( 0.00%)  0           0                  7 ( 0.00%)         0                0                   0                  0                  0                 while (__first != __last && !__pred(__first))
         .           .           .                  .                  .                .                   .                  .                  .           	++__first;
         .           .           .                  .                  .                .                   .                  .                  .                 return __first;
         .           .           .                  .                  .                .                   .                  .                  .               }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             /// This is an overload used by find algos for the RAI case.
         .           .           .                  .                  .                .                   .                  .                  .             template<typename _RandomAccessIterator, typename _Predicate>
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               _RandomAccessIterator
         .           .           .                  .                  .                .                   .                  .                  .               __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
         .           .           .                  .                  .                .                   .                  .                  .           	      _Predicate __pred, random_access_iterator_tag)
         .           .           .                  .                  .                .                   .                  .                  .               {
         .           .           .                  .                  .                .                   .                  .                  .                 typename iterator_traits<_RandomAccessIterator>::difference_type
 1,000,733 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0           	__trip_count = (__last - __first) >> 2;
         .           .           .                  .                  .                .                   .                  .                  .           
 2,001,066 ( 0.01%)  7 ( 0.04%)  1 ( 0.01%)         0                  0                0                   0                  0                  0                 for (; __trip_count > 0; --__trip_count)
         .           .           .                  .                  .                .                   .                  .                  .           	{
       144 ( 0.00%)  0           0                  4 ( 0.00%)         0                0                   0                  0                  0           	  if (__pred(__first))
         .           .           .                  .                  .                .                   .                  .                  .           	    return __first;
         .           .           .                  .                  .                .                   .                  .                  .           	  ++__first;
         .           .           .                  .                  .                .                   .                  .                  .           
         8 ( 0.00%)  0           0                  4 ( 0.00%)         0                0                   0                  0                  0           	  if (__pred(__first))
         .           .           .                  .                  .                .                   .                  .                  .           	    return __first;
         .           .           .                  .                  .                .                   .                  .                  .           	  ++__first;
         .           .           .                  .                  .                .                   .                  .                  .           
         8 ( 0.00%)  0           0                  4 ( 0.00%)         0                0                   0                  0                  0           	  if (__pred(__first))
         .           .           .                  .                  .                .                   .                  .                  .           	    return __first;
         .           .           .                  .                  .                .                   .                  .                  .           	  ++__first;
         .           .           .                  .                  .                .                   .                  .                  .           
        12 ( 0.00%)  0           0                  4 ( 0.00%)         0                0                   0                  0                  0           	  if (__pred(__first))
         .           .           .                  .                  .                .                   .                  .                  .           	    return __first;
         .           .           .                  .                  .                .                   .                  .                  .           	  ++__first;
         .           .           .                  .                  .                .                   .                  .                  .           	}
         .           .           .                  .                  .                .                   .                  .                  .           
 3,501,950 ( 0.01%) 24 ( 0.14%)  6 ( 0.06%)         0                  0                0                   0                  0                  0                 switch (__last - __first)
         .           .           .                  .                  .                .                   .                  .                  .           	{
         .           .           .                  .                  .                .                   .                  .                  .           	case 3:
         8 ( 0.00%)  0           0                  2 ( 0.00%)         0                0                   0                  0                  0           	  if (__pred(__first))
         .           .           .                  .                  .                .                   .                  .                  .           	    return __first;
         .           .           .                  .                  .                .                   .                  .                  .           	  ++__first;
         .           .           .                  .                  .                .                   .                  .                  .           	  // FALLTHRU
         .           .           .                  .                  .                .                   .                  .                  .           	case 2:
        50 ( 0.00%)  3 ( 0.02%)  0                  6 ( 0.00%)         0                0                   0                  0                  0           	  if (__pred(__first))
         .           .           .                  .                  .                .                   .                  .                  .           	    return __first;
   500,000 ( 0.00%)  1 ( 0.01%)  1 ( 0.01%)         0                  0                0                   0                  0                  0           	  ++__first;
         .           .           .                  .                  .                .                   .                  .                  .           	  // FALLTHRU
         .           .           .                  .                  .                .                   .                  .                  .           	case 1:
 1,998,094 ( 0.01%)  0           0            500,013 ( 0.01%)         0                0                   2 ( 0.00%)         0                  0           	  if (__pred(__first))
   498,062 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0           	    return __first;
         .           .           .                  .                  .                .                   .                  .                  .           	  ++__first;
         .           .           .                  .                  .                .                   .                  .                  .           	  // FALLTHRU
         .           .           .                  .                  .                .                   .                  .                  .           	case 0:
         .           .           .                  .                  .                .                   .                  .                  .           	default:
       616 ( 0.00%)  0           0                245 ( 0.00%)         0                0                   0                  0                  0           	  return __last;
         .           .           .                  .                  .                .                   .                  .                  .           	}
         .           .           .                  .                  .                .                   .                  .                  .               }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             template<typename _Iterator, typename _Predicate>
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               inline _Iterator
         .           .           .                  .                  .                .                   .                  .                  .               __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
         .           .           .                  .                  .                .                   .                  .                  .               {
-- line 2113 ----------------------------------------
-- line 2115 ----------------------------------------
         .           .           .                  .                  .                .                   .                  .                  .           		       std::__iterator_category(__first));
         .           .           .                  .                  .                .                   .                  .                  .               }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .             template<typename _InputIterator, typename _Predicate>
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               typename iterator_traits<_InputIterator>::difference_type
         .           .           .                  .                  .                .                   .                  .                  .               __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
         .           .           .                  .                  .                .                   .                  .                  .               {
         4 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0                 typename iterator_traits<_InputIterator>::difference_type __n = 0;
        69 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0                 for (; __first != __last; ++__first)
         .           .           .                  .                  .                .                   .                  .                  .           	if (__pred(__first))
         2 ( 0.00%)  0           0                  0                  0                0                   0                  0                  0           	  ++__n;
         .           .           .                  .                  .                .                   .                  .                  .                 return __n;
         .           .           .                  .                  .                .                   .                  .                  .               }
         .           .           .                  .                  .                .                   .                  .                  .           
         .           .           .                  .                  .                .                   .                  .                  .           #if __cplusplus >= 201103L
         .           .           .                  .                  .                .                   .                  .                  .             template<typename _ForwardIterator1, typename _ForwardIterator2,
         .           .           .                  .                  .                .                   .                  .                  .           	   typename _BinaryPredicate>
         .           .           .                  .                  .                .                   .                  .                  .               _GLIBCXX20_CONSTEXPR
         .           .           .                  .                  .                .                   .                  .                  .               bool
-- line 2134 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/mriccobene/CLionProjects/silkworm/silkworm/node/huffman/decompressor.hpp
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr                  D1mr               DLmr           Dw           D1mw       DLmw       

-- line 34 ----------------------------------------
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .           namespace silkworm::huffman {
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .           class DecodingTable {
          .          .          .                   .                  .              .            .          .          .             public:
          .          .          .                   .                  .              .            .          .          .               //! The max bit length for tables (we don't use tables larger than 2^9)
          .          .          .                   .                  .              .            .          .          .               constexpr static std::size_t kMaxTableBitLength{9};
          .          .          .                   .                  .              .            .          .          .           
 81,461,944 ( 0.26%) 0          0          81,461,944 ( 1.23%)   678,511 ( 1.79%)   479 ( 0.01%)   0          0          0               [[nodiscard]] std::size_t bit_length() const { return bit_length_; }
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .             protected:
          .          .          .                   .                  .              .            .          .          .               explicit DecodingTable(std::size_t max_depth);
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               std::size_t bit_length_{0};
          .          .          .                   .                  .              .            .          .          .               std::size_t max_depth_;
          .          .          .                   .                  .              .            .          .          .           };
          .          .          .                   .                  .              .            .          .          .           
-- line 50 ----------------------------------------
-- line 51 ----------------------------------------
          .          .          .                   .                  .              .            .          .          .           class PatternTable;
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .           class CodeWord {
          .          .          .                   .                  .              .            .          .          .             public:
          .          .          .                   .                  .              .            .          .          .               explicit CodeWord();
          .          .          .                   .                  .              .            .          .          .               explicit CodeWord(uint16_t code, uint8_t length, ByteView pattern);
          .          .          .                   .                  .              .            .          .          .               explicit CodeWord(uint16_t code, uint8_t length, ByteView pattern, std::unique_ptr<PatternTable> table, CodeWord* next);
          .          .          .                   .                  .              .            .          .          .           
     64,448 ( 0.00%) 0          0              32,224 ( 0.00%)         0              0            0          0          0               [[nodiscard]] uint16_t code() const { return code_; }
 41,135,158 ( 0.13%) 0          0          41,135,158 ( 0.62%) 1,733,030 ( 4.58%) 3,786 ( 0.07%)   0          0          0               [[nodiscard]] uint8_t code_length() const { return code_length_; }
 76,222,660 ( 0.25%) 0          0          76,222,660 ( 1.15%)   291,349 ( 0.77%)   617 ( 0.01%)   0          0          0               [[nodiscard]] ByteView pattern() const { return pattern_; }
          .          .          .                   .                  .              .            .          .          .               [[nodiscard]] PatternTable* table() const { return table_.get(); }
          .          .          .                   .                  .              .            .          .          .               [[nodiscard]] CodeWord* next() const { return next_; }
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               void reset_content(uint16_t code, uint8_t length, ByteView pattern);
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               void set_next(CodeWord* next);
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .             private:
-- line 69 ----------------------------------------
-- line 94 ----------------------------------------
          .          .          .                   .                  .              .            .          .          .               //! @details Tables with bit length greater than threshold will be condensed. To disable condensing completely
          .          .          .                   .                  .              .            .          .          .               //! set `condensed_table_bit_length_threshold` to 9; to enable condensing for all tables, set it to 0; to
          .          .          .                   .                  .              .            .          .          .               //! enable condensing for tables of size greater than 64, set it to 6.
          .          .          .                   .                  .              .            .          .          .               static void set_condensed_table_bit_length_threshold(std::size_t condensed_table_bit_length_threshold);
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               explicit PatternTable(std::size_t max_depth);
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               [[nodiscard]] const CodeWord* codeword(std::size_t code) const {
123,308,802 ( 0.40%) 0          0                   0                  0              0            0          0          0                   return code < codewords_.size() ? codewords_[code].get() : nullptr;
          .          .          .                   .                  .              .            .          .          .               }
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               [[nodiscard]] std::size_t num_codewords() const { return codewords_.size(); }
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               [[nodiscard]] const CodeWord* search_condensed(uint16_t code) const;
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               std::size_t build_condensed(std::span<Pattern> patterns);
          .          .          .                   .                  .              .            .          .          .           
-- line 110 ----------------------------------------
-- line 129 ----------------------------------------
          .          .          .                   .                  .              .            .          .          .               friend std::ostream& operator<<(std::ostream& out, const PatternTable& pt);
          .          .          .                   .                  .              .            .          .          .           };
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .           struct Position {
          .          .          .                   .                  .              .            .          .          .               uint64_t depth;
          .          .          .                   .                  .              .            .          .          .               uint64_t value;
          .          .          .                   .                  .              .            .          .          .           };
          .          .          .                   .                  .              .            .          .          .           
        560 ( 0.00%) 4 ( 0.02%) 4 ( 0.04%)        210 ( 0.00%)         3 ( 0.00%)     0          245 ( 0.00%) 1 ( 0.00%) 0           class PositionTable : public DecodingTable {
          .          .          .                   .                  .              .            .          .          .             public:
          .          .          .                   .                  .              .            .          .          .               explicit PositionTable(std::size_t max_depth);
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               [[nodiscard]] std::size_t num_positions() const { return positions_.size(); }
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               [[nodiscard]] uint64_t position(std::size_t code) const {
200,556,650 ( 0.65%) 2 ( 0.01%) 1 ( 0.01%) 40,111,330 ( 0.61%)   443,496 ( 1.17%)   670 ( 0.01%)   0          0          0                   return code < positions_.size() ? positions_[code] : 0;
          .          .          .                   .                  .              .            .          .          .               }
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               [[nodiscard]] uint8_t length(std::size_t code) const {
121,077,030 ( 0.39%) 1 ( 0.01%) 1 ( 0.01%) 40,359,010 ( 0.61%)    82,552 ( 0.22%)    91 ( 0.00%)   0          0          0                   return code < lengths_.size() ? lengths_[code] : 0;
          .          .          .                   .                  .              .            .          .          .               }
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               [[nodiscard]] PositionTable* child(std::size_t code) const {
    743,040 ( 0.00%) 0          0                   0                  0              0            0          0          0                   return code < children_.size() ? children_[code].get() : nullptr;
          .          .          .                   .                  .              .            .          .          .               }
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .               int build(std::span<Position> positions);
          .          .          .                   .                  .              .            .          .          .           
          .          .          .                   .                  .              .            .          .          .             private:
          .          .          .                   .                  .              .            .          .          .               int build_tree(
          .          .          .                   .                  .              .            .          .          .                   std::span<Position> positions,
          .          .          .                   .                  .              .            .          .          .                   uint64_t highest_depth,
-- line 160 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/mriccobene/CLionProjects/silkworm/silkworm/infra/common/log.cpp
--------------------------------------------------------------------------------
Ir                   I1mr        ILmr       Dr                   D1mr         DLmr       Dw          D1mw       DLmw       

-- line 28 ----------------------------------------
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           #include <silkworm/infra/grpc/common/util.hpp>
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           namespace silkworm::log {
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           //! The fixed size for thread name in log traces
          .           .          .                    .            .          .           .          .          .           constexpr auto kThreadNameFixedSize{11};
          .           .          .                    .            .          .           .          .          .           
          8 ( 0.00%)  0          0                    0            0          0           2 ( 0.00%) 0          0           static Settings settings_{};
          .           .          .                    .            .          .           .          .          .           static std::mutex out_mtx{};
          8 ( 0.00%)  0          0                    0            0          0           0          0          0           static std::unique_ptr<std::fstream> file_{nullptr};
          .           .          .                    .            .          .           .          .          .           thread_local std::string thread_name_{};
          .           .          .                    .            .          .           .          .          .           
          7 ( 0.00%)  2 ( 0.01%) 2 ( 0.02%)           0            0          0           4 ( 0.00%) 0          0           void init(Settings& settings) {
          .           .          .                    .            .          .           .          .          .               settings_ = settings;
          2 ( 0.00%)  0          0                    1 ( 0.00%)   0          0           0          0          0               if (!settings_.log_file.empty()) {
          .           .          .                    .            .          .           .          .          .                   tee_file(std::filesystem::path(settings.log_file));
          .           .          .                    .            .          .           .          .          .               }
          2 ( 0.00%)  0          0                    1 ( 0.00%)   0          0           0          0          0               if (settings.log_grpc) {
          3 ( 0.00%)  2 ( 0.01%) 2 ( 0.02%)           0            0          0           1 ( 0.00%) 0          0                   gpr_set_log_function(gpr_silkworm_log);
          .           .          .                    .            .          .           .          .          .               }
          4 ( 0.00%)  0          0                    2 ( 0.00%)   0          0           0          0          0               init_terminal();
          5 ( 0.00%)  0          0                    4 ( 0.00%)   0          0           0          0          0           }
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           void tee_file(const std::filesystem::path& path) {
          .           .          .                    .            .          .           .          .          .               file_ = std::make_unique<std::fstream>(path.string(), std::ios::out | std::ios::app);
          .           .          .                    .            .          .           .          .          .               if (!file_->is_open()) {
          .           .          .                    .            .          .           .          .          .                   file_.reset();
          .           .          .                    .            .          .           .          .          .                   throw std::runtime_error("Could not open file " + path.string());
          .           .          .                    .            .          .           .          .          .               }
          .           .          .                    .            .          .           .          .          .           }
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           Level get_verbosity() { return settings_.log_verbosity; }
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           void set_verbosity(Level level) { settings_.log_verbosity = level; }
          .           .          .                    .            .          .           .          .          .           
417,787,112 ( 1.35%)  9 ( 0.05%) 4 ( 0.04%) 208,893,556 ( 3.16%) 851 ( 0.00%) 5 ( 0.00%)  0          0          0           bool test_verbosity(Level level) { return level <= settings_.log_verbosity; }
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           //! Set the current thread name resizing it to a fixed size
          .           .          .                    .            .          .           .          .          .           void set_thread_name(const char* name) {
          .           .          .                    .            .          .           .          .          .               thread_name_ = std::string(name);
          .           .          .                    .            .          .           .          .          .               thread_name_.resize(kThreadNameFixedSize, ' ');
          .           .          .                    .            .          .           .          .          .           }
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           std::string get_thread_name() {
-- line 72 ----------------------------------------
-- line 74 ----------------------------------------
          .           .          .                    .            .          .           .          .          .                   std::stringstream ss;
          .           .          .                    .            .          .           .          .          .                   ss << std::this_thread::get_id();
          .           .          .                    .            .          .           .          .          .                   thread_name_ = ss.str();
          .           .          .                    .            .          .           .          .          .               }
          .           .          .                    .            .          .           .          .          .               return thread_name_;
          .           .          .                    .            .          .           .          .          .           }
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           static inline std::pair<const char*, const char*> get_level_settings(Level level) {
         36 ( 0.00%)  0          0                    6 ( 0.00%)   6 ( 0.00%) 2 ( 0.00%)  0          0          0               switch (level) {
          .           .          .                    .            .          .           .          .          .                   case Level::kTrace:
          .           .          .                    .            .          .           .          .          .                       return {"TRACE", kColorCoal};
          .           .          .                    .            .          .           .          .          .                   case Level::kDebug:
          .           .          .                    .            .          .           .          .          .                       return {"DEBUG", kBackgroundPurple};
          .           .          .                    .            .          .           .          .          .                   case Level::kInfo:
         24 ( 0.00%) 10 ( 0.06%) 4 ( 0.04%)           0            0          0           0          0          0                       return {" INFO", kColorGreen};
          .           .          .                    .            .          .           .          .          .                   case Level::kWarning:
          .           .          .                    .            .          .           .          .          .                       return {" WARN", kColorOrangeHigh};
          .           .          .                    .            .          .           .          .          .                   case Level::kError:
          .           .          .                    .            .          .           .          .          .                       return {"ERROR", kColorRed};
          .           .          .                    .            .          .           .          .          .                   case Level::kCritical:
          .           .          .                    .            .          .           .          .          .                       return {" CRIT", kBackgroundRed};
          .           .          .                    .            .          .           .          .          .                   default:
          .           .          .                    .            .          .           .          .          .                       return {"     ", kColorReset};
          .           .          .                    .            .          .           .          .          .               }
          .           .          .                    .            .          .           .          .          .           }
          .           .          .                    .            .          .           .          .          .           
         60 ( 0.00%)  6 ( 0.04%) 2 ( 0.02%)           6 ( 0.00%)   0          0          18 ( 0.00%) 0          0           struct separate_thousands : std::numpunct<char> {
          .           .          .                    .            .          .           .          .          .               char separator;
         18 ( 0.00%)  0          0                    0            0          0          12 ( 0.00%) 0          0               explicit separate_thousands(char sep) : separator(sep) {}
         18 ( 0.00%)  4 ( 0.02%) 2 ( 0.02%)          12 ( 0.00%)   0          0           0          0          0               [[nodiscard]] char do_thousands_sep() const override { return separator; }
         18 ( 0.00%)  0          0                    6 ( 0.00%)   0          0           0          0          0               [[nodiscard]] string_type do_grouping() const override { return "\3"; }  // groups of 3 digit
          .           .          .                    .            .          .           .          .          .           };
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           void prepare_for_logging(std::ostream& ss) {
          .           .          .                    .            .          .           .          .          .               if (settings_.log_thousands_sep != 0) {
          .           .          .                    .            .          .           .          .          .                   ss.imbue(std::locale(ss.getloc(), new separate_thousands(settings_.log_thousands_sep)));
          .           .          .                    .            .          .           .          .          .               }
          .           .          .                    .            .          .           .          .          .           }
          .           .          .                    .            .          .           .          .          .           
        132 ( 0.00%) 11 ( 0.06%) 4 ( 0.04%)          24 ( 0.00%)   7 ( 0.00%) 2 ( 0.00%) 54 ( 0.00%) 7 ( 0.00%) 2 ( 0.00%)  BufferBase::BufferBase(Level level) : should_print_(level <= settings_.log_verbosity) {
         12 ( 0.00%)  0          0                    6 ( 0.00%)   0          0           0          0          0               if (!should_print_) return;
          .           .          .                    .            .          .           .          .          .           
         12 ( 0.00%)  6 ( 0.04%) 2 ( 0.02%)           6 ( 0.00%)   0          0           0          0          0               if (settings_.log_thousands_sep != 0) {
        120 ( 0.00%)  6 ( 0.04%) 2 ( 0.02%)           6 ( 0.00%)   0          0          36 ( 0.00%) 0          0                   ss_.imbue(std::locale(ss_.getloc(), new separate_thousands(settings_.log_thousands_sep)));
          .           .          .                    .            .          .           .          .          .               }
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .               auto [prefix, color] = get_level_settings(level);
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .               // Prefix
          .           .          .                    .            .          .           .          .          .               ss_ << kColorReset << " " << color << prefix << kColorReset << " ";
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .               // TimeStamp
         28 ( 0.00%)  1 ( 0.01%) 1 ( 0.01%)           7 ( 0.00%)   5 ( 0.00%) 2 ( 0.00%)  3 ( 0.00%) 0          0               static const absl::TimeZone tz{settings_.log_utc ? absl::LocalTimeZone() : absl::UTCTimeZone()};
         18 ( 0.00%)  4 ( 0.02%) 1 ( 0.01%)           0            0          0           6 ( 0.00%) 0          0               absl::Time now{absl::Now()};
         42 ( 0.00%)  5 ( 0.03%) 2 ( 0.02%)           6 ( 0.00%)   0          0           6 ( 0.00%) 0          0               ss_ << kColorCyan << "[" << absl::FormatTime("%m-%d|%H:%M:%E3S", now, tz) << " " << tz << "] " << kColorReset;
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .               // ThreadId
         12 ( 0.00%)  0          0                    6 ( 0.00%)   0          0           0          0          0               if (settings_.log_threads) {
          .           .          .                    .            .          .           .          .          .                   ss_ << "[" << get_thread_name() << "] ";
          .           .          .                    .            .          .           .          .          .               }
         66 ( 0.00%)  4 ( 0.02%) 2 ( 0.02%)          54 ( 0.00%)   0          0           0          0          0           }
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .           BufferBase::BufferBase(Level level, std::string_view msg, const Args& args) : BufferBase(level) {
          .           .          .                    .            .          .           .          .          .               append(msg, args);
          .           .          .                    .            .          .           .          .          .           }
          .           .          .                    .            .          .           .          .          .           
         72 ( 0.00%)  8 ( 0.05%) 4 ( 0.04%)           6 ( 0.00%)   0          0          42 ( 0.00%) 0          0           void BufferBase::flush() {
         18 ( 0.00%)  0          0                    6 ( 0.00%)   0          0           0          0          0               if (!should_print_) return;
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .               // Pattern to identify colorization
         36 ( 0.00%)  7 ( 0.04%) 3 ( 0.03%)           6 ( 0.00%)   4 ( 0.00%) 2 ( 0.00%)  3 ( 0.00%) 0          0               static const std::regex color_pattern("(\\\x1b\\[[0-9;]{1,}m)");
          .           .          .                    .            .          .           .          .          .           
          .           .          .                    .            .          .           .          .          .               bool colorized{true};
          .           .          .                    .            .          .           .          .          .               std::string line{ss_.str()};
         12 ( 0.00%)  5 ( 0.03%) 2 ( 0.02%)           6 ( 0.00%)   1 ( 0.00%) 0           0          0          0               if (settings_.log_nocolor) {
          .           .          .                    .            .          .           .          .          .                   line = std::regex_replace(line, color_pattern, "");
          .           .          .                    .            .          .           .          .          .                   colorized = false;
          .           .          .                    .            .          .           .          .          .               }
          .           .          .                    .            .          .           .          .          .               std::unique_lock out_lck{out_mtx};
         18 ( 0.00%)  0          0                   12 ( 0.00%)   0          0           0          0          0               auto& out = settings_.log_std_out ? std::cout : std::cerr;
          .           .          .                    .            .          .           .          .          .               out << line << std::endl;
         12 ( 0.00%)  0          0                    0            0          0           0          0          0               if (file_ && file_->is_open()) {
          .           .          .                    .            .          .           .          .          .                   if (colorized) {
          .           .          .                    .            .          .           .          .          .                       line = std::regex_replace(line, color_pattern, "");
          .           .          .                    .            .          .           .          .          .                   }
          .           .          .                    .            .          .           .          .          .                   *file_ << line << std::endl;
          .           .          .                    .            .          .           .          .          .               }
         66 ( 0.00%)  1 ( 0.01%) 0                   54 ( 0.00%)   2 ( 0.00%) 0           0          0          0           }
          .           .          .                    .            .          .           .          .          .           
         14 ( 0.00%)  0          0                    4 ( 0.00%)   0          0           4 ( 0.00%) 0          0           }  // namespace silkworm::log

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/charconv.h
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr               D1mr            DLmr       Dw               D1mw       DLmw       

-- line 44 ----------------------------------------
         .          .          .                .               .          .                .          .          .             // Generic implementation for arbitrary bases.
         .          .          .                .               .          .                .          .          .             template<typename _Tp>
         .          .          .                .               .          .                .          .          .               _GLIBCXX14_CONSTEXPR unsigned
         .          .          .                .               .          .                .          .          .               __to_chars_len(_Tp __value, int __base = 10) noexcept
         .          .          .                .               .          .                .          .          .               {
         .          .          .                .               .          .                .          .          .                 static_assert(is_integral<_Tp>::value, "implementation bug");
         .          .          .                .               .          .                .          .          .                 static_assert(is_unsigned<_Tp>::value, "implementation bug");
         .          .          .                .               .          .                .          .          .           
   499,004 ( 0.00%) 0          0                0               0          0                0          0          0                 unsigned __n = 1;
         .          .          .                .               .          .                .          .          .                 const unsigned __b2 = __base  * __base;
         .          .          .                .               .          .                .          .          .                 const unsigned __b3 = __b2 * __base;
         .          .          .                .               .          .                .          .          .                 const unsigned long __b4 = __b3 * __base;
         .          .          .                .               .          .                .          .          .                 for (;;)
         .          .          .                .               .          .                .          .          .           	{
 1,980,008 ( 0.01%) 0          0                0               0          0                0          0          0           	  if (__value < (unsigned)__base) return __n;
 2,199,984 ( 0.01%) 0          0                0               0          0                0          0          0           	  if (__value < __b2) return __n + 1;
   999,804 ( 0.00%) 2 ( 0.01%) 2 ( 0.02%)       0               0          0                0          0          0           	  if (__value < __b3) return __n + 2;
 1,007,008 ( 0.00%) 0          0                0               0          0                0          0          0           	  if (__value < __b4) return __n + 3;
 2,949,012 ( 0.01%) 5 ( 0.03%) 4 ( 0.04%)       0               0          0                0          0          0           	  __value /= __b4;
   490,002 ( 0.00%) 0          0                0               0          0                0          0          0           	  __n += 4;
         .          .          .                .               .          .                .          .          .           	}
         .          .          .                .               .          .                .          .          .               }
         .          .          .                .               .          .                .          .          .           
         .          .          .                .               .          .                .          .          .             // Write an unsigned integer value to the range [first,first+len).
         .          .          .                .               .          .                .          .          .             // The caller is required to provide a buffer of exactly the right size
         .          .          .                .               .          .                .          .          .             // (which can be determined by the __to_chars_len function).
         .          .          .                .               .          .                .          .          .             template<typename _Tp>
         .          .          .                .               .          .                .          .          .               void
-- line 71 ----------------------------------------
-- line 75 ----------------------------------------
         .          .          .                .               .          .                .          .          .                 static_assert(is_unsigned<_Tp>::value, "implementation bug");
         .          .          .                .               .          .                .          .          .           
         .          .          .                .               .          .                .          .          .                 static constexpr char __digits[201] =
         .          .          .                .               .          .                .          .          .           	"0001020304050607080910111213141516171819"
         .          .          .                .               .          .                .          .          .           	"2021222324252627282930313233343536373839"
         .          .          .                .               .          .                .          .          .           	"4041424344454647484950515253545556575859"
         .          .          .                .               .          .                .          .          .           	"6061626364656667686970717273747576777879"
         .          .          .                .               .          .                .          .          .           	"8081828384858687888990919293949596979899";
 1,000,002 ( 0.00%) 0          0          500,000 ( 0.01%)      0          0                0          0          0                 unsigned __pos = __len - 1;
 2,979,908 ( 0.01%) 0          0                0               0          0                0          0          0                 while (__val >= 100)
         .          .          .                .               .          .                .          .          .           	{
13,868,528 ( 0.04%) 1 ( 0.01%) 1 ( 0.01%)       0               0          0                0          0          0           	  auto const __num = (__val % 100) * 2;
   989,904 ( 0.00%) 0          0                0               0          0                0          0          0           	  __val /= 100;
 2,969,716 ( 0.01%) 2 ( 0.01%) 2 ( 0.02%) 989,904 ( 0.01%) 13,318 ( 0.04%) 4 ( 0.00%) 989,904 ( 0.04%) 0          0           	  __first[__pos] = __digits[__num + 1];
 2,969,712 ( 0.01%) 0          0          989,904 ( 0.01%)      2 ( 0.00%) 2 ( 0.00%) 989,904 ( 0.04%) 0          0           	  __first[__pos - 1] = __digits[__num];
   989,904 ( 0.00%) 0          0                0               0          0                0          0          0           	  __pos -= 2;
         .          .          .                .               .          .                .          .          .           	}
 1,000,004 ( 0.00%) 0          0                0               0          0                0          0          0                 if (__val >= 10)
         .          .          .                .               .          .                .          .          .           	{
         .          .          .                .               .          .                .          .          .           	  auto const __num = __val * 2;
 1,727,270 ( 0.01%) 0          0          818,180 ( 0.01%)    453 ( 0.00%) 4 ( 0.00%) 909,090 ( 0.03%) 0          0           	  __first[1] = __digits[__num + 1];
   409,090 ( 0.00%) 0          0          409,090 ( 0.01%)      0          0                0          0          0           	  __first[0] = __digits[__num];
         .          .          .                .               .          .                .          .          .           	}
         .          .          .                .               .          .                .          .          .                 else
   500,002 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)       0               0          0                0          0          0           	__first[0] = '0' + __val;
         .          .          .                .               .          .                .          .          .               }
         .          .          .                .               .          .                .          .          .           
         .          .          .                .               .          .                .          .          .           } // namespace __detail
         .          .          .                .               .          .                .          .          .           _GLIBCXX_END_NAMESPACE_VERSION
         .          .          .                .               .          .                .          .          .           } // namespace std
         .          .          .                .               .          .                .          .          .           #endif // C++11
         .          .          .                .               .          .                .          .          .           #endif // _GLIBCXX_CHARCONV_H

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/mriccobene/CLionProjects/silkworm/silkworm/core/common/util.cpp
--------------------------------------------------------------------------------
Ir                  I1mr       ILmr       Dr                  D1mr           DLmr       Dw                  D1mw       DLmw       

-- line 52 ----------------------------------------
         .          .          .                   .              .          .                   .          .          .               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         .          .          .                   .              .          .                   .          .          .               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         .          .          .                   .              .          .                   .          .          .               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         .          .          .                   .              .          .                   .          .          .               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         .          .          .                   .              .          .                   .          .          .               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         .          .          .                   .              .          .                   .          .          .               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
         .          .          .                   .              .          .                   .          .          .               0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
         .          .          .                   .              .          .                   .          .          .           
 1,000,000 ( 0.00%) 2 ( 0.01%) 1 ( 0.01%)          0              0          0                   0          0          0           ByteView zeroless_view(ByteView data) {
         .          .          .                   .              .          .                   .          .          .               const auto is_zero_byte = [](const auto& b) { return b == 0x0; };
         .          .          .                   .              .          .                   .          .          .               const auto first_nonzero_byte_it{as_range::find_if_not(data, is_zero_byte)};
         .          .          .                   .              .          .                   .          .          .               return data.substr(static_cast<size_t>(std::distance(data.begin(), first_nonzero_byte_it)));
 1,000,000 ( 0.00%) 0          0             500,000 ( 0.01%)     0          0                   0          0          0           }
         .          .          .                   .              .          .                   .          .          .           
10,000,100 ( 0.03%) 2 ( 0.01%) 2 ( 0.02%)          0              0          0           5,000,050 ( 0.18%) 0          0           std::string to_hex(ByteView bytes, bool with_prefix) {
         .          .          .                   .              .          .                   .          .          .               static const char* kHexDigits{"0123456789abcdef"};
 3,000,030 ( 0.01%) 0          0                   0              0          0                   0          0          0               std::string out(bytes.length() * 2 + (with_prefix ? 2 : 0), '\0');
         .          .          .                   .              .          .                   .          .          .               char* dest{&out[0]};
 2,000,020 ( 0.01%) 0          0                   0              0          0                   0          0          0               if (with_prefix) {
        30 ( 0.00%) 0          0                   0              0          0                  10 ( 0.00%) 0          0                   *dest++ = '0';
        10 ( 0.00%) 0          0                   0              0          0                   0          0          0                   *dest++ = 'x';
         .          .          .                   .              .          .                   .          .          .               }
52,492,636 ( 0.17%) 0          0                   0              0          0                   0          0          0               for (const auto& b : bytes) {
98,989,092 ( 0.32%) 0          0          32,996,364 ( 0.50%) 2,642 ( 0.01%) 4 ( 0.00%) 16,498,182 ( 0.59%) 0          0                   *dest++ = kHexDigits[b >> 4];    // Hi
65,992,728 ( 0.21%) 0          0          32,996,364 ( 0.50%)   738 ( 0.00%) 3 ( 0.00%) 16,498,182 ( 0.59%) 0          0                   *dest++ = kHexDigits[b & 0x0f];  // Lo
         .          .          .                   .              .          .                   .          .          .               }
         .          .          .                   .              .          .                   .          .          .               return out;
 7,000,070 ( 0.02%) 0          0           6,000,060 ( 0.09%)     0          0                   0          0          0           }
         .          .          .                   .              .          .                   .          .          .           
         .          .          .                   .              .          .                   .          .          .           std::string abridge(std::string_view input, size_t length) {
         .          .          .                   .              .          .                   .          .          .               if (input.length() <= length) {
         .          .          .                   .              .          .                   .          .          .                   return std::string(input);
         .          .          .                   .              .          .                   .          .          .               }
         .          .          .                   .              .          .                   .          .          .               return std::string(input.substr(0, length)) + "...";
         .          .          .                   .              .          .                   .          .          .           }
         .          .          .                   .              .          .                   .          .          .           
        52 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)         52 ( 0.00%)     3 ( 0.00%) 3 ( 0.00%)          0          0          0           static inline uint8_t unhex_lut(uint8_t x) { return kUnhexTable[x]; }
        60 ( 0.00%) 3 ( 0.02%) 3 ( 0.03%)         52 ( 0.00%)     2 ( 0.00%) 2 ( 0.00%)          0          0          0           static inline uint8_t unhex_lut4(uint8_t x) { return kUnhexTable4[x]; }
         .          .          .                   .              .          .                   .          .          .           
         .          .          .                   .              .          .                   .          .          .           std::optional<uint8_t> decode_hex_digit(char ch) noexcept {
         .          .          .                   .              .          .                   .          .          .               auto ret{unhex_lut(static_cast<uint8_t>(ch))};
         .          .          .                   .              .          .                   .          .          .               if (ret == 0xff) {
         .          .          .                   .              .          .                   .          .          .                   return std::nullopt;
         .          .          .                   .              .          .                   .          .          .               }
         .          .          .                   .              .          .                   .          .          .               return ret;
         .          .          .                   .              .          .                   .          .          .           }
         .          .          .                   .              .          .                   .          .          .           
        28 ( 0.00%) 3 ( 0.02%) 3 ( 0.03%)          2 ( 0.00%)     0          0                  14 ( 0.00%) 0          0           std::optional<Bytes> from_hex(std::string_view hex) noexcept {
         .          .          .                   .              .          .                   .          .          .               if (has_hex_prefix(hex)) {
         .          .          .                   .              .          .                   .          .          .                   hex.remove_prefix(2);
         .          .          .                   .              .          .                   .          .          .               }
         .          .          .                   .              .          .                   .          .          .               if (hex.empty()) {
         .          .          .                   .              .          .                   .          .          .                   return Bytes{};
         .          .          .                   .              .          .                   .          .          .               }
         .          .          .                   .              .          .                   .          .          .           
         4 ( 0.00%) 0          0                   0              0          0                   0          0          0               size_t pos(hex.length() & 1);  // "[0x]1" is legit and has to be treated as "[0x]01"
         6 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)          0              0          0                   0          0          0               Bytes out((hex.length() + pos) / 2, '\0');
         .          .          .                   .              .          .                   .          .          .               const char* src{const_cast<char*>(hex.data())};
         2 ( 0.00%) 0          0                   0              0          0                   0          0          0               const char* last = src + hex.length();
         .          .          .                   .              .          .                   .          .          .               uint8_t* dst{&out[0]};
         .          .          .                   .              .          .                   .          .          .           
         4 ( 0.00%) 0          0                   0              0          0                   0          0          0               if (pos) {
         .          .          .                   .              .          .                   .          .          .                   auto b{unhex_lut(static_cast<uint8_t>(*src++))};
         .          .          .                   .              .          .                   .          .          .                   if (b == 0xff) {
         .          .          .                   .              .          .                   .          .          .                       return std::nullopt;
         .          .          .                   .              .          .                   .          .          .                   }
         .          .          .                   .              .          .                   .          .          .                   *dst++ = b;
         .          .          .                   .              .          .                   .          .          .               }
         .          .          .                   .              .          .                   .          .          .           
         .          .          .                   .              .          .                   .          .          .               // following "while" is unrolling the loop when we have >= 4 target bytes
         .          .          .                   .              .          .                   .          .          .               // this is optional, but 5-10% faster
        38 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)          0              0          0                   0          0          0               while (last - src >= 8) {
         .          .          .                   .              .          .                   .          .          .                   auto a{unhex_lut4(static_cast<uint8_t>(*src++))};
         .          .          .                   .              .          .                   .          .          .                   auto b{unhex_lut(static_cast<uint8_t>(*src++))};
         .          .          .                   .              .          .                   .          .          .                   auto c{unhex_lut4(static_cast<uint8_t>(*src++))};
         .          .          .                   .              .          .                   .          .          .                   auto d{unhex_lut(static_cast<uint8_t>(*src++))};
         .          .          .                   .              .          .                   .          .          .                   auto e{unhex_lut4(static_cast<uint8_t>(*src++))};
         .          .          .                   .              .          .                   .          .          .                   auto f{unhex_lut(static_cast<uint8_t>(*src++))};
         .          .          .                   .              .          .                   .          .          .                   auto g{unhex_lut4(static_cast<uint8_t>(*src++))};
         .          .          .                   .              .          .                   .          .          .                   auto h{unhex_lut(static_cast<uint8_t>(*src++))};
        72 ( 0.00%) 0          0                   0              0          0                   0          0          0                   if ((b | d | f | h) == 0xff || (a | c | e | g) == 0xff) {
         .          .          .                   .              .          .                   .          .          .                       return std::nullopt;
         .          .          .                   .              .          .                   .          .          .                   }
        12 ( 0.00%) 0          0                   0              0          0                   6 ( 0.00%) 0          0                   *dst++ = a | b;
        12 ( 0.00%) 0          0                   0              0          0                   6 ( 0.00%) 0          0                   *dst++ = c | d;
        12 ( 0.00%) 0          0                   0              0          0                   6 ( 0.00%) 0          0                   *dst++ = e | f;
        18 ( 0.00%) 0          0                   0              0          0                   6 ( 0.00%) 0          0                   *dst++ = g | h;
         .          .          .                   .              .          .                   .          .          .               }
         .          .          .                   .              .          .                   .          .          .           
        10 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)          0              0          0                   0          0          0               while (src < last) {
         .          .          .                   .              .          .                   .          .          .                   auto a{unhex_lut4(static_cast<uint8_t>(*src++))};
         .          .          .                   .              .          .                   .          .          .                   auto b{unhex_lut(static_cast<uint8_t>(*src++))};
         8 ( 0.00%) 1 ( 0.01%) 1 ( 0.01%)          0              0          0                   0          0          0                   if (a == 0xff || b == 0xff) {
         .          .          .                   .              .          .                   .          .          .                       return std::nullopt;
         .          .          .                   .              .          .                   .          .          .                   }
         6 ( 0.00%) 0          0                   0              0          0                   2 ( 0.00%) 0          0                   *dst++ = a | b;
         .          .          .                   .              .          .                   .          .          .               }
         .          .          .                   .              .          .                   .          .          .               return out;
        24 ( 0.00%) 3 ( 0.02%) 3 ( 0.03%)         18 ( 0.00%)     0          0                   0          0          0           }
         .          .          .                   .              .          .                   .          .          .           
         .          .          .                   .              .          .                   .          .          .           inline bool case_insensitive_char_comparer(char a, char b) { return (tolower(a) == tolower(b)); }
         .          .          .                   .              .          .                   .          .          .           
         .          .          .                   .              .          .                   .          .          .           bool iequals(const std::string_view a, const std::string_view b) {
         .          .          .                   .              .          .                   .          .          .               return (a.size() == b.size() && std::equal(a.begin(), a.end(), b.begin(), case_insensitive_char_comparer));
         .          .          .                   .              .          .                   .          .          .           }
         .          .          .                   .              .          .                   .          .          .           
         .          .          .                   .              .          .                   .          .          .           std::optional<uint64_t> parse_size(const std::string& sizestr) {
-- line 158 ----------------------------------------

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./malloc/./malloc/malloc.c
  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
  ./string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
Ir                      I1mr           ILmr           Dr                     D1mr                DLmr               Dw                     D1mw               DLmw               
--------------------------------------------------------------------------------
29,350,047,551 (94.60%) 3,181 (18.60%) 2,012 (21.16%) 6,147,265,231 (93.12%) 30,568,319 (80.73%) 3,189,686 (61.77%) 2,529,321,878 (90.80%) 2,434,459 (77.71%) 2,057,245 (86.91%)  events annotated
